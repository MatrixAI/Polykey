!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.polykey=t():e.polykey=t()}(this,(function(){return function(e){var t={};function r(s){if(t[s])return t[s].exports;var a=t[s]={i:s,l:!1,exports:{}};return e[s].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(s,a,function(t){return e[t]}.bind(null,a));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=5)}([function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("crypto")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e,t){this.ip=e,this.port=t}static parse(e){const t=e.split(":"),r=t[0],a=t[1];return new s(r,a)}}t.Address=s,s.prototype.toString=function(){return`${this.ip}:${this.port}`};t.default=class{constructor(e,t=[],r){this.publicKey=e,this.addresses=new Set(t.map(e=>s.parse(e))),this.connectedAddr=r?s.parse(r):void 0}connect(e){this.addresses.has(e)||this.addresses.add(e),this.connectedAddr=e}disconnect(){this.connectedAddr=void 0}}},function(e,t,r){"use strict";(function(e){var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(r(0)),i=s(r(17)),o=s(r(3));console.log(e);t.default=class{static loadProto(t){const r=new i.default.Root;return r.resolvePath=(t,r)=>a.default.join(e,r),r.loadSync(t)}static encodePeerInfo(e){var t;const r=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),s=[];for(const t of e.addresses)s.push(t.toString());const a={pubKey:e.publicKey,addresses:s,connectedAddr:null===(t=e.connectedAddr)||void 0===t?void 0:t.toString()},i=r.verify(a);if(i)throw Error(i);const o=r.create(a);return r.encode(o).finish()}static decodePeerInfo(e){const t=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),r=t.decode(e),s=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return new o.default(s.pubKey,s.addresses,s.connectedAddr)}static encodeHandshakeMessage(e,t,r,s){const a=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),i={targetPubKey:e,requestingPubKey:t,message:r,responsePeerInfo:s?this.encodePeerInfo(s):void 0},o=a.verify(i);if(o)throw Error(o);const n=a.create(i);return a.encode(n).finish()}static decodeHandshakeMessage(e){const t=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),r=t.decode(e),s=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return{targetPubKey:Buffer.from(s.targetPubKey,"base64"),requestingPubKey:Buffer.from(s.requestingPubKey,"base64"),message:Buffer.from(s.message,"base64"),responsePeerInfo:s.responsePeerInfo?this.decodePeerInfo(Buffer.from(s.responsePeerInfo,"base64")):void 0}}}}).call(this,"/index.js")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=r(6);t.default=s.default},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(r(7)),i=s(r(1)),o=s(r(0)),n=s(r(2)),u=s(r(8)),d=s(r(9)),c=s(r(13)),l=s(r(16)),y=s(r(3)),f=s(r(4)),h=s(r(18));t.default=class{constructor(e,t,r=a.default.homedir()+"/.polykey"){if(this.polykeyPath=r,this.metadataPath=o.default.join(r,"metadata"),this.fs=i.default,this.keyManager=null!=e?e:new c.default(r),this.peerDiscovery=null!=t?t:new h.default(this.peerStore,this.keyManager),this.fs.existsSync(this.polykeyPath))if(this.fs.existsSync(this.metadataPath)){const e=u.default.readFileSync(this.metadataPath);this.metadata={vaults:e.vaults,peerInfo:e.peerInfo,publicKeyPath:e.publicKeyPath,privateKeyPath:e.privateKeyPath}}else{const e=new y.default(this.keyManager.getPublicKey()),t={vaults:{},peerInfo:f.default.encodePeerInfo(e)};u.default.writeFileSync(this.metadataPath,t),this.metadata=t}else this.fs.mkdirSync(this.polykeyPath,{recursive:!0});this.peerStore=new l.default(f.default.decodePeerInfo(this.metadata.peerInfo)),this.peerDiscovery=new h.default(this.peerStore,this.keyManager),this.vaults=new Map;for(const e in this.metadata.vaults)if(this.metadata.vaults.hasOwnProperty(e)){const t=o.default.join(this.polykeyPath,e);if(this.fs.existsSync(t)){const t=Buffer.from(this.metadata.vaults[e].key),r=new d.default(e,t,this.polykeyPath);this.vaults.set(e,r)}}}async getVault(e){if(this.vaults.has(e)){const t=this.vaults.get(e);if(t)return t}await this.validateVault(e);const t=this.metadata.vaults[e].key,r=new d.default(e,t,this.polykeyPath);return this.vaults.set(e,r),r}async createVault(e,t){const r=o.default.join(this.polykeyPath,e);let s;if(s=this.fs.existsSync(r),s)throw Error("Vault already exists!");try{let s;this.fs.mkdirSync(r,{recursive:!0}),s=t||n.default.randomBytes(16),this.metadata.vaults[e]={key:s,tags:[]},await this.writeMetadata();const a=new d.default(e,s,this.polykeyPath);return this.vaults.set(e,a),await this.getVault(e)}catch(t){throw await this.destroyVault(e),t}}async vaultExists(e){const t=o.default.join(this.polykeyPath,e);return this.fs.existsSync(t)}async destroyVault(e){const t=o.default.join(this.polykeyPath,e);if(this.fs.existsSync(t)&&this.fs.rmdirSync(t,{recursive:!0}),this.vaults.has(e)&&this.vaults.delete(e),this.metadata.vaults.hasOwnProperty(e)&&(delete this.metadata.vaults[e],await this.writeMetadata()),this.fs.existsSync(t))throw new Error("Vault path could not be destroyed!");if(this.vaults.has(e))throw new Error("Vault could not be removed from PolyKey!");if(this.metadata.vaults.hasOwnProperty(e))throw new Error("Vault metadata could not be destroyed!")}async validateVault(e){if(!this.metadata.vaults.hasOwnProperty(e))throw Error("Vault metadata does not exist");const t=o.default.join(this.polykeyPath,e);if(!this.fs.existsSync(t))throw Error("Vault directory does not exist")}listVaults(){return Array.from(this.vaults.keys())}tagVault(){}untagVault(){}shareVault(){}unshareVault(){}async writeMetadata(){try{await u.default.writeFile(this.metadataPath,this.metadata)}catch(e){throw Error("Error writing vault key to config file")}}}},function(e,t){e.exports=require("os")},function(e,t){e.exports=require("jsonfile")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(r(1)),i=s(r(0)),o=s(r(10)),n=r(11);t.default=class{constructor(e,t,s){this.keyLen=32,this.key=this.genSymKey(t,this.keyLen);const o=new(r(12).VirtualFS);this.fs=new n.EncryptedFS(t,o,o,a.default,process),this.name=e,this.vaultPath=i.default.join(s,e),this.fs.mkdirSync(this.vaultPath,{recursive:!0}),this.secrets=new Map,this.loadSecrets()}loadSecrets(){const e=a.default.readdirSync(this.vaultPath,void 0);for(const t of e)this.secrets.set(t,null)}genSymKey(e,t){return Buffer.from(o.default(e.toString(),t))}secretExists(e){const t=i.default.join(this.vaultPath,e);return this.secrets.has(e)&&this.fs.existsSync(t)}addSecret(e,t){const r=i.default.join(this.vaultPath,e),s=this.fs.openSync(r,"w");this.fs.writeSync(s,t,0,t.length,0),this.secrets.set(e,t)}getSecret(e){if(this.secrets.has(e)){const t=this.secrets.get(e);if(t)return t;{const t=i.default.join(this.vaultPath,e),r=this.fs.readFileSync(t,{});return this.secrets.set(e,r),r}}throw Error("Secret: "+e+" does not exist")}removeSecret(e){if(this.secrets.has(e)){if(this.secrets.delete(e))return;throw Error("Secret: "+e+" was not removed")}throw Error("Secret: "+e+" does not exist")}listSecrets(){return Array.from(this.secrets.keys())}tagVault(){}untagVault(){}shareVault(){}unshareVault(){}}},function(e,t){e.exports=require("futoin-hkdf")},function(e,t){e.exports=require("encryptedfs")},function(e,t){e.exports=require("virtualfs")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(r(1)),i=s(r(0)),o=s(r(14)),n=s(r(2)),u=r(15);t.default=class{constructor(e="~/.polykey/",t=!1,r){this.primaryKeyPair={private:"",public:"",passphrase:""},this.storePath=e,this.useWebWorkers=t,this.workerPool=r,this.derivedKeys=new Map}async generateKeyPair(e,t,r,s=!1,a){const i=o.default.const.openpgp,n={asp:a?new o.default.ASP({progress_hook:a}):void 0,userid:`${e} <${t}>`,primary:{nbits:4096,flags:i.certify_keys|i.sign_data|i.auth|i.encrypt_comm|i.encrypt_storage,expire_in:0},subkeys:[]};return new Promise((e,t)=>{o.default.KeyManager.generate(n,(a,i)=>{a&&t(a),i.sign({},a=>{a&&t(a),i.export_pgp_public({},(a,o)=>{a&&t(a),i.export_pgp_private({passphrase:r},(a,n)=>{a&&t(a);const u={private:n,public:o,passphrase:r};s&&(this.primaryPassphrase=r,this.primaryKeyPair=u,this.primaryIdentity=i),e(u)})})})})})}getKeyPair(){return this.primaryKeyPair}getPublicKey(){return this.primaryKeyPair.public}getPrivateKey(){return this.primaryKeyPair.private}async loadPrivateKey(e,t=""){try{let r;r="string"==typeof e?Buffer.from(await a.default.promises.readFile(e)):e,this.primaryKeyPair.private=r.toString(),t&&(this.primaryPassphrase=t)}catch(e){throw e}}async loadPublicKey(e){try{let t;t="string"==typeof e?Buffer.from(await a.default.promises.readFile(e)):e,this.primaryKeyPair.public=t.toString()}catch(e){throw e}}async loadIdentity(e){return new Promise((t,r)=>{const s=this.getPublicKey(),a=this.getPrivateKey();o.default.KeyManager.import_from_armored_pgp({armored:s},(s,i)=>{s&&r(s),i.merge_pgp_private({armored:a},s=>{s&&r(s),i.is_pgp_locked()?i.unlock_pgp({passphrase:e},e=>{e&&r(e),this.primaryIdentity=i,t()}):(this.primaryIdentity=i,t())})})})}async loadKeyPair(e,t,r=""){await this.loadPrivateKey(t),await this.loadPublicKey(e),await this.loadIdentity(r),r&&this.primaryPassphrase}async exportPrivateKey(e){await a.default.promises.writeFile(e,this.primaryKeyPair.private)}async exportPublicKey(e){await a.default.promises.writeFile(e,this.primaryKeyPair.public)}generateKeySync(e,t){const r=n.default.randomBytes(32);return this.derivedKeys[e]=n.default.pbkdf2Sync(t,r,1e4,32,"sha256"),this.derivedKeys[e]}async generateKey(e,t){const r=n.default.randomBytes(32);return this.derivedKeys[e]=await u.promisify(n.default.pbkdf2)(t,r,1e4,32,"sha256"),this.derivedKeys[e]}importKeySync(e,t){this.derivedKeys[e]="string"==typeof t?a.default.readFileSync(t):t}async importKey(e,t){this.derivedKeys[e]="string"==typeof t?await a.default.promises.readFile(t):t}async exportKey(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&await a.default.promises.mkdir(i.default.dirname(t),{recursive:!0}),await a.default.promises.writeFile(t,this.derivedKeys[e])}exportKeySync(e,t){if(!this.derivedKeys.has(name))throw Error("There is no key loaded for name: "+name);t&&a.default.mkdirSync(i.default.dirname(e),{recursive:!0}),a.default.writeFileSync(e,this.derivedKeys[name])}async getIdentityFromPublicKey(e){return new Promise((t,r)=>{o.default.KeyManager.import_from_armored_pgp({armored:e},(e,s)=>{e&&r(e),t(s)})})}async getIdentityFromPrivateKey(e,t){return new Promise((r,s)=>{o.default.KeyManager.import_from_armored_pgp({armored:e},(e,a)=>{e&&s(e),a.is_pgp_locked()?a.unlock_pgp({passphrase:t},e=>{e&&s(e),r(a)}):r(a)})})}signData(e,t,r){return new Promise(async(s,a)=>{let i;if(t)r||a(Error("passphrase for private key was not provided")),i=await this.getIdentityFromPrivateKey(t,r);else{if(!this.primaryIdentity)throw Error("no identity available for signing");i=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){const t=await this.workerPool.queue(async t=>await t.signData(e,i));s(t)}else{const t={msg:e,sign_with:i};o.default.box(t,(e,t,r)=>{e&&a(e),s(Buffer.from(t))})}})}verifyData(e,t,r){return new Promise(async(s,a)=>{const i=new o.default.keyring.KeyRing;let n;if(r)n=await this.getIdentityFromPublicKey(r);else{if(!this.primaryIdentity)throw new Error("no identity available for verifying");n=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){const r=await this.workerPool.queue(async r=>await r.verifyData(e,t,n));s(r)}else{i.add_key_manager(this.primaryIdentity);const r={armored:t,data:e,keyfetch:i};o.default.unbox(r,(e,t)=>{e&&a(e);let r,i=t[0].get_data_signer();i&&(r=i.get_key_manager()),r?s(r.get_pgp_fingerprint().toString("hex")):a(Error("could not verify file"))})}})}async verifyFile(e,t,r){let s;r&&(s="string"==typeof r?a.default.readFileSync(r):r);const i=a.default.readFileSync(e),o=a.default.readFileSync(t);return await this.verifyData(i,o,s)}async signFile(e,t,r){let s;t&&(s="string"==typeof t?Buffer.from(a.default.readFileSync(t)):t);const i=Buffer.from(a.default.readFileSync(e)),o=await this.signData(i,s,r),n=e+".sig";return a.default.writeFileSync(n,o),n}async encryptData(e,t){return new Promise(async(r,s)=>{let a;try{a=await this.getIdentityFromPublicKey(t)}catch(e){throw Error("Identity could not be resolved for encrypting: "+e)}if(this.useWebWorkers&&this.workerPool){const t=await this.workerPool.queue(async t=>await t.encryptData(e,a));r(t)}else{const t={msg:e,encrypt_for:a};o.default.box(t,(e,t,a)=>{e&&s(e),r(t)})}})}async decryptData(e,t){return new Promise(async(r,s)=>{var a=new o.default.keyring.KeyRing;let i;if(t)i=await this.getIdentityFromPublicKey(t);else{if(!this.primaryIdentity)throw Error("no identity available for signing");i=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){const t=await this.workerPool.queue(async t=>await t.decryptData(e,i));r(t)}else{a.add_key_manager(i);const t={armored:e,keyfetch:a};o.default.unbox(t,(e,t)=>{e&&s(e);try{const e=Buffer.from(t[0].toString());r(e)}catch(e){s(e)}})}})}getKey(e){return this.derivedKeys[e]}isLoaded(){return!!this.derivedKeys[name]}}},function(e,t){e.exports=require("kbpgp")},function(e,t){e.exports=require("util")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{constructor(e){this.localPeerInfo=e,this.peers=new Map}put(e){this.has(e.publicKey)?this.update(e):this.add(e)}add(e){this.peers.set(e.publicKey,e)}update(e){this.peers.set(e.publicKey,e)}get(e){var t;return null!==(t=this.peers.get(e))&&void 0!==t?t:null}has(e){return this.peers.has(e)}}},function(e,t){e.exports=require("protobufjs")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(r(19)),i=s(r(20)),o=r(23),n={name:"Keybase",findUser:async(e,t)=>{const r=`https://keybase.io/_/api/1.0/user/lookup.json?${t}=${e}`;try{const e=await a.default(r);return(await e.json()).them[0].public_keys.primary.bundle}catch(e){throw new Error("User was not found: "+e.message)}}};t.default=class{constructor(e,t,r=[]){this.peerStore=e,this.keyManager=t,this.socialDiscoveryServices=r,this.socialDiscoveryServices=[],this.socialDiscoveryServices.push(n);for(const e of r)this.socialDiscoveryServices.push(e);this.multicastBroadcaster=new i.default(this.peerStore,this.keyManager)}async findPubKey(e){return new Promise((t,r)=>{this.multicastBroadcaster.requestPeerContact(e),this.multicastBroadcaster.on("found",r=>{r.publicKey==e&&t(r)}),this.multicastBroadcaster.on("timeout",t=>{t==e&&r("The broadcaster stopped looking")})})}async findSocialUser(e,t){const r=[];for(const s of this.socialDiscoveryServices)try{r.push(s.findUser(e,t))}catch(e){console.log("Could not find user on this discovery service: "+s.name)}const s=await o.firstPromiseFulfilled(r);if(s.length>1)throw new Error("Could not find public key from services");const a=s[0];return await this.findPubKey(a)}}},function(e,t){e.exports=require("node-fetch")},function(e,t,r){"use strict";var s,a,i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=i(r(21)),n=i(r(2)),u=r(22),d=i(r(4)),c=parseInt(null!==(s=process.env.UDP_MULTICAST_PORT)&&void 0!==s?s:"5353"),l=null!==(a=process.env.UDP_MULTICAST_ADDR)&&void 0!==a?a:"224.0.0.251";class y extends u.EventEmitter{constructor(e,t){super(),this.peerPubKeyMessages=new Map,this.peerStore=e,this.keyManager=t,this.interval=1e3,this.queryInterval=null,this.socket=o.default.createSocket({type:"udp4",reuseAddr:!0}),this.socket.bind(c),this.socket.on("listening",(()=>{this.socket.addMembership(l);const e=this.socket.address();console.log(`UDP socket listening on ${e.address}:${e.port} pid: ${process.pid}`)}).bind(this)),this.socket.on("message",this.handleHandshakeMessages.bind(this)),this.queryInterval=this.queryLAN()}queryLAN(){const e=()=>{for(const e of this.peerPubKeyMessages.keys()){const t=this.peerPubKeyMessages.get(e);if(t){const e=d.default.encodeHandshakeMessage(t.encryptedPeerPubKey,t.encryptedLocalPubKey,t.encryptedRandomMessage);this.socket.send(e,0,e.length,c,l,()=>{console.info("Sending message to peer")})}}};return e(),setInterval(e,this.interval)}async handleHandshakeMessages(e,t){var r;try{const s=d.default.decodeHandshakeMessage(e);console.info(`Message from: ${t.address}:${t.port}`);const a=await this.keyManager.decryptData(s.message.toString()),i=await this.keyManager.decryptData(s.targetPubKey.toString()),o=await this.keyManager.decryptData(s.requestingPubKey.toString()),n=this.keyManager.getPublicKey();if(o.toString()==n){const e=null===(r=this.peerPubKeyMessages.get(i.toString()))||void 0===r?void 0:r.rawRandomMessage;if(a.toString()==(null==e?void 0:e.toString())){const e=s.responsePeerInfo;if(e){this.peerStore.add(e);const t=e.publicKey;this.peerPubKeyMessages.delete(t),console.log("New peer added to the store"),this.emit("found",e)}else this.emit("error","I got a validated response. But no peerInfo")}}else{const e=await this.keyManager.encryptData(Buffer.from(n),o),t=await this.keyManager.encryptData(a,o),r=await this.keyManager.encryptData(o,o),s=d.default.encodeHandshakeMessage(Buffer.from(e),Buffer.from(r),Buffer.from(t),this.peerStore.localPeerInfo);this.socket.send(s,0,s.length,c,l)}}catch(e){}}async requestPeerContact(e){const t=Buffer.from(e),r=n.default.randomBytes(16),s=await this.keyManager.encryptData(t,t),a=await this.keyManager.encryptData(r,t),i=await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()),t);this.peerPubKeyMessages.set(e,{encryptedLocalPubKey:Buffer.from(i),encryptedPeerPubKey:Buffer.from(s),rawRandomMessage:r,encryptedRandomMessage:Buffer.from(a)})}}t.default=y},function(e,t){e.exports=require("dgram")},function(e,t){e.exports=require("events")},function(e,t,r){"use strict";function s(e){return new Promise((t,r)=>e.then(r,t))}Object.defineProperty(t,"__esModule",{value:!0}),t.randomString=function(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)},t.firstPromiseFulfilled=function(e){return s(Promise.all(e.map(s)))}}])}));
//# sourceMappingURL=polykey.js.map