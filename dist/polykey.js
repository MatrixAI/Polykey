!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.polykey=t():e.polykey=t()}(this,(function(){return function(e){var t={};function r(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(s,i,function(t){return e[t]}.bind(null,i));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=20)}([function(e,t){e.exports=require("path")},function(e,t){e.exports=require("os")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e,t){this.ip=e,this.port=t}static parse(e){const t=e.split(":"),r=t[0],i=t[1];return new s(r,i)}static fromAddressInfo(e){const t="::"==e.address?"127.0.0.1":e.address;return new s(t,e.port.toString())}toString(){return`${this.ip}:${this.port}`}}t.Address=s,s.prototype.toString=function(){return`${this.ip}:${this.port}`};t.default=class{constructor(e,t=[],r){this.publicKey=e,this.addresses=new Set(t.map(e=>s.parse(e))),this.connectedAddr=r?s.parse(r):void 0}connect(e){this.addresses.has(e)||this.addresses.add(e),this.connectedAddr=e}disconnect(){this.connectedAddr=void 0}}},function(e,t){e.exports=require("readable-stream")},function(e,t){e.exports=require("http")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{static flush(){return Buffer.from("0000","utf8")}static encode(e){"string"==typeof e&&(e=Buffer.from(e));const t=function(e,t){const r=t.toString(16);return"0".repeat(e-r.length)+r}(4,e.length+4);return Buffer.concat([Buffer.from(t,"utf8"),e])}static streamReader(e){return async function(){try{let t=await e.slice(4);if(null===t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;let r=await e.slice(t-4);return null===r||r}catch(e){return console.log("error",e),!0}}}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(25));function n(e,t){const r=e.replace(/\^\{\}$/,""),s=t.replace(/\^\{\}$/,""),i=-(r<s)||+(r>s);return 0===i?e.endsWith("^{}")?1:-1:i}const o=["config","description","index","shallow","commondir"];class u{static async packedRefs(e,t){const r=e.readFileSync(t+"/packed-refs",{encoding:"utf8"});return a.default.from(r).refs}static async listRefs(e,t,r){const s=u.packedRefs(e,t);let a=[];try{a=await async function e(t,r){return new Promise((s,a)=>{let n=[];r.promises.readdir(t).then(async a=>{var o=a.length;if(!o)return s(n);a.forEach((async function(a){a=i.default.resolve(t,a),r.promises.stat(a).then(async t=>{if(t&&t.isDirectory()){const t=await e(a,r);n=n.concat(t),--o||s(n)}else n.push(a),--o||s(n)})}))}).catch(e=>{if(e)return a(e)})})}(`${t}/${r}`,e),a=a.map(e=>e.replace(`${t}/${r}/`,""))}catch(e){a=[]}for(let e of(await s).keys())e.startsWith(r)&&(e=e.replace(r+"/",""),a.includes(e)||a.push(e));return a.sort(n),a}static async resolve(e,t,r,s){if(void 0!==s&&-1===--s)return r;if(r.startsWith("ref: "))return r=r.slice("ref: ".length),u.resolve(e,t,r,s);if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const i=await u.packedRefs(e,t),a=(e=>[""+e,"refs/"+e,"refs/tags/"+e,"refs/heads/"+e,"refs/remotes/"+e,`refs/remotes/${e}/HEAD`])(r).filter(e=>!o.includes(e));for(const r of a){const a=e.readFileSync(`${t}/${r}`,{encoding:"utf8"}).toString()||i.get(r);if(a)return u.resolve(e,t,a.trim(),s)}throw Error("RefNotFound")}}t.default=u},function(e,t){e.exports=require("pako")},function(e,t,r){"use strict";function s(e){return 0===e?e:-e}function i(e){let t=(r=s(e),Math.sign(r)||(Object.is(r,-0)?-1:1));var r;e=Math.abs(e);let i=Math.floor(e/60);e-=60*i;let a=String(i),n=String(e);return a.length<2&&(a="0"+a),n.length<2&&(n="0"+n),(-1===t?"-":"+")+a+n}function a(e){let[,t,r,i]=e.match(/(\+|-)(\d\d)(\d\d)/);return i=("+"===t?1:-1)*(60*Number(r)+Number(i)),s(i)}function n(e){let[,t,r,s,i]=e.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:r,timestamp:Number(s),timezoneOffset:a(i)}}function o(e){return e=(e=(e=e.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function u(e){return e.trim().split("\n").map(e=>" "+e).join("\n")+"\n"}Object.defineProperty(t,"__esModule",{value:!0});class l{constructor(e){if("string"==typeof e)this._commit=e;else if(Buffer.isBuffer(e))this._commit=e.toString("utf8");else{if("object"!=typeof e)throw new Error("invalid type passed to GitCommit constructor");this._commit=l.render(e)}}static fromPayloadSignature({payload:e,signature:t}){let r=l.justHeaders(e),s=l.justMessage(e),i=o(r+"\ngpgsig"+u(t)+"\n"+s);return new l(i)}static from(e){return new l(e)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return l.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(e){return o(e.slice(e.indexOf("\n\n")+2))}static justHeaders(e){return e.slice(0,e.indexOf("\n\n"))}parseHeaders(){let e=l.justHeaders(this._commit).split("\n"),t=[];for(let r of e)" "===r[0]?t[t.length-1]+="\n"+r.slice(1):t.push(r);let r={parent:[]};for(let e of t){let t=e.slice(0,e.indexOf(" ")),s=e.slice(e.indexOf(" ")+1);Array.isArray(r[t])?r[t].push(s):r[t]=s}return r.author&&(r.author=n(r.author)),r.committer&&(r.committer=n(r.committer)),r}static renderHeaders(e){let t="";if(e.tree?t+=`tree ${e.tree}\n`:t+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",e.parent){if(void 0===e.parent.length)throw new Error("commit 'parent' property should be an array");for(let r of e.parent)t+=`parent ${r}\n`}let r=e.author;t+=`author ${r.name} <${r.email}> ${r.timestamp} ${i(r.timezoneOffset)}\n`;let s=e.committer||e.author;return t+=`committer ${s.name} <${s.email}> ${s.timestamp} ${i(s.timezoneOffset)}\n`,e.gpgsig&&(t+="gpgsig"+u(e.gpgsig)),t}static render(e){return l.renderHeaders(e)+"\n"+o(e.message)}render(){return this._commit}withoutSignature(){let e=o(this._commit);return-1===e.indexOf("\ngpgsig")?e:o(e.slice(0,e.indexOf("\ngpgsig"))+"\n"+e.slice(e.indexOf("-----END PGP SIGNATURE-----\n")+"-----END PGP SIGNATURE-----\n".length))}isolateSignature(){let e=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length);return e.split("\n").map(e=>e.replace(/^ /,"")).join("\n")}}t.default=l},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(10)),a=s(r(7)),n=s(r(0)),o=s(r(30)),u=new Map;class l{static async read(e,t,r,s="content"){let c=e.readFileSync(`${t}/objects/${r.slice(0,2)}/${r.slice(2)}`),d=`./objects/${r.slice(0,2)}/${r.slice(2)}`;if(!c){const s=r=>l.read(e,t,r);let a=i.default.readdirSync(n.default.join(t,"/objects/pack"));a=a.filter(e=>e.endsWith(".pack"));for(let i of a){let a=u.get(i);if(a.offsets.has(r)){if(!a.pack){const r=e.readFileSync(`${t}/objects/pack/${i}`);await a.load({pack:r})}let n=await a.read({oid:r,getExternalRefDelta:s});return n.source="./objects/pack/"+i,n}}}if(!c){let s=e.readFileSync(t+"/shallow",{encoding:"utf8"});if(null!==s&&s.includes(r))throw new Error("ReadShallowObjectFail: "+r)}if(!c)throw new Error("ReadObjectFail: "+r);if("deflated"===s)return{format:"deflated",object:c,source:d};let f=Buffer.from(a.default.inflate(c));if("wrapped"===s)return{format:"wrapped",object:f,source:d};let{type:h,object:y}=o.default.unwrap({oid:r,buffer:f});return"content"===s?{type:h,format:"content",object:y,source:d}:void 0}}t.default=l},function(e,t){e.exports=require("fs")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(0)),n=s(r(35)),o=s(r(12)),u=r(36);t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r,s=!1,n){this.primaryKeyPair={private:null,public:null},this.metadata={privateKeyPath:null,publicKeyPath:null},this.useWebWorkers=s,this.workerPool=n,this.derivedKeys=new Map,this.fileSystem=t,this.polykeyPath=e;const o=a.default.join(e,".keypair");if(this.fileSystem.existsSync(o)||this.fileSystem.mkdirSync(o),this.metadataPath=a.default.join(o,"metadata"),this.loadMetadata(),this.metadata.privateKeyPath&&this.metadata.publicKeyPath&&r){const e=this.fileSystem.readFileSync(this.metadata.publicKeyPath),t=this.fileSystem.readFileSync(this.metadata.privateKeyPath);this.loadKeyPair(e,t,r)}}async generateKeyPair(e,t,r,s=4096,i=!1,a){const o=n.default.const.openpgp,l={asp:a?new n.default.ASP({progress_hook:a}):void 0,userid:`${e} <${t}>`,primary:{nbits:s,flags:o.certify_keys|o.sign_data|o.auth|o.encrypt_comm|o.encrypt_storage,expire_in:0},subkeys:[]},c=await u.promisify(n.default.KeyManager.generate)(l);await u.promisify(c.sign.bind(c))({});const d=await u.promisify(c.export_pgp_public.bind(c))({}),f={private:await u.promisify(c.export_pgp_private.bind(c))({passphrase:r}),public:d};return i&&(this.primaryKeyPair=f,this.primaryIdentity=c),f}getKeyPair(){return this.primaryKeyPair}hasPublicKey(){return!!this.primaryKeyPair.public}getPublicKey(){if(!this.primaryKeyPair.public)throw new Error("Public key does not exist in memory");return this.primaryKeyPair.public}getPrivateKey(){if(!this.primaryKeyPair.private)throw new Error("Private key does not exist in memory");return this.primaryKeyPair.private}async loadKeyPair(e,t,r){await this.loadPrivateKey(t),await this.loadPublicKey(e),await this.loadIdentity(r)}async loadPrivateKey(e){let t;"string"==typeof e?(t=Buffer.from(await this.fileSystem.promises.readFile(e)),this.metadata.privateKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.private=t.toString()}async loadPublicKey(e){let t;"string"==typeof e?(t=Buffer.from(await this.fileSystem.promises.readFile(e)),this.metadata.publicKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.public=t.toString()}async loadIdentity(e){const t=this.getPublicKey(),r=this.getPrivateKey(),s=await u.promisify(n.default.KeyManager.import_from_armored_pgp)({armored:t});await u.promisify(s.merge_pgp_private.bind(s))({armored:r}),s.is_pgp_locked.bind(s)()&&await u.promisify(s.unlock_pgp.bind(s))({passphrase:e}),this.primaryIdentity=s}async exportPrivateKey(e){await this.fileSystem.promises.writeFile(e,this.primaryKeyPair.private),this.metadata.privateKeyPath=e,this.writeMetadata()}async exportPublicKey(e){await this.fileSystem.promises.writeFile(e,this.primaryKeyPair.public),this.metadata.publicKeyPath=e,this.writeMetadata()}generateKeySync(e,t){const r=o.default.randomBytes(32);return this.derivedKeys[e]=o.default.pbkdf2Sync(t,r,1e4,32,"sha256"),this.derivedKeys[e]}async generateKey(e,t){const r=o.default.randomBytes(32);return this.derivedKeys[e]=await u.promisify(o.default.pbkdf2)(t,r,1e4,32,"sha256"),this.derivedKeys[e]}importKeySync(e,t){this.derivedKeys[e]="string"==typeof t?this.fileSystem.readFileSync(t):t}async importKey(e,t){this.derivedKeys[e]="string"==typeof t?await this.fileSystem.promises.readFile(t):t}exportKeySync(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&this.fileSystem.mkdirSync(a.default.dirname(t),{recursive:!0}),this.fileSystem.writeFileSync(t,this.derivedKeys[e])}async exportKey(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&await this.fileSystem.promises.mkdir(a.default.dirname(t),{recursive:!0}),await this.fileSystem.promises.writeFile(t,this.derivedKeys[e])}async getIdentityFromPublicKey(e){return await u.promisify(n.default.KeyManager.import_from_armored_pgp)({armored:e})}async getIdentityFromPrivateKey(e,t){const r=await u.promisify(n.default.KeyManager.import_from_armored_pgp)({armored:e});return r.is_pgp_locked()&&await u.promisify(r.unlock_pgp)({passphrase:t}),r}async signData(e,t,r){let s;if(t){if(!r)throw new Error("passphrase for private key was not provided");s=await this.getIdentityFromPrivateKey(t,r)}else{if(!this.primaryIdentity)throw new Error("no identity available for signing");s=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.signData(e,s))}{const t={msg:e.toString(),sign_with:s},r=await u.promisify(n.default.box)(t);return Buffer.from(r)}}async signFile(e,t,r){let s;t&&(s="string"==typeof t?Buffer.from(this.fileSystem.readFileSync(t)):t);const i=Buffer.from(this.fileSystem.readFileSync(e)),a=await this.signData(i,s,r),n=e+".sig";return this.fileSystem.writeFileSync(n,a),n}async verifyData(e,t,r){const s=new n.default.keyring.KeyRing;let i;if(r)i=await this.getIdentityFromPublicKey(r);else{if(!this.primaryIdentity)throw new Error("no identity available for verifying");i=this.primaryIdentity}if(s.add_key_manager(i),this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async r=>await r.verifyData(e,t,i))}{const r={armored:t,data:e,keyfetch:s};let i,a=(await u.promisify(n.default.unbox)(r))[0].get_data_signer();return a&&(i=a.get_key_manager()),!!i&&!!i.get_pgp_fingerprint()}}async verifyFile(e,t,r){let s;r&&(s="string"==typeof r?this.fileSystem.readFileSync(r):r);const i=this.fileSystem.readFileSync(e),a=this.fileSystem.readFileSync(t);return await this.verifyData(i,a,s)}async encryptData(e,t){let r;if(t)r=await this.getIdentityFromPublicKey(t);else{if(!this.primaryIdentity)throw new Error("Identity could not be resolved for encrypting");r=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.encryptData(e,r))}{const t={msg:e,encrypt_for:r};return await u.promisify(n.default.box)(t)}}async decryptData(e,t,r){var s=new n.default.keyring.KeyRing;let i;if(t){if(!r)throw new Error("A key passphrase must be supplied if a privateKey is specified");i=await this.getIdentityFromPrivateKey(t,r)}else{if(!this.primaryIdentity)throw Error("no identity available for signing");i=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.decryptData(e,i))}{s.add_key_manager(i);const t={armored:e.toString(),keyfetch:s},r=await u.promisify(n.default.unbox)(t);return Buffer.from(r[0].toString())}}getKey(e){return this.derivedKeys[e]}hasKey(e){return!!this.derivedKeys[e]}writeMetadata(){const e=JSON.stringify(this.metadata);this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.metadata=JSON.parse(e)}}}},function(e,t){e.exports=require("crypto")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(37)),n=s(r(38)),o=s(r(0)),u=s(r(14)),l=r(40),c=s(r(2)),d=s(r(41)),f=s(r(44)),h={name:"Keybase",findUser:async(e,t)=>{const r=`https://keybase.io/_/api/1.0/user/lookup.json?${t}=${e}`;try{const e=await fetch(r);return(await e.json()).them[0].public_keys.primary.bundle}catch(e){throw new Error("User was not found: "+e.message)}}};t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r,s,a=[]){this.metadata={localPeerInfo:null},this.fileSystem=t,this.fileSystem.mkdirSync(e,{recursive:!0}),this.metadataPath=o.default.join(e,".peerMetadata"),this.keyManager=r,this.socialDiscoveryServices=a,this.loadMetadata(),s?(this.localPeerInfo=s,this.writeMetadata()):this.metadata.localPeerInfo?this.localPeerInfo=this.metadata.localPeerInfo:this.keyManager.hasPublicKey()&&(this.localPeerInfo=new c.default(this.keyManager.getPublicKey())),this.peerStore=new Map,this.socialDiscoveryServices=[],this.socialDiscoveryServices.push(h);for(const e of a)this.socialDiscoveryServices.push(e);this.multicastBroadcaster=new d.default(this.addPeer,this.localPeerInfo,this.keyManager);const{keyPem:u,certPem:l}=f.default.createX509Certificate();this.keyPem=u,this.certPem=l;const y={key:u,cert:l,requestCert:!0,rejectUnauthorized:!1};this.server=n.default.createServer(y,e=>{console.log("server connected",e.authorized?"authorized":"unauthorized")}).listen()}getLocalPeerInfo(){return this.localPeerInfo}connectLocalPeerInfo(e){this.localPeerInfo.connect(e)}addPeer(e){this.peerStore.set(e.publicKey,e)}getPeer(e){var t;return null!==(t=this.peerStore.get(e))&&void 0!==t?t:null}hasPeer(e){return this.peerStore.has(e)}async findPubKey(e){return new Promise((t,r)=>{this.multicastBroadcaster.requestPeerContact(e),this.multicastBroadcaster.on("found",r=>{r.publicKey==e&&t(r)}),this.multicastBroadcaster.on("timeout",t=>{t==e&&r("The broadcaster stopped looking")})})}async findSocialUser(e,t){const r=[];for(const s of this.socialDiscoveryServices)try{r.push(s.findUser(e,t))}catch(e){console.log("Could not find user on this discovery service: "+s.name)}const s=await l.firstPromiseFulfilled(r);if(s.length>1)throw new Error("Could not find public key from services");const i=s[0];return await this.findPubKey(i)}connectToPeer(e){var t;if("string"!=typeof e){const t=e,r={port:parseInt(t.port),host:t.ip};return a.default.connect(r)}{const r=this.peerConnections.get(e);if(r)return r;{const r=null===(t=this.getPeer(e))||void 0===t?void 0:t.connectedAddr;if(r){const e={port:parseInt(r.port),host:r.ip};return a.default.connect(e)}}}throw new Error("Peer does not have an address connected")}writeMetadata(){const e=JSON.stringify(u.default.encodePeerInfo(this.localPeerInfo));this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.localPeerInfo=u.default.decodePeerInfo(Buffer.from(e))}}}},function(e,t,r){"use strict";(function(e){var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(39)),n=s(r(2));t.default=class{static encodePeerInfo(e){var t;const r=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),s=[];for(const t of e.addresses)s.push(t.toString());const i={pubKey:e.publicKey,addresses:s,connectedAddr:null===(t=e.connectedAddr)||void 0===t?void 0:t.toString()},a=r.verify(i);if(a)throw Error(a);const n=r.create(i);return r.encode(n).finish()}static decodePeerInfo(e){const t=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),r=t.decode(e),s=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return new n.default(s.pubKey,s.addresses,s.connectedAddr)}static encodeHandshakeMessage(e,t,r,s){const i=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),a={targetPubKey:e,requestingPubKey:t,message:r,responsePeerInfo:s?this.encodePeerInfo(s):void 0},n=i.verify(a);if(n)throw Error(n);const o=i.create(a);return i.encode(o).finish()}static decodeHandshakeMessage(e){const t=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),r=t.decode(e),s=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return{targetPubKey:Buffer.from(s.targetPubKey,"base64"),requestingPubKey:Buffer.from(s.requestingPubKey,"base64"),message:Buffer.from(s.message,"base64"),responsePeerInfo:s.responsePeerInfo?this.decodePeerInfo(Buffer.from(s.responsePeerInfo,"base64")):void 0}}static loadProto(t){const r=new a.default.Root;return r.resolvePath=(t,r)=>i.default.join(i.default.dirname(e),r),r.loadSync(t)}}}).call(this,"/index.js")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(0)),n=s(r(16)),o=r(17),u=s(r(46)),l=s(r(18));t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r){this.polykeyPath=e,this.fileSystem=t,this.keyManager=r,this.metadataPath=a.default.join(e,".vaultKeys"),this.fileSystem.mkdirSync(this.polykeyPath,{recursive:!0}),this.vaults=new Map,this.vaultKeys=new Map,this.loadMetadata();for(const[e,t]of this.vaultKeys.entries()){const r=a.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(r)){const r=new u.default(e,t,this.polykeyPath);this.vaults.set(e,r)}}}getVault(e){if(this.vaults.has(e)){return this.vaults.get(e)}if(this.vaultKeys.has(e)){this.validateVault(e);const t=this.vaultKeys.get(e),r=new u.default(e,t,this.polykeyPath);return this.vaults.set(e,r),r}throw new Error("Vault does not exist in memory")}async createVault(e,t){if(this.vaultExists(e))throw Error("Vault already exists!");try{const r=a.default.join(this.polykeyPath,e);let s;this.fileSystem.mkdirSync(r,{recursive:!0}),s=t||await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),this.vaultKeys.set(e,s),this.writeMetadata();const i=new u.default(e,s,this.polykeyPath);return await i.initRepository(),this.vaults.set(e,i),this.getVault(e)}catch(t){throw this.destroyVault(e),t}}async cloneVault(e,t,s){if(this.vaultExists(e))throw new Error("Vault name already exists locally, try pulling instead");const i=`http://${t.toString()}/${e}`,c=new l.default(t,s);if(!(await n.default.getRemoteInfo({http:c,url:i})).refs)throw new Error(`Peer does not have vault: '${e}'`);const d=await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),f=new(r(19).VirtualFS),h=new o.EncryptedFS(d,f,f,this.fileSystem,process);await n.default.clone({fs:{promises:h.promises},http:c,dir:a.default.join(this.polykeyPath,e),url:i,ref:"master",singleBranch:!0});const y=new u.default(e,d,this.polykeyPath);return this.vaults.set(e,y),y}vaultExists(e){const t=a.default.join(this.polykeyPath,e);return this.fileSystem.existsSync(t)}destroyVault(e){const t=a.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(t)&&this.fileSystem.rmdirSync(t,{recursive:!0}),this.vaults.delete(e),this.vaultKeys.delete(e),this.writeMetadata(),this.fileSystem.existsSync(t))throw new Error("Vault folder could not be destroyed!")}listVaults(){return Array.from(this.vaults.keys())}validateVault(e){if(!this.vaults.has(e))throw Error("Vault does not exist in memory");if(!this.vaultKeys.has(e))throw Error("Vault key does not exist in memory");const t=a.default.join(this.polykeyPath,e);if(!this.fileSystem.existsSync(t))throw Error("Vault directory does not exist")}async writeMetadata(){const e=JSON.stringify([...this.vaultKeys]),t=await this.keyManager.encryptData(Buffer.from(e));await this.fileSystem.promises.writeFile(this.metadataPath,t)}async loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath),t=(await this.keyManager.decryptData(e)).toString();for(const[e,r]of new Map(JSON.parse(t)))this.vaultKeys[e]=Buffer.from(r)}}}},function(e,t){e.exports=require("isomorphic-git")},function(e,t){e.exports=require("encryptedfs")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(4));t.default=class{constructor(e,t){this.address=e,this.getSocket=t}request({url:e,method:t,headers:r,body:s,onProgress:a}){return new Promise((a,n)=>{const{pathname:o,search:u}=new URL(e),l={path:o+u,headers:r,method:t,createConnection:()=>this.getSocket(this.address)},c=i.default.request(l,e=>{const t=this.httpMessageToIter(e);a({url:e.url,method:e.method,statusCode:e.statusCode,statusMessage:e.statusMessage,body:t,headers:e.headers})});if(s)for(const e of s)c.write(e);c.end()})}httpMessageToIter(e){let t=!1;const r=[];let s={};return e.on("data",e=>{r.push(e),s.resolve&&(s.resolve({value:r.shift(),done:!1}),s={})}),e.on("error",e=>{s.reject&&(s.reject(e),s={})}),e.on("end",()=>{t=!0,s.resolve&&(s.resolve({done:!0}),s={})}),{next:()=>new Promise((e,i)=>0===r.length&&t?e({done:!0}):r.length>0?e({value:r.shift(),done:!1}):void(0!==r.length||t||(s={resolve:e,reject:i})))}}}},function(e,t){e.exports=require("virtualfs")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=r(21);t.default=s.default;var i=r(11);t.KeyManager=i.default;var a=r(13);t.PeerManager=a.default;var n=r(15);t.VaultManager=n.default},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(22)),n=s(r(11)),o=s(r(13)),u=s(r(15));t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r,s,l){this.polykeyPath=e,this.keyManager=null!=r?r:new n.default(this.polykeyPath,t),this.vaultManager=null!=s?s:new u.default(this.polykeyPath,t,this.keyManager),this.peerManager=null!=l?l:new o.default(this.polykeyPath,t,this.keyManager),this.gitServer=new a.default(this.polykeyPath,this.vaultManager),this.peerManager.connectLocalPeerInfo(this.gitServer.address)}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(4)),n=r(23),o=r(2),u=s(r(24)),l=s(r(26)),c=r(3),d=s(r(28)),f=["upload-pack","receive-pack"];t.default=class{constructor(e,t,r=0){this.polykeyPath=e,this.vaultManager=t,this.server=a.default.createServer((e,t)=>{this.handle(e,t)}).listen(r),this.address=o.Address.fromAddressInfo(this.server.address())}exists(e,t){const r=this.vaultManager.getVault(e);return!!r&&r.peerCanAccess(t)}handle(e,t){t.setHeader("connection","close"),"GET"==e.method?this.handleInfoRequest(e,t):"POST"==e.method?this.handlePackRequest(e,t):(t.statusCode=405,t.end("method not supported"))}notFoundResponse(e){e.statusCode=404,e.end("not found")}handleInfoRequest(e,t){var r,s;const i=null!==(s=null===(r=e.url)||void 0===r?void 0:r.split("?"))&&void 0!==s?s:[];if(2!=i.length)return this.notFoundResponse(t);const a=i[0],o=i[1],u=a.match(/\/(.+)\/info\/refs$/);if(!u||/\.\./.test(u[1]))return this.notFoundResponse(t);const l=u[1],c=n.parse(o);if(!c.service)return t.statusCode=400,void t.end("service parameter required");const d=c.service.replace(/^git-/,"");if(f.indexOf(d)<0)return t.statusCode=405,void t.end("service not available");this.infoResponse(l,d,t)}handlePackRequest(e,t){var r;const s=e.url.match(/\/(.+)\/git-(.+)/);if(!s||/\.\./.test(s[1]))return this.notFoundResponse(t);const a=s[1],n=s[2];if(f.indexOf(n)<0)return t.statusCode=405,void t.end("service not available");t.setHeader("content-type","application/x-git-"+n+"-result"),this.noCache(t);const o=i.default.join(this.polykeyPath,a);if(!this.exists(a,""))return t.statusCode=404,void t.end("not found");const u=null===(r=this.vaultManager.getVault(a))||void 0===r?void 0:r.EncryptedFS;u&&e.on("data",async e=>{if("want"==e.toString().slice(4,8)){const r=e.toString().slice(9,49),s=await d.default(u,o,[r],void 0);t.write(Buffer.from("0008NAK\n"));const i=new c.PassThrough,a=new c.PassThrough;l.default.mux("side-band-64",i,s.packstream,a,[]).pipe(t),a.write(Buffer.from("0014progress is at 50%\n")),a.end()}})}infoResponse(e,t,r){this.exists(e,"")?(r.setHeader("content-type","application/x-git-"+t+"-advertisement"),this.noCache(r),this.uploadPackRespond(e,t,r)):(r.statusCode=404,r.setHeader("content-type","text/plain"),r.end("repository not found"))}noCache(e){e.setHeader("expires","Fri, 01 Jan 1980 00:00:00 GMT"),e.setHeader("pragma","no-cache"),e.setHeader("cache-control","no-cache, max-age=0, must-revalidate")}createGitPacketLine(e){const t=(4+e.length).toString(16);return Array(4-t.length+1).join("0")+t+e}async uploadPackRespond(e,t,r){var s;r.write(this.createGitPacketLine("# service=git-"+t+"\n")),r.write("0000");const a=null===(s=this.vaultManager.getVault(e))||void 0===s?void 0:s.EncryptedFS,n=await u.default(a,i.default.join(this.polykeyPath,e),void 0,!0),o=null!=n?n:[];c.Readable.from(o).pipe(r)}}},function(e,t){e.exports=require("querystring")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(5)),n=s(r(6));t.default=async function(e,t,r=i.default.join(t,".git"),s=!1){try{if(s){const t=["side-band-64k"];let s=await n.default.listRefs(e,r,"refs");s=s.map(e=>"refs/"+e);const i={};s.unshift("HEAD");for(const t of s)i[t]=await n.default.resolve(e,r,t);const o={};return o.HEAD=await n.default.resolve(e,r,"HEAD",2),async function({capabilities:e,refs:t,symrefs:r}){const s=[];let i="";for(const[e,t]of Object.entries(r))i+=`symref=${e}:${t} `;let n=`\0${[...e].join(" ")} ${i}agent=git/isomorphic-git@1.4.0`;for(const[e,r]of Object.entries(t))s.push(a.default.encode(`${r} ${e}${n}\n`)),n="";return s.push(a.default.flush()),s}({capabilities:t,refs:i,symrefs:o})}}catch(e){throw e.caller="git.uploadPack",e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){if(this.refs=new Map,this.parsedConfig=[],e){let t;this.parsedConfig=e.trim().split("\n").map(e=>{if(/^\s*#/.test(e))return{line:e,comment:!0};const r=e.indexOf(" ");if(e.startsWith("^")){const r=e.slice(1);return this.refs.set(t+"^{}",r),{line:e,ref:t,peeled:r}}{const s=e.slice(0,r);return t=e.slice(r+1),this.refs.set(t,s),{line:e,ref:t,oid:s}}})}return this}static from(e){return new s(e)}}t.default=s},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=r(27),a=r(3),n=s(r(5));function o(e,t){const r=[];let s=0;for(;s<e.length;){const i=e.slice(s,s+t);r.push(i),s+=i.length}return r.push(e.slice(s)),r}t.default=class{static demux(e){let t=n.default.streamReader(e),r=new a.PassThrough,s=new a.PassThrough,i=new a.PassThrough;const o=async function(){let e=await t();if(null===e)return o();if(!0===e)return r.end(),i.end(),void s.end();switch(e[0]){case 1:s.write(e.slice(1));break;case 2:i.write(e.slice(1));break;case 3:let t=e.slice(1);return i.write(t),void s.destroy(new Error(t.toString("utf8")));default:r.write(e.slice(0))}o()};return o(),{packetlines:r,packfile:s,progress:i}}static mux(e,t,r,s,u){const l="side-band-64k"===e?999:65519;let c=new a.PassThrough;t.on("data",e=>{null===e?c.write(n.default.flush()):c.write(n.default.encode(e))});let d=!0,f=!1,h=!1,y=i.Buffer.concat([n.default.encode(i.Buffer.from("010A","hex")),n.default.flush()]);return r.on("data",e=>{d=!1;const t=o(e,l);for(const e of t)c.write(n.default.encode(i.Buffer.concat([i.Buffer.from("01","hex"),e])))}).on("end",()=>{f=!0,d||c.write(y),h&&c.end()}),s.on("data",e=>{const t=o(e,l);for(const e of t)c.write(n.default.encode(i.Buffer.concat([i.Buffer.from("02","hex"),e])))}).on("end",()=>{h=!0,f&&c.end()}),c}}},function(e,t){e.exports=require("buffer")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(7)),a=s(r(0)),n=s(r(29)),o=s(r(33)),u=s(r(34)),l=s(r(8)),c=r(3),d=s(r(9)),f={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function h(e,t,r=a.default.join(t,".git"),s){let i=new Set,n=new Set,u=new Set;async function c(t){let{type:s,object:a}=await d.default.read(e,r,t);if("commit"===s){i.add(t);let e=l.default.from(a).headers().tree;await c(e)}else if("tree"===s){n.add(t);let e=o.default.from(a);for(let t of e)"blob"===t.type&&u.add(t.oid),"tree"===t.type&&await c(t.oid)}}for(let e of s)await c(e);return[...i,...n,...u]}async function y(e,t,r=a.default.join(t,".git"),s,n){let o=u.default("sha1");function l(e,t){t?n.write(e,t):n.write(e),o.update(e,t)}function c(e,t){let r,s,a,n=f[t];if(void 0===n)throw new Error("Unrecognized type: "+t);a=e.length,s=a>15?128:0,r=15&a,a>>>=4;let o=(s|n|r).toString(16);for(l(o,"hex");s;){s=a>127?128:0,o=s|127&a;const e=o.toString(16);l("0".repeat(2-e.length)+e,"hex"),a>>>=7}l(Buffer.from(i.default.deflate(e)))}l("PACK"),l("00000002","hex");const h=s.length.toString(16);l("0".repeat(8-h.length)+h,"hex");for(let t of s){let{type:s,object:i}=await d.default.read(e,r,t);c(i,s)}let y=o.digest();return n.end(y),n}t.listObjects=h,t.pack=y,t.default=async function(e,t,r,s,i){const o=a.default.join(t,".git");let u=new Set,l=new Set,d=new Set,f=[];i=i||[];for(const a of r)try{let r=await n.default(e,t,o,void 0,a,s,void 0),c=[];for(let e=0;e<r.length;e++){let t=r[e];if(i.includes(t.oid)){f.push({oid:a});break}u.add(t.oid),e===r.length-1?c.includes(t.oid)||void 0===s||(console.log("make it shallow",t.oid),l.add(t.oid)):c.includes(t.oid)&&(console.log("make it unshallow",t.oid),d.add(t.oid))}}catch(e){console.log(e)}let p=await h(e,t,o,Array.from(u)),m=new c.PassThrough;return y(e,t,void 0,[...p],m),{packstream:m,shallows:l,unshallows:d,acks:f}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=r(0),a=s(r(8)),n=s(r(9)),o=s(r(6));async function u(e,t,r,s){try{let{type:i,object:o}=await n.default.read(e,t,r);if("commit"!==i)throw new Error("expected type to be commit");const u=a.default.from(o),l=Object.assign({oid:r},u.parse());return s&&(l.payload=u.withoutSignature()),l}catch(e){return{oid:r,error:e}}}function l(e,t){return e.committer.timestamp-t.committer.timestamp}t.logCommit=u,t.default=async function(e,t,r=i.join(t,".git"),s="HEAD",a,n,c=!1){try{let t=void 0===n?void 0:Math.floor(n.valueOf()/1e3),i=[],d=await o.default.resolve(e,r,s),f=[await u(e,r,d,c)];for(;;){let s=f.pop();if(s.error){i.push(s);break}if(void 0!==t&&s.committer.timestamp<=t)break;if(i.push(s),void 0!==a&&i.length===a)break;for(const t of s.parent){let s=await u(e,r,t,c);f.map(e=>e.oid).includes(s.oid)||f.push(s)}if(0===f.length)break;f.sort(l)}return i}catch(e){throw e.caller="git.log",e}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(31));t.default=class{static hash({type:e,object:t}){let r=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),Buffer.from(t)]);return i.default(r)}static wrap({type:e,object:t}){let r=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),t]);return{oid:i.default(r),buffer:r}}static unwrap({oid:e,buffer:t}){if(e){let r=i.default(t);if(r!==e)throw new Error(`SHA check failed! Expected ${e}, computed ${r}`)}let r=t.indexOf(32),s=t.indexOf(0),a=t.slice(0,r).toString("utf8"),n=t.slice(r+1,s).toString("utf8"),o=t.length-(s+1);if(parseInt(n)!==o)throw new Error(`Length mismatch: expected ${n} bytes but got ${o} instead.`);return{type:a,object:Buffer.from(t.slice(s+1))}}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(32));t.default=function(e){return(new i.default).update(e).digest("hex")}},function(e,t){e.exports=require("sha.js/sha1")},function(e,t,r){"use strict";function s(e){return!e.oid&&e.sha&&(e.oid=e.sha),e.mode=function(e){if("number"==typeof e&&(e=e.toString(8)),e.match(/^0?4.*/))return"40000";if(e.match(/^1006.*/))return"100644";if(e.match(/^1007.*/))return"100755";if(e.match(/^120.*/))return"120000";if(e.match(/^160.*/))return"160000";throw new Error("Could not understand file mode: "+e)}(e.mode),e.type||(e.type="blob"),e}Object.defineProperty(t,"__esModule",{value:!0});class i{constructor(e){if(Buffer.isBuffer(e))this._entries=function(e){let t=[],r=0;for(;r<e.length;){let s=e.indexOf(32,r);if(-1===s)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);let i=e.indexOf(0,r);if(-1===i)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let a=e.slice(r,s).toString("utf8");"40000"===a&&(a="040000");let n="040000"===a?"tree":"blob",o=e.slice(s+1,i).toString("utf8"),u=e.slice(i+1,i+21).toString("hex");r=i+21,t.push({mode:a,path:o,oid:u,type:n})}return t}(e);else{if(!Array.isArray(e))throw new Error("invalid type passed to GitTree constructor");this._entries=e.map(s)}}static from(e){return new i(e)}render(){return this._entries.map(e=>`${e.mode} ${e.type} ${e.oid}    ${e.path}`).join("\n")}toObject(){return Buffer.concat(this._entries.map(e=>{let t=Buffer.from(e.mode.replace(/^0/,"")),r=Buffer.from(" "),s=Buffer.from(e.path),i=Buffer.from([0]),a=Buffer.from(e.oid.match(/../g).map(e=>parseInt(e,16)));return Buffer.concat([t,r,s,i,a])}))}entries(){return this._entries}*[Symbol.iterator](){for(let e of this._entries)yield e}}t.default=i},function(e,t){e.exports=require("sha.js")},function(e,t){e.exports=require("kbpgp")},function(e,t){e.exports=require("util")},function(e,t){e.exports=require("net")},function(e,t){e.exports=require("tls")},function(e,t){e.exports=require("protobufjs")},function(e,t,r){"use strict";function s(e){return new Promise((t,r)=>e.then(r,t))}Object.defineProperty(t,"__esModule",{value:!0}),t.randomString=function(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)},t.firstPromiseFulfilled=function(e){return s(Promise.all(e.map(s)))}},function(e,t,r){"use strict";var s,i,a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=a(r(42)),o=a(r(12)),u=r(43),l=a(r(14)),c=parseInt(null!==(s=process.env.UDP_MULTICAST_PORT)&&void 0!==s?s:"5353"),d=null!==(i=process.env.UDP_MULTICAST_ADDR)&&void 0!==i?i:"224.0.0.251";class f extends u.EventEmitter{constructor(e,t,r){super(),this.peerPubKeyMessages=new Map,this.addPeer=e,this.localPeerInfo=t,this.keyManager=r,this.interval=1e3,this.queryInterval=null,this.socket=n.default.createSocket({type:"udp4",reuseAddr:!0}),this.socket.bind(c),this.socket.on("listening",(()=>{this.socket.addMembership(d);this.socket.address()}).bind(this)),this.socket.on("message",this.handleHandshakeMessages.bind(this)),this.queryInterval=this.queryLAN()}async requestPeerContact(e){const t=Buffer.from(e),r=o.default.randomBytes(16),s=await this.keyManager.encryptData(t,t),i=await this.keyManager.encryptData(r,t),a=await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()),t);this.peerPubKeyMessages.set(e,{encryptedLocalPubKey:Buffer.from(a),encryptedPeerPubKey:Buffer.from(s),rawRandomMessage:r,encryptedRandomMessage:Buffer.from(i)})}queryLAN(){const e=()=>{for(const e of this.peerPubKeyMessages.keys()){const t=this.peerPubKeyMessages.get(e);if(t){const e=l.default.encodeHandshakeMessage(t.encryptedPeerPubKey,t.encryptedLocalPubKey,t.encryptedRandomMessage);this.socket.send(e,0,e.length,c,d,()=>{console.info("Sending message to peer")})}}};return e(),setInterval(e,this.interval)}async handleHandshakeMessages(e,t){var r;try{const s=l.default.decodeHandshakeMessage(e);console.info(`Message from: ${t.address}:${t.port}`);const i=await this.keyManager.decryptData(s.message),a=await this.keyManager.decryptData(s.targetPubKey),n=await this.keyManager.decryptData(s.requestingPubKey),o=this.keyManager.getPublicKey();if(n.toString()==o){const e=null===(r=this.peerPubKeyMessages.get(a.toString()))||void 0===r?void 0:r.rawRandomMessage;if(i.toString()==(null==e?void 0:e.toString())){const e=s.responsePeerInfo;if(e){this.addPeer(e);const t=e.publicKey;this.peerPubKeyMessages.delete(t),console.log("New peer added to the store"),this.emit("found",e)}else this.emit("error","I got a validated response. But no peerInfo")}}else{const e=await this.keyManager.encryptData(Buffer.from(o),n),t=await this.keyManager.encryptData(i,n),r=await this.keyManager.encryptData(n,n),s=l.default.encodeHandshakeMessage(Buffer.from(e),Buffer.from(r),Buffer.from(t),this.localPeerInfo);this.socket.send(s,0,s.length,c,d)}}catch(e){}}}t.default=f},function(e,t){e.exports=require("dgram")},function(e,t){e.exports=require("events")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(45));class a{static createX509Certificate(e=this.N_BITS,t=this.COMMON_NAME,r=this.ORGANIZATION_NAME){const s=i.default.pki,a=s.rsa.generateKeyPair(e),n=s.createCertificate();n.publicKey=a.publicKey,n.serialNumber="01",n.validity.notBefore=new Date,n.validity.notAfter=new Date,n.validity.notAfter.setFullYear(n.validity.notBefore.getFullYear()+1);const o=[{name:"commonName",value:t},{name:"organizationName",value:r}];return n.setSubject(o),n.setIssuer(o),n.setExtensions([{name:"basicConstraints",cA:!0},{name:"keyUsage",keyCertSign:!0,digitalSignature:!0,nonRepudiation:!0,keyEncipherment:!0,dataEncipherment:!0},{name:"extKeyUsage",serverAuth:!0,clientAuth:!0,codeSigning:!0,emailProtection:!0,timeStamping:!0},{name:"nsCertType",client:!0,server:!0,email:!0,objsign:!0,sslCA:!0,emailCA:!0,objCA:!0},{name:"subjectAltName",altNames:{type:7,ip:"127.0.0.1"}},{name:"subjectKeyIdentifier"}]),n.sign(a.privateKey),{keyPem:s.privateKeyToPem(a.privateKey),certPem:s.certificateToPem(n)}}}a.N_BITS=2048,a.COMMON_NAME="polykey",a.ORGANIZATION_NAME="MatrixAI",t.default=a},function(e,t){e.exports=require("node-forge")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(10)),a=s(r(0)),n=s(r(16)),o=r(17),u=s(r(18));t.default=class{constructor(e,t,s){this.key=t,this.keyLen=t.length;const n=new(r(19).VirtualFS);this.efs=new o.EncryptedFS(this.key,n,n,i.default,process),this.name=e,this.vaultPath=a.default.join(s,e),this.efs.mkdirSync(this.vaultPath,{recursive:!0}),this.secrets=new Map,this.loadSecrets(),this.metadataPath=a.default.join(this.vaultPath,".vault","metadata"),this.loadMetadata()}get EncryptedFS(){return this.efs}secretExists(e){const t=a.default.join(this.vaultPath,e);return this.secrets.has(e)&&this.efs.existsSync(t)}async addSecret(e,t){if(this.secrets.has(e))throw new Error("Secret already exists, try updating it instead.");const r=a.default.join(this.vaultPath,e);await this.efs.promises.writeFile(r,t,{}),this.secrets.set(e,t),await this.commitChanges("Add secret: "+e,e,"added")}async updateSecret(e,t){if(!this.secrets.has(e))throw new Error("Secret does not exist, try adding it instead.");const r=a.default.join(this.vaultPath,e);await this.efs.promises.writeFile(r,t,{}),this.secrets.set(e,t),await this.commitChanges("Update secret: "+e,e,"modified")}getSecret(e){if(this.secrets.has(e)){const t=this.secrets.get(e);if(t)return t;{const t=a.default.join(this.vaultPath,e),r=this.efs.readFileSync(t,{});return this.secrets.set(e,r),r}}throw Error("Secret: "+e+" does not exist")}async removeSecret(e){if(this.secrets.has(e)){const t=this.secrets.delete(e);if(await this.efs.promises.unlink(a.default.join(this.vaultPath,e)),await this.commitChanges("Remove secret: "+e,e,"removed"),t)return;throw Error("Secret: "+e+" was not removed")}throw Error("Secret: "+e+" does not exist")}listSecrets(){return Array.from(this.secrets.keys())}tagVault(){}untagVault(){}shareVault(e){if(this.sharedPubKeys.has(name))throw new Error("Vault is already shared with given public key");this.sharedPubKeys.add(e),this.writeMetadata()}unshareVault(e){if(!this.sharedPubKeys.has(e))throw new Error("Vault is not shared with given public key");this.sharedPubKeys.delete(e),this.writeMetadata()}peerCanAccess(e){return!0}async pullVault(e,t){const r="http://"+e.toString()+"/"+this.name;await n.default.currentBranch({fs:{promises:this.efs.promises},dir:this.vaultPath,fullname:!0});const s=new u.default(e,t);await n.default.pull({fs:{promises:this.efs.promises},http:s,dir:this.vaultPath,url:r,ref:"HEAD",singleBranch:!0,author:{name:this.name}}),this.loadSecrets()}async initRepository(){const e=this.efs;await n.default.init({fs:e,dir:this.vaultPath}),await n.default.commit({fs:e,dir:this.vaultPath,author:{name:this.name},message:"init commit"}),this.efs.writeFileSync(a.default.join(this.vaultPath,".git","packed-refs"),"# pack-refs with: peeled fully-peeled sorted")}writeMetadata(){this.efs.mkdirSync(a.default.dirname(this.metadataPath),{recursive:!0});const e={sharedPubKeys:Array.from(this.sharedPubKeys.keys())};this.efs.writeFileSync(this.metadataPath,JSON.stringify(e))}loadMetadata(){if(this.efs.existsSync(this.metadataPath)){const e=this.efs.readFileSync(this.metadataPath).toString(),t=JSON.parse(e);this.sharedPubKeys=new Set(t.sharedPubKeys)}else this.sharedPubKeys=new Set,this.writeMetadata()}async commitChanges(e,t,r){return"removed"==r?await n.default.remove({fs:this.efs,dir:this.vaultPath,filepath:t}):await n.default.add({fs:this.efs,dir:this.vaultPath,filepath:t}),await n.default.commit({fs:this.efs,dir:this.vaultPath,author:{name:this.name},message:e})}loadSecrets(){const e=i.default.readdirSync(this.vaultPath,void 0);for(const t of e.filter(e=>"."!=e[0]))this.secrets.set(t,null)}}}])}));
//# sourceMappingURL=polykey.js.map