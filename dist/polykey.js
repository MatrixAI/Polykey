!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.polykey=t():e.polykey=t()}(this,(function(){return function(e){var t={};function r(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(s,i,function(t){return e[t]}.bind(null,i));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=20)}([function(e,t){e.exports=require("path")},function(e,t){e.exports=require("os")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("readable-stream")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(2)),n=s(r(0)),o=s(r(22)),l=s(r(5)),u=r(23);t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r,s=!1,o){this.primaryKeyPair={private:null,public:null},this.metadata={privateKeyPath:null,publicKeyPath:null,pkiKeyPath:null,pkiCertPath:null,caCertPath:null},this.pkiInfo={key:null,cert:null,caCert:null},this.useWebWorkers=s,this.workerPool=o,this.derivedKeys=new Map,this.fileSystem=t,this.polykeyPath=e;const l=n.default.join(e,".keypair");if(this.fileSystem.existsSync(l)||this.fileSystem.mkdirSync(l),this.metadataPath=n.default.join(l,"metadata"),this.loadMetadata(),this.metadata.privateKeyPath&&this.metadata.publicKeyPath&&r){const e=this.fileSystem.readFileSync(this.metadata.publicKeyPath),t=this.fileSystem.readFileSync(this.metadata.privateKeyPath);this.loadKeyPair(e,t,r)}this.metadata.pkiKeyPath&&(this.pkiInfo.key=a.default.readFileSync(this.metadata.pkiKeyPath)),this.metadata.pkiCertPath&&(this.pkiInfo.cert=a.default.readFileSync(this.metadata.pkiCertPath)),this.metadata.caCertPath&&(this.pkiInfo.caCert=a.default.readFileSync(this.metadata.caCertPath)),this.loadPKIInfo(this.pkiInfo.key,this.pkiInfo.cert,this.pkiInfo.caCert,!0)}async generateKeyPair(e,t,r,s=4096,i=!1,a){if(s<1024)throw new Error("nbits must be greater than 1024 for keypair generation");const n=o.default.const.openpgp,l={asp:a?new o.default.ASP({progress_hook:a}):void 0,userid:`${e} <${t}>`,primary:{nbits:s,flags:n.certify_keys|n.sign_data|n.auth|n.encrypt_comm|n.encrypt_storage,expire_in:0},subkeys:[]},c=await u.promisify(o.default.KeyManager.generate)(l);await u.promisify(c.sign.bind(c))({});const f=await u.promisify(c.export_pgp_public.bind(c))({}),d={private:await u.promisify(c.export_pgp_private.bind(c))({passphrase:r}),public:f};return i&&(this.primaryKeyPair=d,this.primaryIdentity=c),d}getKeyPair(){return this.primaryKeyPair}hasPublicKey(){return!!this.primaryKeyPair.public}getPublicKey(){if(!this.primaryKeyPair.public)throw new Error("Public key does not exist in memory");return this.primaryKeyPair.public}getPrivateKey(){if(!this.primaryKeyPair.private)throw new Error("Private key does not exist in memory");return this.primaryKeyPair.private}async loadKeyPair(e,t,r){await this.loadPrivateKey(t),await this.loadPublicKey(e),await this.loadIdentity(r)}async loadPrivateKey(e){let t;"string"==typeof e?(t=Buffer.from(await this.fileSystem.promises.readFile(e)),this.metadata.privateKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.private=t.toString()}async loadPublicKey(e){let t;"string"==typeof e?(t=Buffer.from(await this.fileSystem.promises.readFile(e)),this.metadata.publicKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.public=t.toString()}async loadIdentity(e){const t=this.getPublicKey(),r=this.getPrivateKey(),s=await u.promisify(o.default.KeyManager.import_from_armored_pgp)({armored:t});await u.promisify(s.merge_pgp_private.bind(s))({armored:r}),s.is_pgp_locked.bind(s)()&&await u.promisify(s.unlock_pgp.bind(s))({passphrase:e}),this.primaryIdentity=s}async exportPrivateKey(e){await this.fileSystem.promises.writeFile(e,this.primaryKeyPair.private),this.metadata.privateKeyPath=e,this.writeMetadata()}async exportPublicKey(e){await this.fileSystem.promises.writeFile(e,this.primaryKeyPair.public),this.metadata.publicKeyPath=e,this.writeMetadata()}generateKeySync(e,t){const r=l.default.randomBytes(32);return this.derivedKeys[e]=l.default.pbkdf2Sync(t,r,1e4,32,"sha256"),this.derivedKeys[e]}async generateKey(e,t){const r=l.default.randomBytes(32);return this.derivedKeys[e]=await u.promisify(l.default.pbkdf2)(t,r,1e4,32,"sha256"),this.derivedKeys[e]}importKeySync(e,t){this.derivedKeys[e]="string"==typeof t?this.fileSystem.readFileSync(t):t}async importKey(e,t){this.derivedKeys[e]="string"==typeof t?await this.fileSystem.promises.readFile(t):t}exportKeySync(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&this.fileSystem.mkdirSync(n.default.dirname(t),{recursive:!0}),this.fileSystem.writeFileSync(t,this.derivedKeys[e])}async exportKey(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&await this.fileSystem.promises.mkdir(n.default.dirname(t),{recursive:!0}),await this.fileSystem.promises.writeFile(t,this.derivedKeys[e])}async getIdentityFromPublicKey(e){return await u.promisify(o.default.KeyManager.import_from_armored_pgp)({armored:e})}async getIdentityFromPrivateKey(e,t){const r=await u.promisify(o.default.KeyManager.import_from_armored_pgp)({armored:e});return r.is_pgp_locked()&&await u.promisify(r.unlock_pgp)({passphrase:t}),r}async signData(e,t,r){let s;if(t){if(!r)throw new Error("passphrase for private key was not provided");s=await this.getIdentityFromPrivateKey(t,r)}else{if(!this.primaryIdentity)throw new Error("no identity available for signing");s=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.signData(e,s))}{const t={msg:e.toString(),sign_with:s},r=await u.promisify(o.default.box)(t);return Buffer.from(r)}}async signFile(e,t,r){let s;t&&(s="string"==typeof t?Buffer.from(this.fileSystem.readFileSync(t)):t);const i=Buffer.from(this.fileSystem.readFileSync(e)),a=await this.signData(i,s,r),n=e+".sig";return this.fileSystem.writeFileSync(n,a),n}async verifyData(e,t,r){const s=new o.default.keyring.KeyRing;let i;if(r)i=await this.getIdentityFromPublicKey(r);else{if(!this.primaryIdentity)throw new Error("no identity available for verifying");i=this.primaryIdentity}if(s.add_key_manager(i),this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async r=>await r.verifyData(e,t,i))}{const r={armored:t,data:e,keyfetch:s};let i,a=(await u.promisify(o.default.unbox)(r))[0].get_data_signer();return a&&(i=a.get_key_manager()),!!i&&!!i.get_pgp_fingerprint()}}async verifyFile(e,t,r){let s;r&&(s="string"==typeof r?this.fileSystem.readFileSync(r):r);const i=this.fileSystem.readFileSync(e),a=this.fileSystem.readFileSync(t);return await this.verifyData(i,a,s)}async encryptData(e,t){let r;if(t)r=await this.getIdentityFromPublicKey(t);else{if(!this.primaryIdentity)throw new Error("Identity could not be resolved for encrypting");r=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.encryptData(e,r))}{const t={msg:e,encrypt_for:r};return await u.promisify(o.default.box)(t)}}async decryptData(e,t,r){var s=new o.default.keyring.KeyRing;let i;if(t){if(!r)throw new Error("A key passphrase must be supplied if a privateKey is specified");i=await this.getIdentityFromPrivateKey(t,r)}else{if(!this.primaryIdentity)throw Error("no identity available for signing");i=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.decryptData(e,i))}{s.add_key_manager(i);const t={armored:e.toString(),keyfetch:s},r=await u.promisify(o.default.unbox)(t);return Buffer.from(r[0].toString())}}get PKIInfo(){return this.pkiInfo}loadPKIInfo(e,t,r,s=!1){if(e&&(this.pkiInfo.key=e),t&&(this.pkiInfo.cert=t),r&&(this.pkiInfo.caCert=r),s){const s=n.default.dirname(this.metadataPath);e&&(this.metadata.pkiKeyPath=n.default.join(s,"pki_private_key"),a.default.writeFileSync(this.metadata.pkiKeyPath,e)),t&&(this.metadata.pkiCertPath=n.default.join(s,"pki_cert"),a.default.writeFileSync(this.metadata.pkiCertPath,t)),r&&(this.metadata.caCertPath=n.default.join(s,"ca_cert"),a.default.writeFileSync(this.metadata.caCertPath,r))}}getKey(e){return this.derivedKeys[e]}hasKey(e){return!!this.derivedKeys[e]}writeMetadata(){const e=JSON.stringify(this.metadata);this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.metadata=JSON.parse(e)}}}},function(e,t){e.exports=require("crypto")},function(e,t,r){"use strict";(function(e){var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const a=s(r(1)),n=s(r(0)),o=s(r(7)),l=s(r(24)),u=s(r(25)),c=s(r(14)),f=r(38),d=i(r(15)),h=s(r(39)),y={name:"Keybase",findUser:async(e,t)=>{const r=`https://keybase.io/_/api/1.0/user/lookup.json?${t}=${e}`;try{const e=await fetch(r);return(await e.json()).them[0].public_keys.primary.bundle}catch(e){throw new Error("User was not found: "+e.message)}}};t.default=class{constructor(t=a.default.homedir()+"/.polykey",s,i,l,c,f=[],p){this.metadata={localPeerInfo:null},this.fileSystem=s,this.fileSystem.mkdirSync(t,{recursive:!0}),this.metadataPath=n.default.join(t,".peerMetadata"),this.keyManager=i,this.socialDiscoveryServices=f,this.loadMetadata(),c?(this.localPeerInfo=c,this.writeMetadata()):this.metadata.localPeerInfo?this.localPeerInfo=this.metadata.localPeerInfo:this.keyManager.hasPublicKey()&&(this.localPeerInfo=new d.default(this.keyManager.getPublicKey())),this.peerStore=new Map,this.socialDiscoveryServices=[],this.socialDiscoveryServices.push(y);for(const e of f)this.socialDiscoveryServices.push(e);this.multicastBroadcaster=new h.default(this.addPeer,this.localPeerInfo,this.keyManager),this.peerConnections=new Map,this.gitBackend=new u.default(t,l),this.server=new o.default.Server;const m=r(8),g=e+"/../../proto/git_server.proto",w=m.loadSync(g,{keepCase:!0,longs:String,enums:String,defaults:!0,oneofs:!0}),P=o.default.loadPackageDefinition(w);this.server.addService(P.GitServer.service,{requestInfo:async function(e,t){const r=e.request.vaultName;t(null,{vaultName:r,body:await this.gitBackend.handleInfoRequest(r)})}.bind(this),requestPack:async function(e,t){const r=e.request.vaultName,s=e.request.body.toString();t(null,{vaultName:r,body:await this.gitBackend.handlePackRequest(r,s)})}.bind(this)});const v=this.keyManager.PKIInfo;v.caCert&&v.cert&&v.key?this.credentials=o.default.ServerCredentials.createSsl(v.caCert,[{private_key:v.key,cert_chain:v.cert}],!0):this.credentials=o.default.ServerCredentials.createInsecure();const b=this.server.bind("0.0.0.0:0",this.credentials),S=new d.Address("localhost",b.toString());this.server.start(),this.localPeerInfo.connect(S)}getLocalPeerInfo(){return this.localPeerInfo}connectLocalPeerInfo(e){this.localPeerInfo.connect(e)}addPeer(e){this.peerStore.set(e.publicKey,e)}getPeer(e){var t;return null!==(t=this.peerStore.get(e))&&void 0!==t?t:null}hasPeer(e){return this.peerStore.has(e)}async findPubKey(e){return new Promise((t,r)=>{this.multicastBroadcaster.requestPeerContact(e),this.multicastBroadcaster.on("found",r=>{r.publicKey==e&&t(r)}),this.multicastBroadcaster.on("timeout",t=>{t==e&&r("The broadcaster stopped looking")})})}async findSocialUser(e,t){const r=[];for(const s of this.socialDiscoveryServices)try{r.push(s.findUser(e,t))}catch(e){console.log("Could not find user on this discovery service: "+s.name)}const s=await f.firstPromiseFulfilled(r);if(s.length>1)throw new Error("Could not find public key from services");const i=s[0];return await this.findPubKey(i)}connectToPeer(e){var t;if(e==this.localPeerInfo.connectedAddr||e==this.localPeerInfo.publicKey)throw new Error("Cannot connect to self");let r;if("string"==typeof e){const s=this.peerConnections.get(e);if(s)return s;const i=null===(t=this.getPeer(e))||void 0===t?void 0:t.connectedAddr;if(!i)throw new Error("Peer does not exist in peer store");r=i}else r=e;const s=new l.default(r,this.keyManager);return"string"==typeof e&&this.peerConnections.set(e,s),s}writeMetadata(){const e=JSON.stringify(c.default.encodePeerInfo(this.localPeerInfo));this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.localPeerInfo=c.default.decodePeerInfo(Buffer.from(e))}}}}).call(this,"/")},function(e,t){e.exports=require("grpc")},function(e,t){e.exports=require("@grpc/proto-loader")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{static flush(){return Buffer.from("0000","utf8")}static encode(e){"string"==typeof e&&(e=Buffer.from(e));const t=function(e,t){const r=t.toString(16);return"0".repeat(e-r.length)+r}(4,e.length+4);return Buffer.concat([Buffer.from(t,"utf8"),e])}static streamReader(e){return async function(){try{let t=await e.slice(4);if(null===t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;let r=await e.slice(t-4);return null===r||r}catch(e){return console.log("error",e),!0}}}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(27));function n(e,t){const r=e.replace(/\^\{\}$/,""),s=t.replace(/\^\{\}$/,""),i=-(r<s)||+(r>s);return 0===i?e.endsWith("^{}")?1:-1:i}const o=["config","description","index","shallow","commondir"];class l{static async packedRefs(e,t){const r=e.readFileSync(t+"/packed-refs",{encoding:"utf8"});return a.default.from(r).refs}static async listRefs(e,t,r){const s=l.packedRefs(e,t);let a=[];try{a=await async function e(t,r){return new Promise((s,a)=>{let n=[];r.promises.readdir(t).then(async a=>{var o=a.length;if(!o)return s(n);a.forEach((async function(a){a=i.default.resolve(t,a),r.promises.stat(a).then(async t=>{if(t&&t.isDirectory()){const t=await e(a,r);n=n.concat(t),--o||s(n)}else n.push(a),--o||s(n)})}))}).catch(e=>{if(e)return a(e)})})}(`${t}/${r}`,e),a=a.map(e=>e.replace(`${t}/${r}/`,""))}catch(e){a=[]}for(let e of(await s).keys())e.startsWith(r)&&(e=e.replace(r+"/",""),a.includes(e)||a.push(e));return a.sort(n),a}static async resolve(e,t,r,s){if(void 0!==s&&-1===--s)return r;if(r.startsWith("ref: "))return r=r.slice("ref: ".length),l.resolve(e,t,r,s);if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const i=await l.packedRefs(e,t),a=(e=>[""+e,"refs/"+e,"refs/tags/"+e,"refs/heads/"+e,"refs/remotes/"+e,`refs/remotes/${e}/HEAD`])(r).filter(e=>!o.includes(e));for(const r of a){const a=e.readFileSync(`${t}/${r}`,{encoding:"utf8"}).toString()||i.get(r);if(a)return l.resolve(e,t,a.trim(),s)}throw Error("RefNotFound")}}t.default=l},function(e,t){e.exports=require("pako")},function(e,t,r){"use strict";function s(e){return 0===e?e:-e}function i(e){let t=(r=s(e),Math.sign(r)||(Object.is(r,-0)?-1:1));var r;e=Math.abs(e);let i=Math.floor(e/60);e-=60*i;let a=String(i),n=String(e);return a.length<2&&(a="0"+a),n.length<2&&(n="0"+n),(-1===t?"-":"+")+a+n}function a(e){let[,t,r,i]=e.match(/(\+|-)(\d\d)(\d\d)/);return i=("+"===t?1:-1)*(60*Number(r)+Number(i)),s(i)}function n(e){let[,t,r,s,i]=e.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:r,timestamp:Number(s),timezoneOffset:a(i)}}function o(e){return e=(e=(e=e.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function l(e){return e.trim().split("\n").map(e=>" "+e).join("\n")+"\n"}Object.defineProperty(t,"__esModule",{value:!0});class u{constructor(e){if("string"==typeof e)this._commit=e;else if(Buffer.isBuffer(e))this._commit=e.toString("utf8");else{if("object"!=typeof e)throw new Error("invalid type passed to GitCommit constructor");this._commit=u.render(e)}}static fromPayloadSignature({payload:e,signature:t}){let r=u.justHeaders(e),s=u.justMessage(e),i=o(r+"\ngpgsig"+l(t)+"\n"+s);return new u(i)}static from(e){return new u(e)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return u.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(e){return o(e.slice(e.indexOf("\n\n")+2))}static justHeaders(e){return e.slice(0,e.indexOf("\n\n"))}parseHeaders(){let e=u.justHeaders(this._commit).split("\n"),t=[];for(let r of e)" "===r[0]?t[t.length-1]+="\n"+r.slice(1):t.push(r);let r={parent:[]};for(let e of t){let t=e.slice(0,e.indexOf(" ")),s=e.slice(e.indexOf(" ")+1);Array.isArray(r[t])?r[t].push(s):r[t]=s}return r.author&&(r.author=n(r.author)),r.committer&&(r.committer=n(r.committer)),r}static renderHeaders(e){let t="";if(e.tree?t+=`tree ${e.tree}\n`:t+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",e.parent){if(void 0===e.parent.length)throw new Error("commit 'parent' property should be an array");for(let r of e.parent)t+=`parent ${r}\n`}let r=e.author;t+=`author ${r.name} <${r.email}> ${r.timestamp} ${i(r.timezoneOffset)}\n`;let s=e.committer||e.author;return t+=`committer ${s.name} <${s.email}> ${s.timestamp} ${i(s.timezoneOffset)}\n`,e.gpgsig&&(t+="gpgsig"+l(e.gpgsig)),t}static render(e){return u.renderHeaders(e)+"\n"+o(e.message)}render(){return this._commit}withoutSignature(){let e=o(this._commit);return-1===e.indexOf("\ngpgsig")?e:o(e.slice(0,e.indexOf("\ngpgsig"))+"\n"+e.slice(e.indexOf("-----END PGP SIGNATURE-----\n")+"-----END PGP SIGNATURE-----\n".length))}isolateSignature(){let e=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length);return e.split("\n").map(e=>e.replace(/^ /,"")).join("\n")}}t.default=u},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(2)),a=s(r(11)),n=s(r(0)),o=s(r(32)),l=new Map;class u{static async read(e,t,r,s="content"){let c=e.readFileSync(`${t}/objects/${r.slice(0,2)}/${r.slice(2)}`),f=`./objects/${r.slice(0,2)}/${r.slice(2)}`;if(!c){const s=r=>u.read(e,t,r);let a=i.default.readdirSync(n.default.join(t,"/objects/pack"));a=a.filter(e=>e.endsWith(".pack"));for(let i of a){let a=l.get(i);if(a.offsets.has(r)){if(!a.pack){const r=e.readFileSync(`${t}/objects/pack/${i}`);await a.load({pack:r})}let n=await a.read({oid:r,getExternalRefDelta:s});return n.source="./objects/pack/"+i,n}}}if(!c){let s=e.readFileSync(t+"/shallow",{encoding:"utf8"});if(null!==s&&s.includes(r))throw new Error("ReadShallowObjectFail: "+r)}if(!c)throw new Error("ReadObjectFail: "+r);if("deflated"===s)return{format:"deflated",object:c,source:f};let d=Buffer.from(a.default.inflate(c));if("wrapped"===s)return{format:"wrapped",object:d,source:f};let{type:h,object:y}=o.default.unwrap({oid:r,buffer:d});return"content"===s?{type:h,format:"content",object:y,source:f}:void 0}}t.default=u},function(e,t,r){"use strict";(function(e){var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(37)),n=s(r(15));t.default=class{static encodePeerInfo(e){var t;const r=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),s=[];for(const t of e.addresses)s.push(t.toString());const i={pubKey:e.publicKey,addresses:s,connectedAddr:null===(t=e.connectedAddr)||void 0===t?void 0:t.toString()},a=r.verify(i);if(a)throw Error(a);const n=r.create(i);return r.encode(n).finish()}static decodePeerInfo(e){const t=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),r=t.decode(e),s=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return new n.default(s.pubKey,s.addresses,s.connectedAddr)}static encodeHandshakeMessage(e,t,r,s){const i=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),a={targetPubKey:e,requestingPubKey:t,message:r,responsePeerInfo:s?this.encodePeerInfo(s):void 0},n=i.verify(a);if(n)throw Error(n);const o=i.create(a);return i.encode(o).finish()}static decodeHandshakeMessage(e){const t=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),r=t.decode(e),s=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return{targetPubKey:Buffer.from(s.targetPubKey,"base64"),requestingPubKey:Buffer.from(s.requestingPubKey,"base64"),message:Buffer.from(s.message,"base64"),responsePeerInfo:s.responsePeerInfo?this.decodePeerInfo(Buffer.from(s.responsePeerInfo,"base64")):void 0}}static loadProto(t){const r=new a.default.Root;return r.resolvePath=(t,r)=>i.default.join(i.default.dirname(e),r),r.loadSync(t)}}}).call(this,"/index.js")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e,t){this.ip=e,this.port=t}static parse(e){const t=e.split(":"),r=t[0],i=t[1];return new s(r,i)}static fromAddressInfo(e){const t="::"==e.address?"localhost":e.address;return new s(t,e.port.toString())}toString(){return`${this.ip}:${this.port}`}}t.Address=s,s.prototype.toString=function(){return`${this.ip}:${this.port}`};t.default=class{constructor(e,t=[],r){this.publicKey=e,this.addresses=new Set(t.map(e=>s.parse(e))),this.connectedAddr=r?s.parse(r):void 0}connect(e){this.addresses.has(e)||this.addresses.add(e),this.connectedAddr=e}disconnect(){this.connectedAddr=void 0}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(0)),n=s(r(17)),o=s(r(42)),l=r(18);t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r){this.polykeyPath=e,this.fileSystem=t,this.keyManager=r,this.metadataPath=a.default.join(e,".vaultKeys"),this.fileSystem.mkdirSync(this.polykeyPath,{recursive:!0}),this.vaults=new Map,this.vaultKeys=new Map,this.loadMetadata();for(const[e,t]of this.vaultKeys.entries()){const r=a.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(r)){const r=new o.default(e,t,this.polykeyPath);this.vaults.set(e,r)}}}getVault(e){if(this.vaults.has(e)){return this.vaults.get(e)}if(this.vaultKeys.has(e)){this.validateVault(e);const t=this.vaultKeys.get(e),r=new o.default(e,t,this.polykeyPath);return this.vaults.set(e,r),r}throw new Error("Vault does not exist in memory")}async createVault(e,t){if(this.vaultExists(e))throw Error("Vault already exists!");try{const r=a.default.join(this.polykeyPath,e);let s;this.fileSystem.mkdirSync(r,{recursive:!0}),s=t||await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),this.vaultKeys.set(e,s),this.writeMetadata();const i=new o.default(e,s,this.polykeyPath);return await i.initRepository(),this.vaults.set(e,i),this.getVault(e)}catch(t){throw this.destroyVault(e),t}}async cloneVault(e,t){if(this.vaultExists(e))throw new Error("Vault name already exists locally, try pulling instead");const s="http://0.0.0.0/"+e;if(!(await n.default.getRemoteInfo({http:t,url:s})).refs)throw new Error(`Peer does not have vault: '${e}'`);const i=await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),u=new(r(19).VirtualFS),c=new l.EncryptedFS(i,u,u,this.fileSystem,process);await n.default.clone({fs:{promises:c.promises},http:t,dir:a.default.join(this.polykeyPath,e),url:s,ref:"master",singleBranch:!0});const f=new o.default(e,i,this.polykeyPath);return this.vaults.set(e,f),f}vaultExists(e){const t=a.default.join(this.polykeyPath,e);return this.fileSystem.existsSync(t)}destroyVault(e){const t=a.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(t)&&this.fileSystem.rmdirSync(t,{recursive:!0}),this.vaults.delete(e),this.vaultKeys.delete(e),this.writeMetadata(),this.fileSystem.existsSync(t))throw new Error("Vault folder could not be destroyed!")}listVaults(){return Array.from(this.vaults.keys())}validateVault(e){if(!this.vaults.has(e))throw Error("Vault does not exist in memory");if(!this.vaultKeys.has(e))throw Error("Vault key does not exist in memory");const t=a.default.join(this.polykeyPath,e);if(!this.fileSystem.existsSync(t))throw Error("Vault directory does not exist")}async writeMetadata(){const e=JSON.stringify([...this.vaultKeys]),t=await this.keyManager.encryptData(Buffer.from(e));await this.fileSystem.promises.writeFile(this.metadataPath,t)}async loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath),t=(await this.keyManager.decryptData(e)).toString();for(const[e,r]of new Map(JSON.parse(t)))this.vaultKeys[e]=Buffer.from(r)}}}},function(e,t){e.exports=require("isomorphic-git")},function(e,t){e.exports=require("encryptedfs")},function(e,t){e.exports=require("virtualfs")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=r(21);t.default=s.default;var i=r(4);t.KeyManager=i.default;var a=r(6);t.PeerManager=a.default;var n=r(16);t.VaultManager=n.default},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(1)),a=s(r(4)),n=s(r(6)),o=s(r(16));t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,r,s,l,u){this.polykeyPath=e,this.keyManager=null!=r?r:new a.default(this.polykeyPath,t),this.vaultManager=null!=s?s:new o.default(this.polykeyPath,t,this.keyManager),this.peerManager=null!=l?l:new n.default(this.polykeyPath,t,this.keyManager,this.vaultManager,void 0,void 0,u)}}},function(e,t){e.exports=require("kbpgp")},function(e,t){e.exports=require("util")},function(e,t,r){"use strict";(function(e){var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(7));t.default=class{constructor(t,s){const a=e+"/../../proto/git_server.proto",n=r(8).loadSync(a,{keepCase:!0,longs:String,enums:String,defaults:!0,oneofs:!0}),o=i.default.loadPackageDefinition(n),l=s.PKIInfo;l.caCert&&l.cert&&l.key?this.credentials=i.default.credentials.createSsl(l.caCert,l.key,l.cert):this.credentials=i.default.credentials.createInsecure(),this.client=new o.GitServer(t.toString(),this.credentials)}async request({url:e,method:t,headers:r,body:s,onProgress:i}){return new Promise(async(i,a)=>{const n=new URL(e);if("GET"==t){const s=n.pathname.match(/\/(.+)\/info\/refs$/);s&&!/\.\./.test(s[1])||a(new Error("Error"));const o=s[1],l=await this.requestInfo(o);i({url:e,method:t,statusCode:200,statusMessage:"OK",body:this.iteratorFromData(l),headers:r})}else if("POST"==t){const o=n.pathname.match(/\/(.+)\/git-(.+)/);o&&!/\.\./.test(o[1])||a(new Error("Error"));const l=o[1],u=await this.requestPack(l,s[0]);i({url:e,method:t,statusCode:200,statusMessage:"OK",body:this.iteratorFromData(u),headers:r})}else a(new Error("Method not supported"))})}async requestInfo(e){return new Promise((t,r)=>{this.client.requestInfo({vaultName:e},(function(e,s){e?(console.log("err"),console.log(e),r(e)):t(s.body)}))})}async requestPack(e,t){return new Promise((r,s)=>{this.client.requestPack({vaultName:e,body:t},(function(e,t){e?(console.log("err"),console.log(e),s(e)):r(t.body)}))})}iteratorFromData(e){let t=!1;return{next:()=>new Promise((r,s)=>{if(t)return r({done:!0});t=!0,r({value:e,done:!1})})}}}}).call(this,"/")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=r(3),n=s(r(26)),o=s(r(28)),l=s(r(30));t.default=class{constructor(e,t){this.polykeyPath=e,this.vaultManager=t}exists(e,t){const r=this.vaultManager.getVault(e);return!!r&&r.peerCanAccess(t)}async handleInfoRequest(e){var t;const r=[];if(!this.exists(e,""))throw new Error("Vault does not exist");{r.push(Buffer.from(this.createGitPacketLine("# service=git-upload-pack\n"))),r.push(Buffer.from("0000"));const s=null===(t=this.vaultManager.getVault(e))||void 0===t?void 0:t.EncryptedFS,a=await n.default(s,i.default.join(this.polykeyPath,e),void 0,!0),o=null!=a?a:[];r.push(...o)}return Buffer.concat(r)}async handlePackRequest(e,t){return new Promise(async(r,s)=>{var n;const u=[];if(!this.exists(e,""))throw new Error("Vault does not exist");const c=null===(n=this.vaultManager.getVault(e))||void 0===n?void 0:n.EncryptedFS;if(c&&"want"==t.toString().slice(4,8)){const n=t.toString().slice(9,49),f=await l.default(c,i.default.join(this.polykeyPath,e),[n],void 0);u.push(Buffer.from("0008NAK\n"));const d=new a.PassThrough,h=new a.PassThrough,y=o.default.mux("side-band-64",d,f.packstream,h,[]);y.on("data",e=>{u.push(e)}),y.on("end",()=>{r(Buffer.concat(u))}),y.on("error",e=>{s(e)}),h.write(Buffer.from("0014progress is at 50%\n")),h.end()}})}createGitPacketLine(e){const t=(4+e.length).toString(16);return Array(4-t.length+1).join("0")+t+e}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(0)),a=s(r(9)),n=s(r(10));t.default=async function(e,t,r=i.default.join(t,".git"),s=!1){try{if(s){const t=["side-band-64k"];let s=await n.default.listRefs(e,r,"refs");s=s.map(e=>"refs/"+e);const i={};s.unshift("HEAD");for(const t of s)i[t]=await n.default.resolve(e,r,t);const o={};return o.HEAD=await n.default.resolve(e,r,"HEAD",2),async function({capabilities:e,refs:t,symrefs:r}){const s=[];let i="";for(const[e,t]of Object.entries(r))i+=`symref=${e}:${t} `;let n=`\0${[...e].join(" ")} ${i}agent=git/isomorphic-git@1.4.0`;for(const[e,r]of Object.entries(t))s.push(a.default.encode(`${r} ${e}${n}\n`)),n="";return s.push(a.default.flush()),s}({capabilities:t,refs:i,symrefs:o})}}catch(e){throw e.caller="git.uploadPack",e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){if(this.refs=new Map,this.parsedConfig=[],e){let t;this.parsedConfig=e.trim().split("\n").map(e=>{if(/^\s*#/.test(e))return{line:e,comment:!0};const r=e.indexOf(" ");if(e.startsWith("^")){const r=e.slice(1);return this.refs.set(t+"^{}",r),{line:e,ref:t,peeled:r}}{const s=e.slice(0,r);return t=e.slice(r+1),this.refs.set(t,s),{line:e,ref:t,oid:s}}})}return this}static from(e){return new s(e)}}t.default=s},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=r(29),a=r(3),n=s(r(9));function o(e,t){const r=[];let s=0;for(;s<e.length;){const i=e.slice(s,s+t);r.push(i),s+=i.length}return r.push(e.slice(s)),r}t.default=class{static demux(e){let t=n.default.streamReader(e),r=new a.PassThrough,s=new a.PassThrough,i=new a.PassThrough;const o=async function(){let e=await t();if(null===e)return o();if(!0===e)return r.end(),i.end(),void s.end();switch(e[0]){case 1:s.write(e.slice(1));break;case 2:i.write(e.slice(1));break;case 3:let t=e.slice(1);return i.write(t),void s.destroy(new Error(t.toString("utf8")));default:r.write(e.slice(0))}o()};return o(),{packetlines:r,packfile:s,progress:i}}static mux(e,t,r,s,l){const u="side-band-64k"===e?999:65519;let c=new a.PassThrough;t.on("data",e=>{null===e?c.write(n.default.flush()):c.write(n.default.encode(e))});let f=!0,d=!1,h=!1,y=i.Buffer.concat([n.default.encode(i.Buffer.from("010A","hex")),n.default.flush()]);return r.on("data",e=>{f=!1;const t=o(e,u);for(const e of t)c.write(n.default.encode(i.Buffer.concat([i.Buffer.from("01","hex"),e])))}).on("end",()=>{d=!0,f||c.write(y),h&&c.end()}),s.on("data",e=>{const t=o(e,u);for(const e of t)c.write(n.default.encode(i.Buffer.concat([i.Buffer.from("02","hex"),e])))}).on("end",()=>{h=!0,d&&c.end()}),c}}},function(e,t){e.exports=require("buffer")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(11)),a=s(r(0)),n=s(r(31)),o=s(r(35)),l=s(r(36)),u=s(r(12)),c=r(3),f=s(r(13)),d={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function h(e,t,r=a.default.join(t,".git"),s){let i=new Set,n=new Set,l=new Set;async function c(t){let{type:s,object:a}=await f.default.read(e,r,t);if("commit"===s){i.add(t);let e=u.default.from(a).headers().tree;await c(e)}else if("tree"===s){n.add(t);let e=o.default.from(a);for(let t of e)"blob"===t.type&&l.add(t.oid),"tree"===t.type&&await c(t.oid)}}for(let e of s)await c(e);return[...i,...n,...l]}async function y(e,t,r=a.default.join(t,".git"),s,n){let o=l.default("sha1");function u(e,t){t?n.write(e,t):n.write(e),o.update(e,t)}function c(e,t){let r,s,a,n=d[t];if(void 0===n)throw new Error("Unrecognized type: "+t);a=e.length,s=a>15?128:0,r=15&a,a>>>=4;let o=(s|n|r).toString(16);for(u(o,"hex");s;){s=a>127?128:0,o=s|127&a;const e=o.toString(16);u("0".repeat(2-e.length)+e,"hex"),a>>>=7}u(Buffer.from(i.default.deflate(e)))}u("PACK"),u("00000002","hex");const h=s.length.toString(16);u("0".repeat(8-h.length)+h,"hex");for(let t of s){let{type:s,object:i}=await f.default.read(e,r,t);c(i,s)}let y=o.digest();return n.end(y),n}t.listObjects=h,t.pack=y,t.default=async function(e,t,r,s,i){const o=a.default.join(t,".git");let l=new Set,u=new Set,f=new Set,d=[];i=i||[];for(const a of r)try{let r=await n.default(e,t,o,void 0,a,s,void 0),c=[];for(let e=0;e<r.length;e++){let t=r[e];if(i.includes(t.oid)){d.push({oid:a});break}l.add(t.oid),e===r.length-1?c.includes(t.oid)||void 0===s||(console.log("make it shallow",t.oid),u.add(t.oid)):c.includes(t.oid)&&(console.log("make it unshallow",t.oid),f.add(t.oid))}}catch(e){console.log(e)}let p=await h(e,t,o,Array.from(l)),m=new c.PassThrough;return y(e,t,void 0,[...p],m),{packstream:m,shallows:u,unshallows:f,acks:d}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=r(0),a=s(r(12)),n=s(r(13)),o=s(r(10));async function l(e,t,r,s){try{let{type:i,object:o}=await n.default.read(e,t,r);if("commit"!==i)throw new Error("expected type to be commit");const l=a.default.from(o),u=Object.assign({oid:r},l.parse());return s&&(u.payload=l.withoutSignature()),u}catch(e){return{oid:r,error:e}}}function u(e,t){return e.committer.timestamp-t.committer.timestamp}t.logCommit=l,t.default=async function(e,t,r=i.join(t,".git"),s="HEAD",a,n,c=!1){try{let t=void 0===n?void 0:Math.floor(n.valueOf()/1e3),i=[],f=await o.default.resolve(e,r,s),d=[await l(e,r,f,c)];for(;;){let s=d.pop();if(s.error){i.push(s);break}if(void 0!==t&&s.committer.timestamp<=t)break;if(i.push(s),void 0!==a&&i.length===a)break;for(const t of s.parent){let s=await l(e,r,t,c);d.map(e=>e.oid).includes(s.oid)||d.push(s)}if(0===d.length)break;d.sort(u)}return i}catch(e){throw e.caller="git.log",e}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(33));t.default=class{static hash({type:e,object:t}){let r=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),Buffer.from(t)]);return i.default(r)}static wrap({type:e,object:t}){let r=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),t]);return{oid:i.default(r),buffer:r}}static unwrap({oid:e,buffer:t}){if(e){let r=i.default(t);if(r!==e)throw new Error(`SHA check failed! Expected ${e}, computed ${r}`)}let r=t.indexOf(32),s=t.indexOf(0),a=t.slice(0,r).toString("utf8"),n=t.slice(r+1,s).toString("utf8"),o=t.length-(s+1);if(parseInt(n)!==o)throw new Error(`Length mismatch: expected ${n} bytes but got ${o} instead.`);return{type:a,object:Buffer.from(t.slice(s+1))}}}},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(34));t.default=function(e){return(new i.default).update(e).digest("hex")}},function(e,t){e.exports=require("sha.js/sha1")},function(e,t,r){"use strict";function s(e){return!e.oid&&e.sha&&(e.oid=e.sha),e.mode=function(e){if("number"==typeof e&&(e=e.toString(8)),e.match(/^0?4.*/))return"40000";if(e.match(/^1006.*/))return"100644";if(e.match(/^1007.*/))return"100755";if(e.match(/^120.*/))return"120000";if(e.match(/^160.*/))return"160000";throw new Error("Could not understand file mode: "+e)}(e.mode),e.type||(e.type="blob"),e}Object.defineProperty(t,"__esModule",{value:!0});class i{constructor(e){if(Buffer.isBuffer(e))this._entries=function(e){let t=[],r=0;for(;r<e.length;){let s=e.indexOf(32,r);if(-1===s)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);let i=e.indexOf(0,r);if(-1===i)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let a=e.slice(r,s).toString("utf8");"40000"===a&&(a="040000");let n="040000"===a?"tree":"blob",o=e.slice(s+1,i).toString("utf8"),l=e.slice(i+1,i+21).toString("hex");r=i+21,t.push({mode:a,path:o,oid:l,type:n})}return t}(e);else{if(!Array.isArray(e))throw new Error("invalid type passed to GitTree constructor");this._entries=e.map(s)}}static from(e){return new i(e)}render(){return this._entries.map(e=>`${e.mode} ${e.type} ${e.oid}    ${e.path}`).join("\n")}toObject(){return Buffer.concat(this._entries.map(e=>{let t=Buffer.from(e.mode.replace(/^0/,"")),r=Buffer.from(" "),s=Buffer.from(e.path),i=Buffer.from([0]),a=Buffer.from(e.oid.match(/../g).map(e=>parseInt(e,16)));return Buffer.concat([t,r,s,i,a])}))}entries(){return this._entries}*[Symbol.iterator](){for(let e of this._entries)yield e}}t.default=i},function(e,t){e.exports=require("sha.js")},function(e,t){e.exports=require("protobufjs")},function(e,t,r){"use strict";function s(e){return new Promise((t,r)=>e.then(r,t))}Object.defineProperty(t,"__esModule",{value:!0}),t.randomString=function(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)},t.firstPromiseFulfilled=function(e){return s(Promise.all(e.map(s)))}},function(e,t,r){"use strict";var s,i,a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=a(r(40)),o=a(r(5)),l=r(41),u=a(r(14)),c=parseInt(null!==(s=process.env.UDP_MULTICAST_PORT)&&void 0!==s?s:"5353"),f=null!==(i=process.env.UDP_MULTICAST_ADDR)&&void 0!==i?i:"224.0.0.251";class d extends l.EventEmitter{constructor(e,t,r){super(),this.peerPubKeyMessages=new Map,this.addPeer=e,this.localPeerInfo=t,this.keyManager=r,this.interval=1e3,this.queryInterval=null,this.socket=n.default.createSocket({type:"udp4",reuseAddr:!0}),this.socket.bind(c),this.socket.on("listening",(()=>{this.socket.addMembership(f);this.socket.address()}).bind(this)),this.socket.on("message",this.handleHandshakeMessages.bind(this)),this.queryInterval=this.queryLAN()}async requestPeerContact(e){const t=Buffer.from(e),r=o.default.randomBytes(16),s=await this.keyManager.encryptData(t,t),i=await this.keyManager.encryptData(r,t),a=await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()),t);this.peerPubKeyMessages.set(e,{encryptedLocalPubKey:Buffer.from(a),encryptedPeerPubKey:Buffer.from(s),rawRandomMessage:r,encryptedRandomMessage:Buffer.from(i)})}queryLAN(){const e=()=>{for(const e of this.peerPubKeyMessages.keys()){const t=this.peerPubKeyMessages.get(e);if(t){const e=u.default.encodeHandshakeMessage(t.encryptedPeerPubKey,t.encryptedLocalPubKey,t.encryptedRandomMessage);this.socket.send(e,0,e.length,c,f,()=>{console.info("Sending message to peer")})}}};return e(),setInterval(e,this.interval)}async handleHandshakeMessages(e,t){var r;try{const s=u.default.decodeHandshakeMessage(e);console.info(`Message from: ${t.address}:${t.port}`);const i=await this.keyManager.decryptData(s.message),a=await this.keyManager.decryptData(s.targetPubKey),n=await this.keyManager.decryptData(s.requestingPubKey),o=this.keyManager.getPublicKey();if(n.toString()==o){const e=null===(r=this.peerPubKeyMessages.get(a.toString()))||void 0===r?void 0:r.rawRandomMessage;if(i.toString()==(null==e?void 0:e.toString())){const e=s.responsePeerInfo;if(e){this.addPeer(e);const t=e.publicKey;this.peerPubKeyMessages.delete(t),console.log("New peer added to the store"),this.emit("found",e)}else this.emit("error","I got a validated response. But no peerInfo")}}else{const e=await this.keyManager.encryptData(Buffer.from(o),n),t=await this.keyManager.encryptData(i,n),r=await this.keyManager.encryptData(n,n),s=u.default.encodeHandshakeMessage(Buffer.from(e),Buffer.from(r),Buffer.from(t),this.localPeerInfo);this.socket.send(s,0,s.length,c,f)}}catch(e){}}}t.default=d},function(e,t){e.exports=require("dgram")},function(e,t){e.exports=require("events")},function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(r(2)),a=s(r(0)),n=s(r(17)),o=r(18);t.default=class{constructor(e,t,s){this.key=t,this.keyLen=t.length;const n=new(r(19).VirtualFS);this.efs=new o.EncryptedFS(this.key,n,n,i.default,process),this.name=e,this.vaultPath=a.default.join(s,e),this.efs.mkdirSync(this.vaultPath,{recursive:!0}),this.secrets=new Map,this.loadSecrets(),this.metadataPath=a.default.join(this.vaultPath,".vault","metadata"),this.loadMetadata()}get EncryptedFS(){return this.efs}secretExists(e){const t=a.default.join(this.vaultPath,e);return this.secrets.has(e)&&this.efs.existsSync(t)}async addSecret(e,t){if(this.secrets.has(e))throw new Error("Secret already exists, try updating it instead.");const r=a.default.join(this.vaultPath,e);await this.efs.promises.writeFile(r,t,{}),this.secrets.set(e,t),await this.commitChanges("Add secret: "+e,e,"added")}async updateSecret(e,t){if(!this.secrets.has(e))throw new Error("Secret does not exist, try adding it instead.");const r=a.default.join(this.vaultPath,e);await this.efs.promises.writeFile(r,t,{}),this.secrets.set(e,t),await this.commitChanges("Update secret: "+e,e,"modified")}getSecret(e){if(this.secrets.has(e)){const t=this.secrets.get(e);if(t)return t;{const t=a.default.join(this.vaultPath,e),r=this.efs.readFileSync(t,{});return this.secrets.set(e,r),r}}throw Error("Secret: "+e+" does not exist")}async removeSecret(e){if(this.secrets.has(e)){const t=this.secrets.delete(e);if(await this.efs.promises.unlink(a.default.join(this.vaultPath,e)),await this.commitChanges("Remove secret: "+e,e,"removed"),t)return;throw Error("Secret: "+e+" was not removed")}throw Error("Secret: "+e+" does not exist")}listSecrets(){return Array.from(this.secrets.keys())}tagVault(){}untagVault(){}shareVault(e){if(this.sharedPubKeys.has(name))throw new Error("Vault is already shared with given public key");this.sharedPubKeys.add(e),this.writeMetadata()}unshareVault(e){if(!this.sharedPubKeys.has(e))throw new Error("Vault is not shared with given public key");this.sharedPubKeys.delete(e),this.writeMetadata()}peerCanAccess(e){return!0}async pullVault(e){await n.default.currentBranch({fs:{promises:this.efs.promises},dir:this.vaultPath,fullname:!0}),await n.default.pull({fs:{promises:this.efs.promises},http:e,dir:this.vaultPath,url:"http://0.0.0.0:0/"+this.name,ref:"HEAD",singleBranch:!0,author:{name:this.name}}),this.loadSecrets()}async initRepository(){const e=this.efs;await n.default.init({fs:e,dir:this.vaultPath}),await n.default.commit({fs:e,dir:this.vaultPath,author:{name:this.name},message:"init commit"}),this.efs.writeFileSync(a.default.join(this.vaultPath,".git","packed-refs"),"# pack-refs with: peeled fully-peeled sorted")}writeMetadata(){this.efs.mkdirSync(a.default.dirname(this.metadataPath),{recursive:!0});const e={sharedPubKeys:Array.from(this.sharedPubKeys.keys())};this.efs.writeFileSync(this.metadataPath,JSON.stringify(e))}loadMetadata(){if(this.efs.existsSync(this.metadataPath)){const e=this.efs.readFileSync(this.metadataPath).toString(),t=JSON.parse(e);this.sharedPubKeys=new Set(t.sharedPubKeys)}else this.sharedPubKeys=new Set,this.writeMetadata()}async commitChanges(e,t,r){return"removed"==r?await n.default.remove({fs:this.efs,dir:this.vaultPath,filepath:t}):await n.default.add({fs:this.efs,dir:this.vaultPath,filepath:t}),await n.default.commit({fs:this.efs,dir:this.vaultPath,author:{name:this.name},message:e})}loadSecrets(){const e=i.default.readdirSync(this.vaultPath,void 0);for(const t of e.filter(e=>"."!=e[0]))this.secrets.set(t,null)}}}])}));
//# sourceMappingURL=polykey.js.map