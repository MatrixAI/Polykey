!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.pk=t():e.pk=t()}(this,(function(){return function(e){var t={};function r(a){if(t[a])return t[a].exports;var s=t[a]={i:a,l:!1,exports:{}};return e[a].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=e,r.c=t,r.d=function(e,t,a){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)r.d(a,s,function(t){return e[t]}.bind(null,s));return a},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=1)}([function(e,t){e.exports=require("path")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(8)),i=r(2),n=a(r(23)),o=a(r(24)),u=a(r(57)),l=a(r(58)),c=a(r(59)),d=a(r(60));function f(e){console.error(s.default.red(e.message))}var h;t.actionRunner=function(e){return(...t)=>e(...t).catch(f)},function(e){e[e.SUCCESS=0]="SUCCESS",e[e.INFO=1]="INFO",e[e.WARNING=2]="WARNING"}(h||(h={})),t.PKMessageType=h,t.pkLogger=function(e,t){switch(t){case h.SUCCESS:console.log(s.default.green(e));break;case h.INFO:console.log(s.default.blue(e));break;case h.WARNING:console.log(s.default.yellow(e));break;default:console.log(e)}};const p=new i.program.Command;p.version(r(61).version,"--version","output the current version").addCommand(n.default()).addCommand(u.default()).addCommand(l.default()).addCommand(o.default()).addCommand(d.default()).addCommand(c.default()),e.exports=function(e){p.parse(e)}},function(e,t){e.exports=require("commander")},function(e,t){e.exports=require("os")},function(e,t){e.exports=require("fs")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(4)),i=a(r(3)),n=a(r(25)),o=a(r(26)),u=a(r(9)),l=a(r(27)),c=a(r(55)),d=a(r(16)),f=r(1),h=new u.default("PolyKeyConfig");async function p(e){await new Promise((t,r)=>{o.default.prompt(e).then(r=>{for(const t of e)r[t.name]&&h.set(t.name,r[t.name]);t()}).catch(e=>{e.isTtyError,r(e)})})}t.default=async function(){return new Promise(f.actionRunner(async(e,t)=>{await async function(){const e=[];o.default.registerPrompt("fuzzypath",r(56)),h.get("polykeyPath")||e.push({type:"fuzzypath",name:"polykeyPath",message:"Where would you like to store PolyKey?",default:i.default.homedir()+"/.polykey",rootPath:i.default.homedir(),itemType:"directory",depthLimit:1}),h.has("generateKeyPair")||e.push({type:"confirm",name:"generateKeyPair",message:"Would you like to generate a public/private keypair?",default:!0}),e.length>0&&await p(e);const t=[];h.get("generateKeyPair")?(h.get("keyGenerationName")||t.push({type:"input",name:"keyGenerationName",message:"Please provide your full name for key generation?"}),h.get("keyGenerationEmail")||t.push({type:"input",name:"keyGenerationEmail",message:"Please provide an email for key generation?"}),h.get("keyGenerationPassphrase")||t.push({type:"input",name:"keyGenerationPassphrase",message:"Please provide a secure passphrase for key generation?"})):(h.get("publicKeyPath")||t.push({type:"fuzzypath",name:"publicKeyPath",message:"Please provide the path to your public key?",rootPath:i.default.homedir(),suggestOnly:!0,depthLimit:1}),h.get("privateKeyPath")||t.push({type:"fuzzypath",name:"privateKeyPath",message:"Please providee the path to your private key?",rootPath:i.default.homedir(),suggestOnly:!0,depthLimit:1}),h.get("privatePassphrase")||t.push({type:"input",name:"privatePassphrase",message:"Please provide your private key passphrase?"})),t.length>0&&await p(t)}();const a=h.get("polykeyPath"),u=h.get("generateKeyPair");console.log(h.get("generateKeyPair"));const y=new d.default(a,s.default);if(u){console.log("im here");const e=h.get("keyGenerationName"),t=h.get("keyGenerationEmail"),r=h.get("keyGenerationPassphrase");n.default(r).score<2&&f.pkLogger("passphrase score for new keypair is below 2!",f.PKMessageType.WARNING);const a=new c.default.MultiBar({clearOnComplete:!1,hideCursor:!0,format:"Finding '{type}' Prime | [{bar} | {value}/{total} iterations"},c.default.Presets.shades_classic),o=a.create(10,0,{type:"p"}),u=a.create(10,0,{type:"q"});await y.generateKeyPair(e,t,r,void 0,!0,e=>{"mr"==e.what&&"p"==e.section?o.update(e.i,{type:"p"}):"mr"==e.what&&"q"==e.section&&u.update(e.i,{type:"q"})}),o.stop(),u.stop(),f.pkLogger(""),f.pkLogger(""),f.pkLogger("");const l=("~"!==(m=y.polykeyPath)[0]||"/"!==m[1]&&1!==m.length||(m=m.replace("~",i.default.homedir())),m)+"/.keypair";s.default.mkdirSync(l,{recursive:!0});const d=l+"/public_key",p=l+"/private_key";await y.exportPublicKey(d),await y.exportPrivateKey(p),h.set("publicKeyPath",d),h.set("privateKeyPath",p),h.set("privatePassphrase",r),console.log(h.get("generateKeyPair")),h.set("generateKeyPair",!1),h.delete("keyGenerationName"),h.delete("keyGenerationEmail"),h.delete("keyGenerationPassphrase")}else{const e=h.get("publicKeyPath"),t=h.get("privateKeyPath"),r=h.get("privatePassphrase");await y.loadKeyPair(e,t,r)}var m;e(new l.default(a,s.default,y))}))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class a{constructor(e,t){this.ip=e,this.port=t}static parse(e){const t=e.split(":"),r=t[0],s=t[1];return new a(r,s)}static fromAddressInfo(e){const t="::"==e.address?"127.0.0.1":e.address;return new a(t,e.port.toString())}toString(){return`${this.ip}:${this.port}`}}t.Address=a,a.prototype.toString=function(){return`${this.ip}:${this.port}`};t.default=class{constructor(e,t=[],r){this.publicKey=e,this.addresses=new Set(t.map(e=>a.parse(e))),this.connectedAddr=r?a.parse(r):void 0}connect(e){this.addresses.has(e)||this.addresses.add(e),this.connectedAddr=e}disconnect(){this.connectedAddr=void 0}}},function(e,t){e.exports=require("readable-stream")},function(e,t){e.exports=require("chalk")},function(e,t){e.exports=require("configstore")},function(e,t){e.exports=require("http")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{static flush(){return Buffer.from("0000","utf8")}static encode(e){"string"==typeof e&&(e=Buffer.from(e));const t=function(e,t){const r=t.toString(16);return"0".repeat(e-r.length)+r}(4,e.length+4);return Buffer.concat([Buffer.from(t,"utf8"),e])}static streamReader(e){return async function(){try{let t=await e.slice(4);if(null===t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;let r=await e.slice(t-4);return null===r||r}catch(e){return console.log("error",e),!0}}}}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(0)),i=a(r(31));function n(e,t){const r=e.replace(/\^\{\}$/,""),a=t.replace(/\^\{\}$/,""),s=-(r<a)||+(r>a);return 0===s?e.endsWith("^{}")?1:-1:s}const o=["config","description","index","shallow","commondir"];class u{static async packedRefs(e,t){const r=e.readFileSync(t+"/packed-refs",{encoding:"utf8"});return i.default.from(r).refs}static async listRefs(e,t,r){const a=u.packedRefs(e,t);let i=[];try{i=await async function e(t,r){return new Promise((a,i)=>{let n=[];r.promises.readdir(t).then(async i=>{var o=i.length;if(!o)return a(n);i.forEach((async function(i){i=s.default.resolve(t,i),r.promises.stat(i).then(async t=>{if(t&&t.isDirectory()){const t=await e(i,r);n=n.concat(t),--o||a(n)}else n.push(i),--o||a(n)})}))}).catch(e=>{if(e)return i(e)})})}(`${t}/${r}`,e),i=i.map(e=>e.replace(`${t}/${r}/`,""))}catch(e){i=[]}for(let e of(await a).keys())e.startsWith(r)&&(e=e.replace(r+"/",""),i.includes(e)||i.push(e));return i.sort(n),i}static async resolve(e,t,r,a){if(void 0!==a&&-1===--a)return r;if(r.startsWith("ref: "))return r=r.slice("ref: ".length),u.resolve(e,t,r,a);if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const s=await u.packedRefs(e,t),i=(e=>[""+e,"refs/"+e,"refs/tags/"+e,"refs/heads/"+e,"refs/remotes/"+e,`refs/remotes/${e}/HEAD`])(r).filter(e=>!o.includes(e));for(const r of i){const i=e.readFileSync(`${t}/${r}`,{encoding:"utf8"}).toString()||s.get(r);if(i)return u.resolve(e,t,i.trim(),a)}throw Error("RefNotFound")}}t.default=u},function(e,t){e.exports=require("pako")},function(e,t,r){"use strict";function a(e){return 0===e?e:-e}function s(e){let t=(r=a(e),Math.sign(r)||(Object.is(r,-0)?-1:1));var r;e=Math.abs(e);let s=Math.floor(e/60);e-=60*s;let i=String(s),n=String(e);return i.length<2&&(i="0"+i),n.length<2&&(n="0"+n),(-1===t?"-":"+")+i+n}function i(e){let[,t,r,s]=e.match(/(\+|-)(\d\d)(\d\d)/);return s=("+"===t?1:-1)*(60*Number(r)+Number(s)),a(s)}function n(e){let[,t,r,a,s]=e.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:r,timestamp:Number(a),timezoneOffset:i(s)}}function o(e){return e=(e=(e=e.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function u(e){return e.trim().split("\n").map(e=>" "+e).join("\n")+"\n"}Object.defineProperty(t,"__esModule",{value:!0});class l{constructor(e){if("string"==typeof e)this._commit=e;else if(Buffer.isBuffer(e))this._commit=e.toString("utf8");else{if("object"!=typeof e)throw new Error("invalid type passed to GitCommit constructor");this._commit=l.render(e)}}static fromPayloadSignature({payload:e,signature:t}){let r=l.justHeaders(e),a=l.justMessage(e),s=o(r+"\ngpgsig"+u(t)+"\n"+a);return new l(s)}static from(e){return new l(e)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return l.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(e){return o(e.slice(e.indexOf("\n\n")+2))}static justHeaders(e){return e.slice(0,e.indexOf("\n\n"))}parseHeaders(){let e=l.justHeaders(this._commit).split("\n"),t=[];for(let r of e)" "===r[0]?t[t.length-1]+="\n"+r.slice(1):t.push(r);let r={parent:[]};for(let e of t){let t=e.slice(0,e.indexOf(" ")),a=e.slice(e.indexOf(" ")+1);Array.isArray(r[t])?r[t].push(a):r[t]=a}return r.author&&(r.author=n(r.author)),r.committer&&(r.committer=n(r.committer)),r}static renderHeaders(e){let t="";if(e.tree?t+=`tree ${e.tree}\n`:t+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",e.parent){if(void 0===e.parent.length)throw new Error("commit 'parent' property should be an array");for(let r of e.parent)t+=`parent ${r}\n`}let r=e.author;t+=`author ${r.name} <${r.email}> ${r.timestamp} ${s(r.timezoneOffset)}\n`;let a=e.committer||e.author;return t+=`committer ${a.name} <${a.email}> ${a.timestamp} ${s(a.timezoneOffset)}\n`,e.gpgsig&&(t+="gpgsig"+u(e.gpgsig)),t}static render(e){return l.renderHeaders(e)+"\n"+o(e.message)}render(){return this._commit}withoutSignature(){let e=o(this._commit);return-1===e.indexOf("\ngpgsig")?e:o(e.slice(0,e.indexOf("\ngpgsig"))+"\n"+e.slice(e.indexOf("-----END PGP SIGNATURE-----\n")+"-----END PGP SIGNATURE-----\n".length))}isolateSignature(){let e=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length);return e.split("\n").map(e=>e.replace(/^ /,"")).join("\n")}}t.default=l},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(4)),i=a(r(13)),n=a(r(0)),o=a(r(36)),u=new Map;class l{static async read(e,t,r,a="content"){let c=e.readFileSync(`${t}/objects/${r.slice(0,2)}/${r.slice(2)}`),d=`./objects/${r.slice(0,2)}/${r.slice(2)}`;if(!c){const a=r=>l.read(e,t,r);let i=s.default.readdirSync(n.default.join(t,"/objects/pack"));i=i.filter(e=>e.endsWith(".pack"));for(let s of i){let i=u.get(s);if(i.offsets.has(r)){if(!i.pack){const r=e.readFileSync(`${t}/objects/pack/${s}`);await i.load({pack:r})}let n=await i.read({oid:r,getExternalRefDelta:a});return n.source="./objects/pack/"+s,n}}}if(!c){let a=e.readFileSync(t+"/shallow",{encoding:"utf8"});if(null!==a&&a.includes(r))throw new Error("ReadShallowObjectFail: "+r)}if(!c)throw new Error("ReadObjectFail: "+r);if("deflated"===a)return{format:"deflated",object:c,source:d};let f=Buffer.from(i.default.inflate(c));if("wrapped"===a)return{format:"wrapped",object:f,source:d};let{type:h,object:p}=o.default.unwrap({oid:r,buffer:f});return"content"===a?{type:h,format:"content",object:p,source:d}:void 0}}t.default=l},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(3)),i=a(r(0)),n=a(r(41)),o=a(r(17)),u=r(42);t.default=class{constructor(e=s.default.homedir()+"/.polykey",t,r,a=!1,n){this.primaryKeyPair={private:null,public:null},this.metadata={privateKeyPath:null,publicKeyPath:null},this.useWebWorkers=a,this.workerPool=n,this.derivedKeys=new Map,this.fileSystem=t,this.polykeyPath=e;const o=i.default.join(e,".keypair");if(this.fileSystem.existsSync(o)||this.fileSystem.mkdirSync(o),this.metadataPath=i.default.join(o,"metadata"),this.loadMetadata(),this.metadata.privateKeyPath&&this.metadata.publicKeyPath&&r){const e=this.fileSystem.readFileSync(this.metadata.publicKeyPath),t=this.fileSystem.readFileSync(this.metadata.privateKeyPath);this.loadKeyPair(e,t,r)}}async generateKeyPair(e,t,r,a=4096,s=!1,i){const o=n.default.const.openpgp,l={asp:i?new n.default.ASP({progress_hook:i}):void 0,userid:`${e} <${t}>`,primary:{nbits:a,flags:o.certify_keys|o.sign_data|o.auth|o.encrypt_comm|o.encrypt_storage,expire_in:0},subkeys:[]},c=await u.promisify(n.default.KeyManager.generate)(l);await u.promisify(c.sign.bind(c))({});const d=await u.promisify(c.export_pgp_public.bind(c))({}),f={private:await u.promisify(c.export_pgp_private.bind(c))({passphrase:r}),public:d};return s&&(this.primaryKeyPair=f,this.primaryIdentity=c),f}getKeyPair(){return this.primaryKeyPair}hasPublicKey(){return!!this.primaryKeyPair.public}getPublicKey(){if(!this.primaryKeyPair.public)throw new Error("Public key does not exist in memory");return this.primaryKeyPair.public}getPrivateKey(){if(!this.primaryKeyPair.private)throw new Error("Private key does not exist in memory");return this.primaryKeyPair.private}async loadKeyPair(e,t,r){await this.loadPrivateKey(t),await this.loadPublicKey(e),await this.loadIdentity(r)}async loadPrivateKey(e){let t;"string"==typeof e?(t=Buffer.from(await this.fileSystem.promises.readFile(e)),this.metadata.privateKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.private=t.toString()}async loadPublicKey(e){let t;"string"==typeof e?(t=Buffer.from(await this.fileSystem.promises.readFile(e)),this.metadata.publicKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.public=t.toString()}async loadIdentity(e){const t=this.getPublicKey(),r=this.getPrivateKey(),a=await u.promisify(n.default.KeyManager.import_from_armored_pgp)({armored:t});await u.promisify(a.merge_pgp_private.bind(a))({armored:r}),a.is_pgp_locked.bind(a)()&&await u.promisify(a.unlock_pgp.bind(a))({passphrase:e}),this.primaryIdentity=a}async exportPrivateKey(e){await this.fileSystem.promises.writeFile(e,this.primaryKeyPair.private),this.metadata.privateKeyPath=e,this.writeMetadata()}async exportPublicKey(e){await this.fileSystem.promises.writeFile(e,this.primaryKeyPair.public),this.metadata.publicKeyPath=e,this.writeMetadata()}generateKeySync(e,t){const r=o.default.randomBytes(32);return this.derivedKeys[e]=o.default.pbkdf2Sync(t,r,1e4,32,"sha256"),this.derivedKeys[e]}async generateKey(e,t){const r=o.default.randomBytes(32);return this.derivedKeys[e]=await u.promisify(o.default.pbkdf2)(t,r,1e4,32,"sha256"),this.derivedKeys[e]}importKeySync(e,t){this.derivedKeys[e]="string"==typeof t?this.fileSystem.readFileSync(t):t}async importKey(e,t){this.derivedKeys[e]="string"==typeof t?await this.fileSystem.promises.readFile(t):t}exportKeySync(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&this.fileSystem.mkdirSync(i.default.dirname(t),{recursive:!0}),this.fileSystem.writeFileSync(t,this.derivedKeys[e])}async exportKey(e,t,r){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);r&&await this.fileSystem.promises.mkdir(i.default.dirname(t),{recursive:!0}),await this.fileSystem.promises.writeFile(t,this.derivedKeys[e])}async getIdentityFromPublicKey(e){return await u.promisify(n.default.KeyManager.import_from_armored_pgp)({armored:e})}async getIdentityFromPrivateKey(e,t){const r=await u.promisify(n.default.KeyManager.import_from_armored_pgp)({armored:e});return r.is_pgp_locked()&&await u.promisify(r.unlock_pgp)({passphrase:t}),r}async signData(e,t,r){let a;if(t){if(!r)throw new Error("passphrase for private key was not provided");a=await this.getIdentityFromPrivateKey(t,r)}else{if(!this.primaryIdentity)throw new Error("no identity available for signing");a=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.signData(e,a))}{const t={msg:e.toString(),sign_with:a},r=await u.promisify(n.default.box)(t);return Buffer.from(r)}}async signFile(e,t,r){let a;t&&(a="string"==typeof t?Buffer.from(this.fileSystem.readFileSync(t)):t);const s=Buffer.from(this.fileSystem.readFileSync(e)),i=await this.signData(s,a,r),n=e+".sig";return this.fileSystem.writeFileSync(n,i),n}async verifyData(e,t,r){const a=new n.default.keyring.KeyRing;let s;if(r)s=await this.getIdentityFromPublicKey(r);else{if(!this.primaryIdentity)throw new Error("no identity available for verifying");s=this.primaryIdentity}if(a.add_key_manager(s),this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async r=>await r.verifyData(e,t,s))}{const r={armored:t,data:e,keyfetch:a};let s,i=(await u.promisify(n.default.unbox)(r))[0].get_data_signer();return i&&(s=i.get_key_manager()),!!s&&!!s.get_pgp_fingerprint()}}async verifyFile(e,t,r){let a;r&&(a="string"==typeof r?this.fileSystem.readFileSync(r):r);const s=this.fileSystem.readFileSync(e),i=this.fileSystem.readFileSync(t);return await this.verifyData(s,i,a)}async encryptData(e,t){let r;if(t)r=await this.getIdentityFromPublicKey(t);else{if(!this.primaryIdentity)throw new Error("Identity could not be resolved for encrypting");r=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.encryptData(e,r))}{const t={msg:e,encrypt_for:r};return await u.promisify(n.default.box)(t)}}async decryptData(e,t,r){var a=new n.default.keyring.KeyRing;let s;if(t){if(!r)throw new Error("A key passphrase must be supplied if a privateKey is specified");s=await this.getIdentityFromPrivateKey(t,r)}else{if(!this.primaryIdentity)throw Error("no identity available for signing");s=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.decryptData(e,s))}{a.add_key_manager(s);const t={armored:e.toString(),keyfetch:a},r=await u.promisify(n.default.unbox)(t);return Buffer.from(r[0].toString())}}getKey(e){return this.derivedKeys[e]}hasKey(e){return!!this.derivedKeys[e]}writeMetadata(){const e=JSON.stringify(this.metadata);this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.metadata=JSON.parse(e)}}}},function(e,t){e.exports=require("crypto")},function(e,t,r){"use strict";(function(e){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(0)),i=a(r(46)),n=a(r(6));t.default=class{static encodePeerInfo(e){var t;const r=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),a=[];for(const t of e.addresses)a.push(t.toString());const s={pubKey:e.publicKey,addresses:a,connectedAddr:null===(t=e.connectedAddr)||void 0===t?void 0:t.toString()},i=r.verify(s);if(i)throw Error(i);const n=r.create(s);return r.encode(n).finish()}static decodePeerInfo(e){const t=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),r=t.decode(e),a=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return new n.default(a.pubKey,a.addresses,a.connectedAddr)}static encodeHandshakeMessage(e,t,r,a){const s=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),i={targetPubKey:e,requestingPubKey:t,message:r,responsePeerInfo:a?this.encodePeerInfo(a):void 0},n=s.verify(i);if(n)throw Error(n);const o=s.create(i);return s.encode(o).finish()}static decodeHandshakeMessage(e){const t=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),r=t.decode(e),a=t.toObject(r,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return{targetPubKey:Buffer.from(a.targetPubKey,"base64"),requestingPubKey:Buffer.from(a.requestingPubKey,"base64"),message:Buffer.from(a.message,"base64"),responsePeerInfo:a.responsePeerInfo?this.decodePeerInfo(Buffer.from(a.responsePeerInfo,"base64")):void 0}}static loadProto(t){const r=new i.default.Root;return r.resolvePath=(t,r)=>s.default.join(s.default.dirname(e),r),r.loadSync(t)}}}).call(this,"/index.js")},function(e,t){e.exports=require("isomorphic-git")},function(e,t){e.exports=require("encryptedfs")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(10));t.default=class{constructor(e,t){this.address=e,this.getSocket=t}request({url:e,method:t,headers:r,body:a,onProgress:i}){return new Promise((i,n)=>{const{pathname:o,search:u}=new URL(e),l={path:o+u,headers:r,method:t,createConnection:()=>this.getSocket(this.address)},c=s.default.request(l,e=>{const t=this.httpMessageToIter(e);i({url:e.url,method:e.method,statusCode:e.statusCode,statusMessage:e.statusMessage,body:t,headers:e.headers})});if(a)for(const e of a)c.write(e);c.end()})}httpMessageToIter(e){let t=!1;const r=[];let a={};return e.on("data",e=>{r.push(e),a.resolve&&(a.resolve({value:r.shift(),done:!1}),a={})}),e.on("error",e=>{a.reject&&(a.reject(e),a={})}),e.on("end",()=>{t=!0,a.resolve&&(a.resolve({done:!0}),a={})}),{next:()=>new Promise((e,s)=>0===r.length&&t?e({done:!0}):r.length>0?e({value:r.shift(),done:!1}):void(0!==r.length||t||(a={resolve:e,reject:s})))}}}},function(e,t){e.exports=require("virtualfs")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(2)),i=a(r(9)),n=r(1);t.default=function(){return new s.default.Command("config").description("configure polykey").option("-pub, --public-key <publicKey>","provide the path to an existing public key").option("-priv, --private-key <privateKey>","provide the path to an existing private key").option("-pass, --private-passphrase <privatePassphrase>","provide the passphrase to the private key").option("-path, --polykey-path <polykeyPath>","provide the polykey path. defaults to ~/.polykey").option("-v, --verbose","increase verbosity by one level").action(n.actionRunner(async e=>{const t=new i.default("PolyKeyConfig");e.polykeyPath&&t.set("polykeyPath",e.polykeyPath),e.publicKeyPath&&t.set("publicKeyPath",e.publicKeyPath),e.privateKeyPath&&t.set("privateKeyPath",e.privateKeyPath),e.privatePassphrase&&t.set("privatePassphrase",e.privatePassphrase)})).addCommand(new s.default.Command("clear").description("clear the polykey config store").action(n.actionRunner(async e=>{new i.default("PolyKeyConfig").clear()}))).addCommand(new s.default.Command("list").description("list current polykey config parameters").alias("ls").action(n.actionRunner(async e=>{const t=new i.default("PolyKeyConfig");n.pkLogger("The current config parameters are:",n.PKMessageType.INFO),n.pkLogger("Polykey Path: "+t.get("polykeyPath"),n.PKMessageType.INFO),n.pkLogger("Public Key Path: "+t.get("publicKeyPath"),n.PKMessageType.INFO),n.pkLogger("Private Key Path: "+t.get("privateKeyPath"),n.PKMessageType.INFO),n.pkLogger("Private Key Passphrase: "+t.get("privatePassphrase"),n.PKMessageType.INFO)})))}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(4)),i=a(r(2)),n=a(r(5)),o=r(1);t.default=function(){return new i.default.Command("secrets").description("manipulate secrets for a given vault").addCommand(new i.default.Command("list").description("list all available secrets for a given vault").alias("ls").requiredOption("-n, --vault-name <vaultName>","the vault name").option("--verbose","increase verbosity level by one").action(o.actionRunner(async e=>{var t;const r=await n.default(),a=null!==(t=e.verbose)&&void 0!==t&&t,s=e.vaultName;try{if(!await r.vaultManager.vaultExists(s))throw new Error(`vault '${s}' does not exist!`);const e=(await r.vaultManager.getVault(s)).listSecrets();a&&o.pkLogger(`secrets contained within the ${s} vault:`,o.PKMessageType.INFO),0==e.length?o.pkLogger(`no secrets found for vault '${s}'`,o.PKMessageType.INFO):e.forEach(e=>{o.pkLogger(e,o.PKMessageType.INFO)})}catch(e){throw new Error("Error when listing secrets: "+e.message)}}))).addCommand(new i.default.Command("add").description("add a secret to a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").requiredOption("-p, --secret-path <secretPath>","path to the secret to be removed").option("--verbose","increase verbosity level by one").action(o.actionRunner(async e=>{const t=await n.default(),r=(e.verbose,e.vaultName),a=e.secretName,i=e.secretPath;try{if(!await t.vaultManager.vaultExists(r))throw new Error(`vault '${r}' does not exist!`);const e=await t.vaultManager.getVault(a);if(await e.secretExists(a))throw new Error(`secret '${a}' already exists in vault ${r}!`);const n=s.default.readFileSync(i);if(await e.addSecret(a,n),!await e.secretExists(a))throw new Error(`something went wrong, secret '${a}' was not added to vault '${r}'`);o.pkLogger(`secret '${a}' was sucessfully added to vault '${r}'`,o.PKMessageType.SUCCESS)}catch(e){throw new Error("Error when adding secret: "+e.message)}}))).addCommand(new i.default.Command("remove").description("remove a secret from a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").option("--verbose","increase verbosity level by one").action(o.actionRunner(async e=>{const t=await n.default(),r=(e.verbose,e.vaultName),a=e.secretName;try{if(!await t.vaultManager.vaultExists(r))throw new Error(`vault '${r}' does not exist!`);const e=await t.vaultManager.getVault(a);if(await e.removeSecret(a),await e.secretExists(a))throw new Error(`something went wrong, secret '${a}' was not removed from vault '${r}'`);o.pkLogger(`secret '${a}' was sucessfully removed from vault '${r}'`,o.PKMessageType.SUCCESS)}catch(e){throw new Error("Error when removing secret: "+e.message)}})))}},function(e,t){e.exports=require("zxcvbn")},function(e,t){e.exports=require("inquirer")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(3)),i=a(r(28)),n=a(r(16)),o=a(r(43)),u=a(r(53));t.default=class{constructor(e=s.default.homedir()+"/.polykey",t,r,a,l){this.polykeyPath=e,this.keyManager=null!=r?r:new n.default(this.polykeyPath,t),this.vaultManager=null!=a?a:new u.default(this.polykeyPath,t,this.keyManager),this.peerManager=null!=l?l:new o.default(this.polykeyPath,t,this.keyManager),this.gitServer=new i.default(this.polykeyPath,this.vaultManager),this.peerManager.connectLocalPeerInfo(this.gitServer.address)}}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(0)),i=a(r(10)),n=r(29),o=r(6),u=a(r(30)),l=a(r(32)),c=r(7),d=a(r(34)),f=["upload-pack","receive-pack"];t.default=class{constructor(e,t,r=0){this.polykeyPath=e,this.vaultManager=t,this.server=i.default.createServer((e,t)=>{this.handle(e,t)}).listen(r),this.address=o.Address.fromAddressInfo(this.server.address())}exists(e,t){const r=this.vaultManager.getVault(e);return!!r&&r.peerCanAccess(t)}handle(e,t){t.setHeader("connection","close"),"GET"==e.method?this.handleInfoRequest(e,t):"POST"==e.method?this.handlePackRequest(e,t):(t.statusCode=405,t.end("method not supported"))}notFoundResponse(e){e.statusCode=404,e.end("not found")}handleInfoRequest(e,t){var r,a;const s=null!==(a=null===(r=e.url)||void 0===r?void 0:r.split("?"))&&void 0!==a?a:[];if(2!=s.length)return this.notFoundResponse(t);const i=s[0],o=s[1],u=i.match(/\/(.+)\/info\/refs$/);if(!u||/\.\./.test(u[1]))return this.notFoundResponse(t);const l=u[1],c=n.parse(o);if(!c.service)return t.statusCode=400,void t.end("service parameter required");const d=c.service.replace(/^git-/,"");if(f.indexOf(d)<0)return t.statusCode=405,void t.end("service not available");this.infoResponse(l,d,t)}handlePackRequest(e,t){var r;const a=e.url.match(/\/(.+)\/git-(.+)/);if(!a||/\.\./.test(a[1]))return this.notFoundResponse(t);const i=a[1],n=a[2];if(f.indexOf(n)<0)return t.statusCode=405,void t.end("service not available");t.setHeader("content-type","application/x-git-"+n+"-result"),this.noCache(t);const o=s.default.join(this.polykeyPath,i);if(!this.exists(i,""))return t.statusCode=404,void t.end("not found");const u=null===(r=this.vaultManager.getVault(i))||void 0===r?void 0:r.EncryptedFS;u&&e.on("data",async e=>{if("want"==e.toString().slice(4,8)){const r=e.toString().slice(9,49),a=await d.default(u,o,[r],void 0);t.write(Buffer.from("0008NAK\n"));const s=new c.PassThrough,i=new c.PassThrough;l.default.mux("side-band-64",s,a.packstream,i,[]).pipe(t),i.write(Buffer.from("0014progress is at 50%\n")),i.end()}})}infoResponse(e,t,r){this.exists(e,"")?(r.setHeader("content-type","application/x-git-"+t+"-advertisement"),this.noCache(r),this.uploadPackRespond(e,t,r)):(r.statusCode=404,r.setHeader("content-type","text/plain"),r.end("repository not found"))}noCache(e){e.setHeader("expires","Fri, 01 Jan 1980 00:00:00 GMT"),e.setHeader("pragma","no-cache"),e.setHeader("cache-control","no-cache, max-age=0, must-revalidate")}createGitPacketLine(e){const t=(4+e.length).toString(16);return Array(4-t.length+1).join("0")+t+e}async uploadPackRespond(e,t,r){var a;r.write(this.createGitPacketLine("# service=git-"+t+"\n")),r.write("0000");const i=null===(a=this.vaultManager.getVault(e))||void 0===a?void 0:a.EncryptedFS,n=await u.default(i,s.default.join(this.polykeyPath,e),void 0,!0),o=null!=n?n:[];c.Readable.from(o).pipe(r)}}},function(e,t){e.exports=require("querystring")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(0)),i=a(r(11)),n=a(r(12));t.default=async function(e,t,r=s.default.join(t,".git"),a=!1){try{if(a){const t=["side-band-64k"];let a=await n.default.listRefs(e,r,"refs");a=a.map(e=>"refs/"+e);const s={};a.unshift("HEAD");for(const t of a)s[t]=await n.default.resolve(e,r,t);const o={};return o.HEAD=await n.default.resolve(e,r,"HEAD",2),async function({capabilities:e,refs:t,symrefs:r}){const a=[];let s="";for(const[e,t]of Object.entries(r))s+=`symref=${e}:${t} `;let n=`\0${[...e].join(" ")} ${s}agent=git/isomorphic-git@1.4.0`;for(const[e,r]of Object.entries(t))a.push(i.default.encode(`${r} ${e}${n}\n`)),n="";return a.push(i.default.flush()),a}({capabilities:t,refs:s,symrefs:o})}}catch(e){throw e.caller="git.uploadPack",e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class a{constructor(e){if(this.refs=new Map,this.parsedConfig=[],e){let t;this.parsedConfig=e.trim().split("\n").map(e=>{if(/^\s*#/.test(e))return{line:e,comment:!0};const r=e.indexOf(" ");if(e.startsWith("^")){const r=e.slice(1);return this.refs.set(t+"^{}",r),{line:e,ref:t,peeled:r}}{const a=e.slice(0,r);return t=e.slice(r+1),this.refs.set(t,a),{line:e,ref:t,oid:a}}})}return this}static from(e){return new a(e)}}t.default=a},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(33),i=r(7),n=a(r(11));function o(e,t){const r=[];let a=0;for(;a<e.length;){const s=e.slice(a,a+t);r.push(s),a+=s.length}return r.push(e.slice(a)),r}t.default=class{static demux(e){let t=n.default.streamReader(e),r=new i.PassThrough,a=new i.PassThrough,s=new i.PassThrough;const o=async function(){let e=await t();if(null===e)return o();if(!0===e)return r.end(),s.end(),void a.end();switch(e[0]){case 1:a.write(e.slice(1));break;case 2:s.write(e.slice(1));break;case 3:let t=e.slice(1);return s.write(t),void a.destroy(new Error(t.toString("utf8")));default:r.write(e.slice(0))}o()};return o(),{packetlines:r,packfile:a,progress:s}}static mux(e,t,r,a,u){const l="side-band-64k"===e?999:65519;let c=new i.PassThrough;t.on("data",e=>{null===e?c.write(n.default.flush()):c.write(n.default.encode(e))});let d=!0,f=!1,h=!1,p=s.Buffer.concat([n.default.encode(s.Buffer.from("010A","hex")),n.default.flush()]);return r.on("data",e=>{d=!1;const t=o(e,l);for(const e of t)c.write(n.default.encode(s.Buffer.concat([s.Buffer.from("01","hex"),e])))}).on("end",()=>{f=!0,d||c.write(p),h&&c.end()}),a.on("data",e=>{const t=o(e,l);for(const e of t)c.write(n.default.encode(s.Buffer.concat([s.Buffer.from("02","hex"),e])))}).on("end",()=>{h=!0,f&&c.end()}),c}}},function(e,t){e.exports=require("buffer")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(13)),i=a(r(0)),n=a(r(35)),o=a(r(39)),u=a(r(40)),l=a(r(14)),c=r(7),d=a(r(15)),f={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function h(e,t,r=i.default.join(t,".git"),a){let s=new Set,n=new Set,u=new Set;async function c(t){let{type:a,object:i}=await d.default.read(e,r,t);if("commit"===a){s.add(t);let e=l.default.from(i).headers().tree;await c(e)}else if("tree"===a){n.add(t);let e=o.default.from(i);for(let t of e)"blob"===t.type&&u.add(t.oid),"tree"===t.type&&await c(t.oid)}}for(let e of a)await c(e);return[...s,...n,...u]}async function p(e,t,r=i.default.join(t,".git"),a,n){let o=u.default("sha1");function l(e,t){t?n.write(e,t):n.write(e),o.update(e,t)}function c(e,t){let r,a,i,n=f[t];if(void 0===n)throw new Error("Unrecognized type: "+t);i=e.length,a=i>15?128:0,r=15&i,i>>>=4;let o=(a|n|r).toString(16);for(l(o,"hex");a;){a=i>127?128:0,o=a|127&i;const e=o.toString(16);l("0".repeat(2-e.length)+e,"hex"),i>>>=7}l(Buffer.from(s.default.deflate(e)))}l("PACK"),l("00000002","hex");const h=a.length.toString(16);l("0".repeat(8-h.length)+h,"hex");for(let t of a){let{type:a,object:s}=await d.default.read(e,r,t);c(s,a)}let p=o.digest();return n.end(p),n}t.listObjects=h,t.pack=p,t.default=async function(e,t,r,a,s){const o=i.default.join(t,".git");let u=new Set,l=new Set,d=new Set,f=[];s=s||[];for(const i of r)try{let r=await n.default(e,t,o,void 0,i,a,void 0),c=[];for(let e=0;e<r.length;e++){let t=r[e];if(s.includes(t.oid)){f.push({oid:i});break}u.add(t.oid),e===r.length-1?c.includes(t.oid)||void 0===a||(console.log("make it shallow",t.oid),l.add(t.oid)):c.includes(t.oid)&&(console.log("make it unshallow",t.oid),d.add(t.oid))}}catch(e){console.log(e)}let y=await h(e,t,o,Array.from(u)),m=new c.PassThrough;return p(e,t,void 0,[...y],m),{packstream:m,shallows:l,unshallows:d,acks:f}}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(0),i=a(r(14)),n=a(r(15)),o=a(r(12));async function u(e,t,r,a){try{let{type:s,object:o}=await n.default.read(e,t,r);if("commit"!==s)throw new Error("expected type to be commit");const u=i.default.from(o),l=Object.assign({oid:r},u.parse());return a&&(l.payload=u.withoutSignature()),l}catch(e){return{oid:r,error:e}}}function l(e,t){return e.committer.timestamp-t.committer.timestamp}t.logCommit=u,t.default=async function(e,t,r=s.join(t,".git"),a="HEAD",i,n,c=!1){try{let t=void 0===n?void 0:Math.floor(n.valueOf()/1e3),s=[],d=await o.default.resolve(e,r,a),f=[await u(e,r,d,c)];for(;;){let a=f.pop();if(a.error){s.push(a);break}if(void 0!==t&&a.committer.timestamp<=t)break;if(s.push(a),void 0!==i&&s.length===i)break;for(const t of a.parent){let a=await u(e,r,t,c);f.map(e=>e.oid).includes(a.oid)||f.push(a)}if(0===f.length)break;f.sort(l)}return s}catch(e){throw e.caller="git.log",e}}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(37));t.default=class{static hash({type:e,object:t}){let r=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),Buffer.from(t)]);return s.default(r)}static wrap({type:e,object:t}){let r=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),t]);return{oid:s.default(r),buffer:r}}static unwrap({oid:e,buffer:t}){if(e){let r=s.default(t);if(r!==e)throw new Error(`SHA check failed! Expected ${e}, computed ${r}`)}let r=t.indexOf(32),a=t.indexOf(0),i=t.slice(0,r).toString("utf8"),n=t.slice(r+1,a).toString("utf8"),o=t.length-(a+1);if(parseInt(n)!==o)throw new Error(`Length mismatch: expected ${n} bytes but got ${o} instead.`);return{type:i,object:Buffer.from(t.slice(a+1))}}}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(38));t.default=function(e){return(new s.default).update(e).digest("hex")}},function(e,t){e.exports=require("sha.js/sha1")},function(e,t,r){"use strict";function a(e){return!e.oid&&e.sha&&(e.oid=e.sha),e.mode=function(e){if("number"==typeof e&&(e=e.toString(8)),e.match(/^0?4.*/))return"40000";if(e.match(/^1006.*/))return"100644";if(e.match(/^1007.*/))return"100755";if(e.match(/^120.*/))return"120000";if(e.match(/^160.*/))return"160000";throw new Error("Could not understand file mode: "+e)}(e.mode),e.type||(e.type="blob"),e}Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){if(Buffer.isBuffer(e))this._entries=function(e){let t=[],r=0;for(;r<e.length;){let a=e.indexOf(32,r);if(-1===a)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);let s=e.indexOf(0,r);if(-1===s)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let i=e.slice(r,a).toString("utf8");"40000"===i&&(i="040000");let n="040000"===i?"tree":"blob",o=e.slice(a+1,s).toString("utf8"),u=e.slice(s+1,s+21).toString("hex");r=s+21,t.push({mode:i,path:o,oid:u,type:n})}return t}(e);else{if(!Array.isArray(e))throw new Error("invalid type passed to GitTree constructor");this._entries=e.map(a)}}static from(e){return new s(e)}render(){return this._entries.map(e=>`${e.mode} ${e.type} ${e.oid}    ${e.path}`).join("\n")}toObject(){return Buffer.concat(this._entries.map(e=>{let t=Buffer.from(e.mode.replace(/^0/,"")),r=Buffer.from(" "),a=Buffer.from(e.path),s=Buffer.from([0]),i=Buffer.from(e.oid.match(/../g).map(e=>parseInt(e,16)));return Buffer.concat([t,r,a,s,i])}))}entries(){return this._entries}*[Symbol.iterator](){for(let e of this._entries)yield e}}t.default=s},function(e,t){e.exports=require("sha.js")},function(e,t){e.exports=require("kbpgp")},function(e,t){e.exports=require("util")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(3)),i=a(r(44)),n=a(r(45)),o=a(r(0)),u=a(r(18)),l=r(47),c=a(r(6)),d=a(r(48)),f=a(r(51)),h={name:"Keybase",findUser:async(e,t)=>{const r=`https://keybase.io/_/api/1.0/user/lookup.json?${t}=${e}`;try{const e=await fetch(r);return(await e.json()).them[0].public_keys.primary.bundle}catch(e){throw new Error("User was not found: "+e.message)}}};t.default=class{constructor(e=s.default.homedir()+"/.polykey",t,r,a,i=[]){this.metadata={localPeerInfo:null},this.fileSystem=t,this.fileSystem.mkdirSync(e,{recursive:!0}),this.metadataPath=o.default.join(e,".peerMetadata"),this.keyManager=r,this.socialDiscoveryServices=i,this.loadMetadata(),a?(this.localPeerInfo=a,this.writeMetadata()):this.metadata.localPeerInfo?this.localPeerInfo=this.metadata.localPeerInfo:this.keyManager.hasPublicKey()&&(this.localPeerInfo=new c.default(this.keyManager.getPublicKey())),this.peerStore=new Map,this.socialDiscoveryServices=[],this.socialDiscoveryServices.push(h);for(const e of i)this.socialDiscoveryServices.push(e);this.multicastBroadcaster=new d.default(this.addPeer,this.localPeerInfo,this.keyManager);const{keyPem:u,certPem:l}=f.default.createX509Certificate();this.keyPem=u,this.certPem=l;const p={key:u,cert:l,requestCert:!0,rejectUnauthorized:!1};this.server=n.default.createServer(p,e=>{console.log("server connected",e.authorized?"authorized":"unauthorized")}).listen()}getLocalPeerInfo(){return this.localPeerInfo}connectLocalPeerInfo(e){this.localPeerInfo.connect(e)}addPeer(e){this.peerStore.set(e.publicKey,e)}getPeer(e){var t;return null!==(t=this.peerStore.get(e))&&void 0!==t?t:null}hasPeer(e){return this.peerStore.has(e)}async findPubKey(e){return new Promise((t,r)=>{this.multicastBroadcaster.requestPeerContact(e),this.multicastBroadcaster.on("found",r=>{r.publicKey==e&&t(r)}),this.multicastBroadcaster.on("timeout",t=>{t==e&&r("The broadcaster stopped looking")})})}async findSocialUser(e,t){const r=[];for(const a of this.socialDiscoveryServices)try{r.push(a.findUser(e,t))}catch(e){console.log("Could not find user on this discovery service: "+a.name)}const a=await l.firstPromiseFulfilled(r);if(a.length>1)throw new Error("Could not find public key from services");const s=a[0];return await this.findPubKey(s)}connectToPeer(e){var t;if("string"!=typeof e){const t=e,r={port:parseInt(t.port),host:t.ip};return i.default.connect(r)}{const r=this.peerConnections.get(e);if(r)return r;{const r=null===(t=this.getPeer(e))||void 0===t?void 0:t.connectedAddr;if(r){const e={port:parseInt(r.port),host:r.ip};return i.default.connect(e)}}}throw new Error("Peer does not have an address connected")}writeMetadata(){const e=JSON.stringify(u.default.encodePeerInfo(this.localPeerInfo));this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.localPeerInfo=u.default.decodePeerInfo(Buffer.from(e))}}}},function(e,t){e.exports=require("net")},function(e,t){e.exports=require("tls")},function(e,t){e.exports=require("protobufjs")},function(e,t,r){"use strict";function a(e){return new Promise((t,r)=>e.then(r,t))}Object.defineProperty(t,"__esModule",{value:!0}),t.randomString=function(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)},t.firstPromiseFulfilled=function(e){return a(Promise.all(e.map(a)))}},function(e,t,r){"use strict";var a,s,i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=i(r(49)),o=i(r(17)),u=r(50),l=i(r(18)),c=parseInt(null!==(a=process.env.UDP_MULTICAST_PORT)&&void 0!==a?a:"5353"),d=null!==(s=process.env.UDP_MULTICAST_ADDR)&&void 0!==s?s:"224.0.0.251";class f extends u.EventEmitter{constructor(e,t,r){super(),this.peerPubKeyMessages=new Map,this.addPeer=e,this.localPeerInfo=t,this.keyManager=r,this.interval=1e3,this.queryInterval=null,this.socket=n.default.createSocket({type:"udp4",reuseAddr:!0}),this.socket.bind(c),this.socket.on("listening",(()=>{this.socket.addMembership(d);this.socket.address()}).bind(this)),this.socket.on("message",this.handleHandshakeMessages.bind(this)),this.queryInterval=this.queryLAN()}async requestPeerContact(e){const t=Buffer.from(e),r=o.default.randomBytes(16),a=await this.keyManager.encryptData(t,t),s=await this.keyManager.encryptData(r,t),i=await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()),t);this.peerPubKeyMessages.set(e,{encryptedLocalPubKey:Buffer.from(i),encryptedPeerPubKey:Buffer.from(a),rawRandomMessage:r,encryptedRandomMessage:Buffer.from(s)})}queryLAN(){const e=()=>{for(const e of this.peerPubKeyMessages.keys()){const t=this.peerPubKeyMessages.get(e);if(t){const e=l.default.encodeHandshakeMessage(t.encryptedPeerPubKey,t.encryptedLocalPubKey,t.encryptedRandomMessage);this.socket.send(e,0,e.length,c,d,()=>{console.info("Sending message to peer")})}}};return e(),setInterval(e,this.interval)}async handleHandshakeMessages(e,t){var r;try{const a=l.default.decodeHandshakeMessage(e);console.info(`Message from: ${t.address}:${t.port}`);const s=await this.keyManager.decryptData(a.message),i=await this.keyManager.decryptData(a.targetPubKey),n=await this.keyManager.decryptData(a.requestingPubKey),o=this.keyManager.getPublicKey();if(n.toString()==o){const e=null===(r=this.peerPubKeyMessages.get(i.toString()))||void 0===r?void 0:r.rawRandomMessage;if(s.toString()==(null==e?void 0:e.toString())){const e=a.responsePeerInfo;if(e){this.addPeer(e);const t=e.publicKey;this.peerPubKeyMessages.delete(t),console.log("New peer added to the store"),this.emit("found",e)}else this.emit("error","I got a validated response. But no peerInfo")}}else{const e=await this.keyManager.encryptData(Buffer.from(o),n),t=await this.keyManager.encryptData(s,n),r=await this.keyManager.encryptData(n,n),a=l.default.encodeHandshakeMessage(Buffer.from(e),Buffer.from(r),Buffer.from(t),this.localPeerInfo);this.socket.send(a,0,a.length,c,d)}}catch(e){}}}t.default=f},function(e,t){e.exports=require("dgram")},function(e,t){e.exports=require("events")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(52));class i{static createX509Certificate(e=this.N_BITS,t=this.COMMON_NAME,r=this.ORGANIZATION_NAME){const a=s.default.pki,i=a.rsa.generateKeyPair(e),n=a.createCertificate();n.publicKey=i.publicKey,n.serialNumber="01",n.validity.notBefore=new Date,n.validity.notAfter=new Date,n.validity.notAfter.setFullYear(n.validity.notBefore.getFullYear()+1);const o=[{name:"commonName",value:t},{name:"organizationName",value:r}];return n.setSubject(o),n.setIssuer(o),n.setExtensions([{name:"basicConstraints",cA:!0},{name:"keyUsage",keyCertSign:!0,digitalSignature:!0,nonRepudiation:!0,keyEncipherment:!0,dataEncipherment:!0},{name:"extKeyUsage",serverAuth:!0,clientAuth:!0,codeSigning:!0,emailProtection:!0,timeStamping:!0},{name:"nsCertType",client:!0,server:!0,email:!0,objsign:!0,sslCA:!0,emailCA:!0,objCA:!0},{name:"subjectAltName",altNames:{type:7,ip:"127.0.0.1"}},{name:"subjectKeyIdentifier"}]),n.sign(i.privateKey),{keyPem:a.privateKeyToPem(i.privateKey),certPem:a.certificateToPem(n)}}}i.N_BITS=2048,i.COMMON_NAME="polykey",i.ORGANIZATION_NAME="MatrixAI",t.default=i},function(e,t){e.exports=require("node-forge")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(3)),i=a(r(0)),n=a(r(19)),o=r(20),u=a(r(54)),l=a(r(21));t.default=class{constructor(e=s.default.homedir()+"/.polykey",t,r){this.polykeyPath=e,this.fileSystem=t,this.keyManager=r,this.metadataPath=i.default.join(e,".vaultKeys"),this.fileSystem.mkdirSync(this.polykeyPath,{recursive:!0}),this.vaults=new Map,this.vaultKeys=new Map,this.loadMetadata();for(const[e,t]of this.vaultKeys.entries()){const r=i.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(r)){const r=new u.default(e,t,this.polykeyPath);this.vaults.set(e,r)}}}getVault(e){if(this.vaults.has(e)){return this.vaults.get(e)}if(this.vaultKeys.has(e)){this.validateVault(e);const t=this.vaultKeys.get(e),r=new u.default(e,t,this.polykeyPath);return this.vaults.set(e,r),r}throw new Error("Vault does not exist in memory")}async createVault(e,t){if(this.vaultExists(e))throw Error("Vault already exists!");try{const r=i.default.join(this.polykeyPath,e);let a;this.fileSystem.mkdirSync(r,{recursive:!0}),a=t||await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),this.vaultKeys.set(e,a),this.writeMetadata();const s=new u.default(e,a,this.polykeyPath);return await s.initRepository(),this.vaults.set(e,s),this.getVault(e)}catch(t){throw this.destroyVault(e),t}}async cloneVault(e,t,a){if(this.vaultExists(e))throw new Error("Vault name already exists locally, try pulling instead");const s=`http://${t.toString()}/${e}`,c=new l.default(t,a);if(!(await n.default.getRemoteInfo({http:c,url:s})).refs)throw new Error(`Peer does not have vault: '${e}'`);const d=await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),f=new(r(22).VirtualFS),h=new o.EncryptedFS(d,f,f,this.fileSystem,process);await n.default.clone({fs:{promises:h.promises},http:c,dir:i.default.join(this.polykeyPath,e),url:s,ref:"master",singleBranch:!0});const p=new u.default(e,d,this.polykeyPath);return this.vaults.set(e,p),p}vaultExists(e){const t=i.default.join(this.polykeyPath,e);return this.fileSystem.existsSync(t)}destroyVault(e){const t=i.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(t)&&this.fileSystem.rmdirSync(t,{recursive:!0}),this.vaults.delete(e),this.vaultKeys.delete(e),this.writeMetadata(),this.fileSystem.existsSync(t))throw new Error("Vault folder could not be destroyed!")}listVaults(){return Array.from(this.vaults.keys())}validateVault(e){if(!this.vaults.has(e))throw Error("Vault does not exist in memory");if(!this.vaultKeys.has(e))throw Error("Vault key does not exist in memory");const t=i.default.join(this.polykeyPath,e);if(!this.fileSystem.existsSync(t))throw Error("Vault directory does not exist")}async writeMetadata(){const e=JSON.stringify([...this.vaultKeys]),t=await this.keyManager.encryptData(Buffer.from(e));await this.fileSystem.promises.writeFile(this.metadataPath,t)}async loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath),t=(await this.keyManager.decryptData(e)).toString();for(const[e,r]of new Map(JSON.parse(t)))this.vaultKeys[e]=Buffer.from(r)}}}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(4)),i=a(r(0)),n=a(r(19)),o=r(20),u=a(r(21));t.default=class{constructor(e,t,a){this.key=t,this.keyLen=t.length;const n=new(r(22).VirtualFS);this.efs=new o.EncryptedFS(this.key,n,n,s.default,process),this.name=e,this.vaultPath=i.default.join(a,e),this.efs.mkdirSync(this.vaultPath,{recursive:!0}),this.secrets=new Map,this.loadSecrets(),this.metadataPath=i.default.join(this.vaultPath,".vault","metadata"),this.loadMetadata()}get EncryptedFS(){return this.efs}secretExists(e){const t=i.default.join(this.vaultPath,e);return this.secrets.has(e)&&this.efs.existsSync(t)}async addSecret(e,t){if(this.secrets.has(e))throw new Error("Secret already exists, try updating it instead.");const r=i.default.join(this.vaultPath,e);await this.efs.promises.writeFile(r,t,{}),this.secrets.set(e,t),await this.commitChanges("Add secret: "+e,e,"added")}async updateSecret(e,t){if(!this.secrets.has(e))throw new Error("Secret does not exist, try adding it instead.");const r=i.default.join(this.vaultPath,e);await this.efs.promises.writeFile(r,t,{}),this.secrets.set(e,t),await this.commitChanges("Update secret: "+e,e,"modified")}getSecret(e){if(this.secrets.has(e)){const t=this.secrets.get(e);if(t)return t;{const t=i.default.join(this.vaultPath,e),r=this.efs.readFileSync(t,{});return this.secrets.set(e,r),r}}throw Error("Secret: "+e+" does not exist")}async removeSecret(e){if(this.secrets.has(e)){const t=this.secrets.delete(e);if(await this.efs.promises.unlink(i.default.join(this.vaultPath,e)),await this.commitChanges("Remove secret: "+e,e,"removed"),t)return;throw Error("Secret: "+e+" was not removed")}throw Error("Secret: "+e+" does not exist")}listSecrets(){return Array.from(this.secrets.keys())}tagVault(){}untagVault(){}shareVault(e){if(this.sharedPubKeys.has(name))throw new Error("Vault is already shared with given public key");this.sharedPubKeys.add(e),this.writeMetadata()}unshareVault(e){if(!this.sharedPubKeys.has(e))throw new Error("Vault is not shared with given public key");this.sharedPubKeys.delete(e),this.writeMetadata()}peerCanAccess(e){return!0}async pullVault(e,t){const r="http://"+e.toString()+"/"+this.name;await n.default.currentBranch({fs:{promises:this.efs.promises},dir:this.vaultPath,fullname:!0});const a=new u.default(e,t);await n.default.pull({fs:{promises:this.efs.promises},http:a,dir:this.vaultPath,url:r,ref:"HEAD",singleBranch:!0,author:{name:this.name}}),this.loadSecrets()}async initRepository(){const e=this.efs;await n.default.init({fs:e,dir:this.vaultPath}),await n.default.commit({fs:e,dir:this.vaultPath,author:{name:this.name},message:"init commit"}),this.efs.writeFileSync(i.default.join(this.vaultPath,".git","packed-refs"),"# pack-refs with: peeled fully-peeled sorted")}writeMetadata(){this.efs.mkdirSync(i.default.dirname(this.metadataPath),{recursive:!0});const e={sharedPubKeys:Array.from(this.sharedPubKeys.keys())};this.efs.writeFileSync(this.metadataPath,JSON.stringify(e))}loadMetadata(){if(this.efs.existsSync(this.metadataPath)){const e=this.efs.readFileSync(this.metadataPath).toString(),t=JSON.parse(e);this.sharedPubKeys=new Set(t.sharedPubKeys)}else this.sharedPubKeys=new Set,this.writeMetadata()}async commitChanges(e,t,r){return"removed"==r?await n.default.remove({fs:this.efs,dir:this.vaultPath,filepath:t}):await n.default.add({fs:this.efs,dir:this.vaultPath,filepath:t}),await n.default.commit({fs:this.efs,dir:this.vaultPath,author:{name:this.name},message:e})}loadSecrets(){const e=s.default.readdirSync(this.vaultPath,void 0);for(const t of e.filter(e=>"."!=e[0]))this.secrets.set(t,null)}}},function(e,t){e.exports=require("cli-progress")},function(e,t){e.exports=require("inquirer-fuzzy-path")},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(2)),i=a(r(5)),n=r(1);t.default=function(){return new s.default.Command("keymanager").alias("km").description("manipulate the keymanager").addCommand(new s.default.Command("derive").description("manipulate the keymanager").requiredOption("-n, --key-name <keyName>","the name of the new key").requiredOption("-p, --key-passphrase <keyPassphrase>","the passphrase for the new key").action(n.actionRunner(async e=>{const t=e.keyName,r=e.keyPassphrase;(await i.default()).keyManager.generateKeySync(r,t),n.pkLogger(`'${t}' was added to the Key Manager`,n.PKMessageType.SUCCESS)})))}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(2)),i=r(1);t.default=function(){return new s.default.Command("node").description("control the current polykey node").addCommand(new s.default.Command("start").description("start the polykey node").action(i.actionRunner(async e=>{}))).addCommand(new s.default.Command("stop").description("stop the polykey node").action(i.actionRunner(async e=>{})))}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(2)),i=a(r(5)),n=r(1);t.default=function(){return new s.default.Command("crypto").description("crypto operations").addCommand(new s.default.Command("verify").description("verification operations").option("-k, --verifying-key <verifyingKey>","path to public key that will be used to verify files").option("-s, --detach-sig <detachedSignature>","path to detached signature for file").arguments("file to be verified").action(n.actionRunner(async e=>{const t=await i.default(),r=e.verifyingKey,a=e.detachedSignature,s=Array.from(e.args.values());if(s.length<1)throw new Error("no file provided");const o=s[0];if(void 0===a)throw new Error("no signature provided");try{const e=await t.keyManager.verifyFile(o,a,r);n.pkLogger(`file '${o}' successfully verified. PGP fingerprint: ${e}`,n.PKMessageType.SUCCESS)}catch(e){throw new Error(`failed to sign '${o}': ${e.message}`)}}))).addCommand(new s.default.Command("sign").description("signing operations").option("-k, --signing-key <signingKey>","path to private key that will be used to sign files").option("-p, --key-passphrase <keyPassphrase>","passphrase to unlock the provided signing key").arguments("file(s) to be signed").action(async e=>{const t=await i.default(),r=e.signingKey,a=e.keyPassphrase,s=e.args.values();for(const e of s)try{const s=await t.keyManager.signFile(e,r,a);n.pkLogger(`file '${e}' successfully signed at '${s}'`,n.PKMessageType.SUCCESS)}catch(t){throw new Error(`failed to sign '${e}': ${t}`)}}))}},function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=a(r(8)),i=a(r(2)),n=a(r(5)),o=r(1);t.default=function(){return new i.default.Command("vaults").description("manipulate vaults").addCommand(new i.default.Command("list").description("list all available vaults").alias("ls").option("-v, --verbose","increase verbosity level by one").action(o.actionRunner(async e=>{const t=await n.default();e.verbose&&o.pkLogger("vaults contained within polykey:",o.PKMessageType.INFO);const r=t.vaultManager.listVaults();void 0===r||0==r.length?o.pkLogger("no vaults found",o.PKMessageType.INFO):r.forEach(e=>{o.pkLogger(e,o.PKMessageType.INFO)})}))).addCommand(new i.default.Command("add").description("create new vault(s)").arguments("vault name(s)").action(o.actionRunner(async e=>{const t=await n.default(),r=e.args.values();for(const e of r)await t.vaultManager.createVault(e),o.pkLogger(`vault created at ${t.polykeyPath}/${e}`,o.PKMessageType.SUCCESS)}))).addCommand(new i.default.Command("remove").description("destroy an existing vault").option("-n, --vault-name <vaultName>","name of vault").option("-a, --all","remove all vaults").option("-v, --verbose","increase verbosity by one level").action(o.actionRunner(async e=>{var t,r;const a=await n.default(),i=null!==(t=e.verbose)&&void 0!==t&&t;if(null!==(r=e.all)&&void 0!==r&&r){const e=a.vaultManager.listVaults();if(void 0===e||0==e.length)o.pkLogger("no vaults found",o.PKMessageType.INFO);else{for(const t of e)await a.vaultManager.destroyVault(t),i&&o.pkLogger("destroyed "+t,o.PKMessageType.SUCCESS);o.pkLogger("all vaults destroyed successfully",o.PKMessageType.SUCCESS)}return}const u=e.vaultName;if(!u)throw new Error(s.default.red("error: did not receive vault name"));if(!await a.vaultManager.vaultExists(u))throw new Error(`vault '${u}' does not exist`);await a.vaultManager.destroyVault(u),o.pkLogger(`vault '${u}' destroyed ${await a.vaultManager.vaultExists(u)?"un-":""}successfully`,o.PKMessageType.SUCCESS)})))}},function(e){e.exports=JSON.parse('{"name":"polykey","bin":{"polykey":"bin/polykey","pk":"bin/polykey"},"version":"0.0.1","author":"Roger Qiu","description":"Polykey Core Library","keywords":["secrets"],"contributors":["Aaashwin Varshney","Robert Cronin"],"license":"Apache-2.0","repository":{"type":"git","url":"https://github.com/MatrixAI/js-polykey.git"},"main":"dist/index.js","types":"dist/index.d.ts","module":"dist/index.js","scripts":{"develop":"webpack --mode=development --watch & webpack-dev-server --mode=development & wait","build":"tsc; typedoc; webpack --mode=\'production\'","test":"jest","build:documentation":"typedoc"},"jest":{"verbose":true},"engines":{"node":">=12.14.0"},"dependencies":{"@grpc/grpc-js":"^1.0.5","@grpc/proto-loader":"^0.5.4","@types/commander":"^2.12.2","@types/configstore":"^4.0.0","@types/inquirer":"^6.5.0","chalk":"^4.0.0","cli-progress":"^3.8.2","commander":"^5.1.0","configstore":"^5.0.1","crc":"^3.8.0","encryptedfs":"^1.0.0","futoin-hkdf":"^1.3.2","inquirer":"^7.1.0","inquirer-fuzzy-path":"^2.3.0","isomorphic-git":"^1.5.0","jsonfile":"^6.0.1","kbpgp":"^2.0.82","node-forge":"^0.9.1","readable-stream":"^3.6.0","threads":"^1.6.0","virtualfs":"^2.2.0","zxcvbn":"^4.4.2"},"devDependencies":{"@types/cli-progress":"^3.7.0","@types/jest":"^25.0.0","@types/node":"^13.13.1","@types/node-forge":"^0.9.4","copy-webpack-plugin":"^6.0.2","documentation":"^8.1.2","file-loader":"^6.0.0","jest":"^25.0.0","threads-plugin":"^1.3.1","ts-jest":"^25.0.0","ts-loader":"^6.2.2","ts-node":"^8.8.2","tsconfig-paths":"^3.9.0","tsconfig-paths-webpack-plugin":"^3.2.0","typedoc":"^0.17.8","typedoc-webpack-plugin":"^1.1.4","typescript":"^3.8.3","webpack":"^4.42.1","webpack-cli":"^3.3.11","webpack-node-externals":"^1.7.2"},"bugs":{"url":"https://github.com/MatrixAI/js-polykey/issues"},"homepage":"https://github.com/MatrixAI/js-polykey#readme"}')}])}));