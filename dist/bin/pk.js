!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.pk=t():e.pk=t()}(this,(function(){return function(e){var t={};function a(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,a),s.l=!0,s.exports}return a.m=e,a.c=t,a.d=function(e,t,r){a.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(e,t){if(1&t&&(e=a(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(a.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)a.d(r,s,function(t){return e[t]}.bind(null,s));return r},a.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(t,"a",t),t},a.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},a.p="",a(a.s=0)}([function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(6)),i=a(1),o=r(a(12)),n=r(a(13)),u=r(a(34)),d=r(a(35)),l=r(a(36)),c=r(a(37));function p(e){console.error(s.default.red(e.message))}var y;t.actionRunner=function(e){return(...t)=>e(...t).catch(p)},function(e){e[e.SUCCESS=0]="SUCCESS",e[e.INFO=1]="INFO",e[e.WARNING=2]="WARNING"}(y||(y={})),t.PKMessageType=y,t.pkLogger=function(e,t){switch(t){case y.SUCCESS:console.log(s.default.green(e));break;case y.INFO:console.log(s.default.blue(e));break;case y.WARNING:console.log(s.default.yellow(e));break;default:console.log(e)}};const f=new i.program.Command;f.version(a(38).version,"--version","output the current version").addCommand(o.default()).addCommand(u.default()).addCommand(d.default()).addCommand(n.default()).addCommand(c.default()).addCommand(l.default()),e.exports=function(e){f.parse(e)}},function(e,t){e.exports=require("commander")},function(e,t){e.exports=require("fs")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(2)),i=r(a(8)),o=r(a(14)),n=r(a(15)),u=r(a(7)),d=r(a(16)),l=r(a(32)),c=r(a(9)),p=a(0),y=new u.default("PolyKeyConfig");async function f(e){await new Promise((t,a)=>{n.default.prompt(e).then(a=>{for(const t of e)a[t.name]&&y.set(t.name,a[t.name]);t()}).catch(e=>{e.isTtyError,a(e)})})}t.default=async function(){return new Promise(p.actionRunner(async(e,t)=>{await async function(){const e=[];n.default.registerPrompt("fuzzypath",a(33)),y.has("polykeyPath")||e.push({type:"fuzzypath",name:"polykeyPath",message:"Where would you like to store PolyKey?",default:i.default.homedir()+"/.polykey",rootPath:i.default.homedir(),itemType:"directory",suggestOnly:!0,depthLimit:1}),y.has("generateKeyPair")||e.push({type:"confirm",name:"generateKeyPair",message:"Would you like to generate a public/private keypair?",default:!0}),e.length>0&&await f(e);const t=[];y.get("generateKeyPair")?(y.has("keyGenerationName")||t.push({type:"input",name:"keyGenerationName",message:"Please provide your full name for key generation?"}),y.has("keyGenerationEmail")||t.push({type:"input",name:"keyGenerationEmail",message:"Please provide an email for key generation?"}),y.has("keyGenerationPassphrase")||t.push({type:"input",name:"keyGenerationPassphrase",message:"Please provide a secure passphrase for key generation?"})):(y.has("publicKeyPath")||t.push({type:"fuzzypath",name:"publicKeyPath",message:"Please provide the path to your public key?",rootPath:i.default.homedir(),suggestOnly:!0,depthLimit:1}),y.has("privateKeyPath")||t.push({type:"fuzzypath",name:"privateKeyPath",message:"Please providee the path to your private key?",rootPath:i.default.homedir(),suggestOnly:!0,depthLimit:1}),y.has("privatePassphrase")||t.push({type:"input",name:"privatePassphrase",message:"Please provide your private key passphrase?"})),t.length>0&&await f(t)}();const r=y.get("polykeyPath"),u=y.get("generateKeyPair"),h=new c.default(r);if(u){const e=y.get("keyGenerationName"),t=y.get("keyGenerationEmail"),a=y.get("keyGenerationPassphrase");o.default(a).score<2&&p.pkLogger("passphrase score for new keypair is below 2!",p.PKMessageType.WARNING);const r=new l.default.SingleBar({},l.default.Presets.shades_classic);r.start(200,0),r.update(100),r.stop(),await h.generateKeyPair(e,t,a,!0);const n=("~"!==(g=h.storePath)[0]||"/"!==g[1]&&1!==g.length||(g=g.replace("~",i.default.homedir())),g)+"/.keypair";s.default.mkdirSync(n,{recursive:!0});const u=n+"/public_key",d=n+"/private_key";await h.exportPublicKey(u),await h.exportPrivateKey(d),y.set("publicKeyPath",u),y.set("privateKeyPath",d),y.set("privatePassphrase",a),y.set("generateKeyPair",!1),y.delete("keyGenerationName"),y.delete("keyGenerationEmail"),y.delete("keyGenerationPassphrase")}else{const e=y.get("publicKeyPath"),t=y.get("privateKeyPath"),a=y.get("privatePassphrase");await h.loadKeyPair(e,t,a)}var g;e(new d.default(h,r))}))}},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("chalk")},function(e,t){e.exports=require("configstore")},function(e,t){e.exports=require("os")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(2)),i=r(a(4)),o=r(a(22)),n=r(a(5)),u=a(23);t.default=class{constructor(e="~/.polykey/",t=!1,a){this.primaryKeyPair={private:"",public:"",passphrase:""},this.storePath=e,this.useWebWorkers=t,this.workerPool=a,this.derivedKeys=new Map}async generateKeyPair(e,t,a,r=!1,s){const i=o.default.const.openpgp,n={asp:s?new o.default.ASP({progress_hook:s}):void 0,userid:`${e} <${t}>`,primary:{nbits:4096,flags:i.certify_keys|i.sign_data|i.auth|i.encrypt_comm|i.encrypt_storage,expire_in:0},subkeys:[]};return new Promise((e,t)=>{o.default.KeyManager.generate(n,(s,i)=>{s&&t(s),i.sign({},s=>{s&&t(s),i.export_pgp_public({},(s,o)=>{s&&t(s),i.export_pgp_private({passphrase:a},(s,n)=>{s&&t(s);const u={private:n,public:o,passphrase:a};r&&(this.primaryPassphrase=a,this.primaryKeyPair=u,this.primaryIdentity=i),e(u)})})})})})}getKeyPair(){return this.primaryKeyPair}getPublicKey(){return this.primaryKeyPair.public}getPrivateKey(){return this.primaryKeyPair.private}async loadPrivateKey(e,t=""){try{let a;a="string"==typeof e?Buffer.from(await s.default.promises.readFile(e)):e,this.primaryKeyPair.private=a.toString(),t&&(this.primaryPassphrase=t)}catch(e){throw e}}async loadPublicKey(e){try{let t;t="string"==typeof e?Buffer.from(await s.default.promises.readFile(e)):e,this.primaryKeyPair.public=t.toString()}catch(e){throw e}}async loadIdentity(e){return new Promise((t,a)=>{const r=this.getPublicKey(),s=this.getPrivateKey();o.default.KeyManager.import_from_armored_pgp({armored:r},(r,i)=>{r&&a(r),i.merge_pgp_private({armored:s},r=>{r&&a(r),i.is_pgp_locked()?i.unlock_pgp({passphrase:e},e=>{e&&a(e),this.primaryIdentity=i,t()}):(this.primaryIdentity=i,t())})})})}async loadKeyPair(e,t,a=""){await this.loadPrivateKey(t),await this.loadPublicKey(e),await this.loadIdentity(a),a&&this.primaryPassphrase}async exportPrivateKey(e){await s.default.promises.writeFile(e,this.primaryKeyPair.private)}async exportPublicKey(e){await s.default.promises.writeFile(e,this.primaryKeyPair.public)}generateKeySync(e,t){const a=n.default.randomBytes(32);return this.derivedKeys[e]=n.default.pbkdf2Sync(t,a,1e4,32,"sha256"),this.derivedKeys[e]}async generateKey(e,t){const a=n.default.randomBytes(32);return this.derivedKeys[e]=await u.promisify(n.default.pbkdf2)(t,a,1e4,32,"sha256"),this.derivedKeys[e]}importKeySync(e,t){this.derivedKeys[e]="string"==typeof t?s.default.readFileSync(t):t}async importKey(e,t){this.derivedKeys[e]="string"==typeof t?await s.default.promises.readFile(t):t}async exportKey(e,t,a){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);a&&await s.default.promises.mkdir(i.default.dirname(t),{recursive:!0}),await s.default.promises.writeFile(t,this.derivedKeys[e])}exportKeySync(e,t){if(!this.derivedKeys.has(name))throw Error("There is no key loaded for name: "+name);t&&s.default.mkdirSync(i.default.dirname(e),{recursive:!0}),s.default.writeFileSync(e,this.derivedKeys[name])}async getIdentityFromPublicKey(e){return new Promise((t,a)=>{o.default.KeyManager.import_from_armored_pgp({armored:e},(e,r)=>{e&&a(e),t(r)})})}async getIdentityFromPrivateKey(e,t){return new Promise((a,r)=>{o.default.KeyManager.import_from_armored_pgp({armored:e},(e,s)=>{e&&r(e),s.is_pgp_locked()?s.unlock_pgp({passphrase:t},e=>{e&&r(e),a(s)}):a(s)})})}signData(e,t,a){return new Promise(async(r,s)=>{let i;if(t)a||s(Error("passphrase for private key was not provided")),i=await this.getIdentityFromPrivateKey(t,a);else{if(!this.primaryIdentity)throw Error("no identity available for signing");i=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){const t=await this.workerPool.queue(async t=>await t.signData(e,i));r(t)}else{const t={msg:e,sign_with:i};o.default.box(t,(e,t,a)=>{e&&s(e),r(Buffer.from(t))})}})}verifyData(e,t,a){return new Promise(async(r,s)=>{const i=new o.default.keyring.KeyRing;let n;if(a)n=await this.getIdentityFromPublicKey(a);else{if(!this.primaryIdentity)throw new Error("no identity available for verifying");n=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){const a=await this.workerPool.queue(async a=>await a.verifyData(e,t,n));r(a)}else{i.add_key_manager(this.primaryIdentity);const a={armored:t,data:e,keyfetch:i};o.default.unbox(a,(e,t)=>{e&&s(e);let a,i=t[0].get_data_signer();i&&(a=i.get_key_manager()),a?r(a.get_pgp_fingerprint().toString("hex")):s(Error("could not verify file"))})}})}async verifyFile(e,t,a){let r;a&&(r="string"==typeof a?s.default.readFileSync(a):a);const i=s.default.readFileSync(e),o=s.default.readFileSync(t);return await this.verifyData(i,o,r)}async signFile(e,t,a){let r;t&&(r="string"==typeof t?Buffer.from(s.default.readFileSync(t)):t);const i=Buffer.from(s.default.readFileSync(e)),o=await this.signData(i,r,a),n=e+".sig";return s.default.writeFileSync(n,o),n}async encryptData(e,t){return new Promise(async(a,r)=>{let s;try{s=await this.getIdentityFromPublicKey(t)}catch(e){throw Error("Identity could not be resolved for encrypting: "+e)}if(this.useWebWorkers&&this.workerPool){const t=await this.workerPool.queue(async t=>await t.encryptData(e,s));a(t)}else{const t={msg:e,encrypt_for:s};o.default.box(t,(e,t,s)=>{e&&r(e),a(t)})}})}async decryptData(e,t){return new Promise(async(a,r)=>{var s=new o.default.keyring.KeyRing;let i;if(t)i=await this.getIdentityFromPublicKey(t);else{if(!this.primaryIdentity)throw Error("no identity available for signing");i=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){const t=await this.workerPool.queue(async t=>await t.decryptData(e,i));a(t)}else{s.add_key_manager(i);const t={armored:e,keyfetch:s};o.default.unbox(t,(e,t)=>{e&&r(e);try{const e=Buffer.from(t[0].toString());a(e)}catch(e){r(e)}})}})}getKey(e){return this.derivedKeys[e]}isLoaded(){return!!this.derivedKeys[name]}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(e,t){this.ip=e,this.port=t}static parse(e){const t=e.split(":"),a=t[0],s=t[1];return new r(a,s)}}t.Address=r,r.prototype.toString=function(){return`${this.ip}:${this.port}`};t.default=class{constructor(e,t=[],a){this.publicKey=e,this.addresses=new Set(t.map(e=>r.parse(e))),this.connectedAddr=a?r.parse(a):void 0}connect(e){this.addresses.has(e)||this.addresses.add(e),this.connectedAddr=e}disconnect(){this.connectedAddr=void 0}}},function(e,t,a){"use strict";(function(e){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(4)),i=r(a(25)),o=r(a(10));console.log(e);t.default=class{static loadProto(t){const a=new i.default.Root;return a.resolvePath=(t,a)=>s.default.join(e,a),a.loadSync(t)}static encodePeerInfo(e){var t;const a=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),r=[];for(const t of e.addresses)r.push(t.toString());const s={pubKey:e.publicKey,addresses:r,connectedAddr:null===(t=e.connectedAddr)||void 0===t?void 0:t.toString()},i=a.verify(s);if(i)throw Error(i);const o=a.create(s);return a.encode(o).finish()}static decodePeerInfo(e){const t=this.loadProto("PeerInfoMessage.proto").lookupType("peerinfopackage.PeerInfoMessage"),a=t.decode(e),r=t.toObject(a,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return new o.default(r.pubKey,r.addresses,r.connectedAddr)}static encodeHandshakeMessage(e,t,a,r){const s=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),i={targetPubKey:e,requestingPubKey:t,message:a,responsePeerInfo:r?this.encodePeerInfo(r):void 0},o=s.verify(i);if(o)throw Error(o);const n=s.create(i);return s.encode(n).finish()}static decodeHandshakeMessage(e){const t=this.loadProto("HandshakeMessage.proto").lookupType("handshakepackage.HandshakeMessage"),a=t.decode(e),r=t.toObject(a,{enums:String,longs:String,bytes:String,defaults:!0,arrays:!0,objects:!0,oneofs:!0});return{targetPubKey:Buffer.from(r.targetPubKey,"base64"),requestingPubKey:Buffer.from(r.requestingPubKey,"base64"),message:Buffer.from(r.message,"base64"),responsePeerInfo:r.responsePeerInfo?this.decodePeerInfo(Buffer.from(r.responsePeerInfo,"base64")):void 0}}}}).call(this,"/index.js")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(1)),i=r(a(7)),o=a(0);t.default=function(){return new s.default.Command("config").description("configure polykey").option("-pub, --public-key <publicKey>","provide the path to an existing public key").option("-priv, --private-key <privateKey>","provide the path to an existing private key").option("-pass, --private-passphrase <privatePassphrase>","provide the passphrase to the private key").option("-path, --polykey-path <polykeyPath>","provide the polykey path. defaults to ~/.polykey").option("-v, --verbose","increase verbosity by one level").action(o.actionRunner(async e=>{const t=new i.default("PolyKeyConfig");e.polykeyPath&&t.set("polykeyPath",e.polykeyPath),e.publicKeyPath&&t.set("publicKeyPath",e.publicKeyPath),e.privateKeyPath&&t.set("privateKeyPath",e.privateKeyPath),e.privatePassphrase&&t.set("privatePassphrase",e.privatePassphrase)})).addCommand(new s.default.Command("clear").description("clear the polykey config store").action(o.actionRunner(async e=>{new i.default("PolyKeyConfig").clear()}))).addCommand(new s.default.Command("list").description("list current polykey config parameters").alias("ls").action(o.actionRunner(async e=>{const t=new i.default("PolyKeyConfig");o.pkLogger("The current config parameters are:",o.PKMessageType.INFO),o.pkLogger("Polykey Path: "+t.get("polykeyPath"),o.PKMessageType.INFO),o.pkLogger("Public Key Path: "+t.get("publicKeyPath"),o.PKMessageType.INFO),o.pkLogger("Private Key Path: "+t.get("privateKeyPath"),o.PKMessageType.INFO),o.pkLogger("Private Key Passphrase: "+t.get("privatePassphrase"),o.PKMessageType.INFO)})))}},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(2)),i=r(a(1)),o=r(a(3)),n=a(0);t.default=function(){return new i.default.Command("secrets").description("manipulate secrets for a given vault").addCommand(new i.default.Command("list").description("list all available secrets for a given vault").alias("ls").requiredOption("-n, --vault-name <vaultName>","the vault name").option("--verbose","increase verbosity level by one").action(n.actionRunner(async e=>{var t;const a=await o.default(),r=null!==(t=e.verbose)&&void 0!==t&&t,s=e.vaultName;try{if(!await a.vaultExists(s))throw new Error(`vault '${s}' does not exist!`);const e=(await a.getVault(s)).listSecrets();r&&n.pkLogger(`secrets contained within the ${s} vault:`,n.PKMessageType.INFO),0==e.length?n.pkLogger(`no secrets found for vault '${s}'`,n.PKMessageType.INFO):e.forEach(e=>{n.pkLogger(e,n.PKMessageType.INFO)})}catch(e){throw new Error("Error when listing secrets: "+e.message)}}))).addCommand(new i.default.Command("add").description("add a secret to a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").requiredOption("-p, --secret-path <secretPath>","path to the secret to be removed").option("--verbose","increase verbosity level by one").action(n.actionRunner(async e=>{const t=await o.default(),a=(e.verbose,e.vaultName),r=e.secretName,i=e.secretPath;try{if(!await t.vaultExists(a))throw new Error(`vault '${a}' does not exist!`);const e=await t.getVault(r);if(await e.secretExists(r))throw new Error(`secret '${r}' already exists in vault ${a}!`);const o=s.default.readFileSync(i);if(await e.addSecret(r,o),!await e.secretExists(r))throw new Error(`something went wrong, secret '${r}' was not added to vault '${a}'`);n.pkLogger(`secret '${r}' was sucessfully added to vault '${a}'`,n.PKMessageType.SUCCESS)}catch(e){throw new Error("Error when adding secret: "+e.message)}}))).addCommand(new i.default.Command("remove").description("remove a secret from a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").option("--verbose","increase verbosity level by one").action(n.actionRunner(async e=>{const t=await o.default(),a=(e.verbose,e.vaultName),r=e.secretName;try{if(!await t.vaultExists(a))throw new Error(`vault '${a}' does not exist!`);const e=await t.getVault(r);if(await e.removeSecret(r),await e.secretExists(r))throw new Error(`something went wrong, secret '${r}' was not removed from vault '${a}'`);n.pkLogger(`secret '${r}' was sucessfully removed from vault '${a}'`,n.PKMessageType.SUCCESS)}catch(e){throw new Error("Error when removing secret: "+e.message)}})))}},function(e,t){e.exports=require("zxcvbn")},function(e,t){e.exports=require("inquirer")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(8)),i=r(a(2)),o=r(a(4)),n=r(a(5)),u=r(a(17)),d=r(a(18)),l=r(a(9)),c=r(a(24)),p=r(a(10)),y=r(a(11)),f=r(a(26));t.default=class{constructor(e,t,a=s.default.homedir()+"/.polykey"){if(this.polykeyPath=a,this.metadataPath=o.default.join(a,"metadata"),this.fs=i.default,this.keyManager=null!=e?e:new l.default(a),this.peerDiscovery=null!=t?t:new f.default(this.peerStore,this.keyManager),this.fs.existsSync(this.polykeyPath))if(this.fs.existsSync(this.metadataPath)){const e=u.default.readFileSync(this.metadataPath);this.metadata={vaults:e.vaults,peerInfo:e.peerInfo,publicKeyPath:e.publicKeyPath,privateKeyPath:e.privateKeyPath}}else{const e=new p.default(this.keyManager.getPublicKey()),t={vaults:{},peerInfo:y.default.encodePeerInfo(e)};u.default.writeFileSync(this.metadataPath,t),this.metadata=t}else this.fs.mkdirSync(this.polykeyPath,{recursive:!0});this.peerStore=new c.default(y.default.decodePeerInfo(this.metadata.peerInfo)),this.peerDiscovery=new f.default(this.peerStore,this.keyManager),this.vaults=new Map;for(const e in this.metadata.vaults)if(this.metadata.vaults.hasOwnProperty(e)){const t=o.default.join(this.polykeyPath,e);if(this.fs.existsSync(t)){const t=Buffer.from(this.metadata.vaults[e].key),a=new d.default(e,t,this.polykeyPath);this.vaults.set(e,a)}}}async getVault(e){if(this.vaults.has(e)){const t=this.vaults.get(e);if(t)return t}await this.validateVault(e);const t=this.metadata.vaults[e].key,a=new d.default(e,t,this.polykeyPath);return this.vaults.set(e,a),a}async createVault(e,t){const a=o.default.join(this.polykeyPath,e);let r;if(r=this.fs.existsSync(a),r)throw Error("Vault already exists!");try{let r;this.fs.mkdirSync(a,{recursive:!0}),r=t||n.default.randomBytes(16),this.metadata.vaults[e]={key:r,tags:[]},await this.writeMetadata();const s=new d.default(e,r,this.polykeyPath);return this.vaults.set(e,s),await this.getVault(e)}catch(t){throw await this.destroyVault(e),t}}async vaultExists(e){const t=o.default.join(this.polykeyPath,e);return this.fs.existsSync(t)}async destroyVault(e){const t=o.default.join(this.polykeyPath,e);if(this.fs.existsSync(t)&&this.fs.rmdirSync(t,{recursive:!0}),this.vaults.has(e)&&this.vaults.delete(e),this.metadata.vaults.hasOwnProperty(e)&&(delete this.metadata.vaults[e],await this.writeMetadata()),this.fs.existsSync(t))throw new Error("Vault path could not be destroyed!");if(this.vaults.has(e))throw new Error("Vault could not be removed from PolyKey!");if(this.metadata.vaults.hasOwnProperty(e))throw new Error("Vault metadata could not be destroyed!")}async validateVault(e){if(!this.metadata.vaults.hasOwnProperty(e))throw Error("Vault metadata does not exist");const t=o.default.join(this.polykeyPath,e);if(!this.fs.existsSync(t))throw Error("Vault directory does not exist")}listVaults(){return Array.from(this.vaults.keys())}tagVault(){}untagVault(){}shareVault(){}unshareVault(){}async writeMetadata(){try{await u.default.writeFile(this.metadataPath,this.metadata)}catch(e){throw Error("Error writing vault key to config file")}}}},function(e,t){e.exports=require("jsonfile")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(2)),i=r(a(4)),o=r(a(19)),n=a(20);t.default=class{constructor(e,t,r){this.keyLen=32,this.key=this.genSymKey(t,this.keyLen);const o=new(a(21).VirtualFS);this.fs=new n.EncryptedFS(t,o,o,s.default,process),this.name=e,this.vaultPath=i.default.join(r,e),this.fs.mkdirSync(this.vaultPath,{recursive:!0}),this.secrets=new Map,this.loadSecrets()}loadSecrets(){const e=s.default.readdirSync(this.vaultPath,void 0);for(const t of e)this.secrets.set(t,null)}genSymKey(e,t){return Buffer.from(o.default(e.toString(),t))}secretExists(e){const t=i.default.join(this.vaultPath,e);return this.secrets.has(e)&&this.fs.existsSync(t)}addSecret(e,t){const a=i.default.join(this.vaultPath,e),r=this.fs.openSync(a,"w");this.fs.writeSync(r,t,0,t.length,0),this.secrets.set(e,t)}getSecret(e){if(this.secrets.has(e)){const t=this.secrets.get(e);if(t)return t;{const t=i.default.join(this.vaultPath,e),a=this.fs.readFileSync(t,{});return this.secrets.set(e,a),a}}throw Error("Secret: "+e+" does not exist")}removeSecret(e){if(this.secrets.has(e)){if(this.secrets.delete(e))return;throw Error("Secret: "+e+" was not removed")}throw Error("Secret: "+e+" does not exist")}listSecrets(){return Array.from(this.secrets.keys())}tagVault(){}untagVault(){}shareVault(){}unshareVault(){}}},function(e,t){e.exports=require("futoin-hkdf")},function(e,t){e.exports=require("encryptedfs")},function(e,t){e.exports=require("virtualfs")},function(e,t){e.exports=require("kbpgp")},function(e,t){e.exports=require("util")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{constructor(e){this.localPeerInfo=e,this.peers=new Map}put(e){this.has(e.publicKey)?this.update(e):this.add(e)}add(e){this.peers.set(e.publicKey,e)}update(e){this.peers.set(e.publicKey,e)}get(e){var t;return null!==(t=this.peers.get(e))&&void 0!==t?t:null}has(e){return this.peers.has(e)}}},function(e,t){e.exports=require("protobufjs")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(27)),i=r(a(28)),o=a(31),n={name:"Keybase",findUser:async(e,t)=>{const a=`https://keybase.io/_/api/1.0/user/lookup.json?${t}=${e}`;try{const e=await s.default(a);return(await e.json()).them[0].public_keys.primary.bundle}catch(e){throw new Error("User was not found: "+e.message)}}};t.default=class{constructor(e,t,a=[]){this.peerStore=e,this.keyManager=t,this.socialDiscoveryServices=a,this.socialDiscoveryServices=[],this.socialDiscoveryServices.push(n);for(const e of a)this.socialDiscoveryServices.push(e);this.multicastBroadcaster=new i.default(this.peerStore,this.keyManager)}async findPubKey(e){return new Promise((t,a)=>{this.multicastBroadcaster.requestPeerContact(e),this.multicastBroadcaster.on("found",a=>{a.publicKey==e&&t(a)}),this.multicastBroadcaster.on("timeout",t=>{t==e&&a("The broadcaster stopped looking")})})}async findSocialUser(e,t){const a=[];for(const r of this.socialDiscoveryServices)try{a.push(r.findUser(e,t))}catch(e){console.log("Could not find user on this discovery service: "+r.name)}const r=await o.firstPromiseFulfilled(a);if(r.length>1)throw new Error("Could not find public key from services");const s=r[0];return await this.findPubKey(s)}}},function(e,t){e.exports=require("node-fetch")},function(e,t,a){"use strict";var r,s,i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=i(a(29)),n=i(a(5)),u=a(30),d=i(a(11)),l=parseInt(null!==(r=process.env.UDP_MULTICAST_PORT)&&void 0!==r?r:"5353"),c=null!==(s=process.env.UDP_MULTICAST_ADDR)&&void 0!==s?s:"224.0.0.251";class p extends u.EventEmitter{constructor(e,t){super(),this.peerPubKeyMessages=new Map,this.peerStore=e,this.keyManager=t,this.interval=1e3,this.queryInterval=null,this.socket=o.default.createSocket({type:"udp4",reuseAddr:!0}),this.socket.bind(l),this.socket.on("listening",(()=>{this.socket.addMembership(c);const e=this.socket.address();console.log(`UDP socket listening on ${e.address}:${e.port} pid: ${process.pid}`)}).bind(this)),this.socket.on("message",this.handleHandshakeMessages.bind(this)),this.queryInterval=this.queryLAN()}queryLAN(){const e=()=>{for(const e of this.peerPubKeyMessages.keys()){const t=this.peerPubKeyMessages.get(e);if(t){const e=d.default.encodeHandshakeMessage(t.encryptedPeerPubKey,t.encryptedLocalPubKey,t.encryptedRandomMessage);this.socket.send(e,0,e.length,l,c,()=>{console.info("Sending message to peer")})}}};return e(),setInterval(e,this.interval)}async handleHandshakeMessages(e,t){var a;try{const r=d.default.decodeHandshakeMessage(e);console.info(`Message from: ${t.address}:${t.port}`);const s=await this.keyManager.decryptData(r.message.toString()),i=await this.keyManager.decryptData(r.targetPubKey.toString()),o=await this.keyManager.decryptData(r.requestingPubKey.toString()),n=this.keyManager.getPublicKey();if(o.toString()==n){const e=null===(a=this.peerPubKeyMessages.get(i.toString()))||void 0===a?void 0:a.rawRandomMessage;if(s.toString()==(null==e?void 0:e.toString())){const e=r.responsePeerInfo;if(e){this.peerStore.add(e);const t=e.publicKey;this.peerPubKeyMessages.delete(t),console.log("New peer added to the store"),this.emit("found",e)}else this.emit("error","I got a validated response. But no peerInfo")}}else{const e=await this.keyManager.encryptData(Buffer.from(n),o),t=await this.keyManager.encryptData(s,o),a=await this.keyManager.encryptData(o,o),r=d.default.encodeHandshakeMessage(Buffer.from(e),Buffer.from(a),Buffer.from(t),this.peerStore.localPeerInfo);this.socket.send(r,0,r.length,l,c)}}catch(e){}}async requestPeerContact(e){const t=Buffer.from(e),a=n.default.randomBytes(16),r=await this.keyManager.encryptData(t,t),s=await this.keyManager.encryptData(a,t),i=await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()),t);this.peerPubKeyMessages.set(e,{encryptedLocalPubKey:Buffer.from(i),encryptedPeerPubKey:Buffer.from(r),rawRandomMessage:a,encryptedRandomMessage:Buffer.from(s)})}}t.default=p},function(e,t){e.exports=require("dgram")},function(e,t){e.exports=require("events")},function(e,t,a){"use strict";function r(e){return new Promise((t,a)=>e.then(a,t))}Object.defineProperty(t,"__esModule",{value:!0}),t.randomString=function(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)},t.firstPromiseFulfilled=function(e){return r(Promise.all(e.map(r)))}},function(e,t){e.exports=require("cli-progress")},function(e,t){e.exports=require("inquirer-fuzzy-path")},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(1)),i=r(a(3)),o=a(0);t.default=function(){return new s.default.Command("keymanager").alias("km").description("manipulate the keymanager").addCommand(new s.default.Command("derive").description("manipulate the keymanager").requiredOption("-n, --key-name <keyName>","the name of the new key").requiredOption("-p, --key-passphrase <keyPassphrase>","the passphrase for the new key").action(o.actionRunner(async e=>{const t=e.keyName,a=e.keyPassphrase;(await i.default()).keyManager.generateKeySync(a,t),o.pkLogger(`'${t}' was added to the Key Manager`,o.PKMessageType.SUCCESS)})))}},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(1)),i=a(0);t.default=function(){return new s.default.Command("node").description("control the current polykey node").addCommand(new s.default.Command("start").description("start the polykey node").action(i.actionRunner(async e=>{}))).addCommand(new s.default.Command("stop").description("stop the polykey node").action(i.actionRunner(async e=>{})))}},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(1)),i=r(a(3)),o=a(0);t.default=function(){return new s.default.Command("crypto").description("crypto operations").addCommand(new s.default.Command("verify").description("verification operations").option("-k, --verifying-key <verifyingKey>","path to public key that will be used to verify files").option("-s, --detach-sig <detachedSignature>","path to detached signature for file").arguments("file to be verified").action(o.actionRunner(async e=>{const t=await i.default(),a=e.verifyingKey,r=e.detachedSignature,s=Array.from(e.args.values());if(s.length<1)throw new Error("no file provided");const n=s[0];if(void 0===r)throw new Error("no signature provided");try{const e=await t.keyManager.verifyFile(n,r,a);o.pkLogger(`file '${n}' successfully verified. PGP fingerprint: ${e}`,o.PKMessageType.SUCCESS)}catch(e){throw new Error(`failed to sign '${n}': ${e.message}`)}}))).addCommand(new s.default.Command("sign").description("signing operations").option("-k, --signing-key <signingKey>","path to private key that will be used to sign files").option("-p, --key-passphrase <keyPassphrase>","passphrase to unlock the provided signing key").arguments("file(s) to be signed").action(async e=>{const t=await i.default(),a=e.signingKey,r=e.keyPassphrase,s=e.args.values();for(const e of s)try{const s=await t.keyManager.signFile(e,a,r);o.pkLogger(`file '${e}' successfully signed at '${s}'`,o.PKMessageType.SUCCESS)}catch(t){throw new Error(`failed to sign '${e}': ${t}`)}}))}},function(e,t,a){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(a(6)),i=r(a(1)),o=r(a(3)),n=a(0);t.default=function(){return new i.default.Command("vaults").description("manipulate vaults").addCommand(new i.default.Command("list").description("list all available vaults").alias("ls").option("-v, --verbose","increase verbosity level by one").action(n.actionRunner(async e=>{const t=await o.default();e.verbose&&n.pkLogger("vaults contained within polykey:",n.PKMessageType.INFO);const a=t.listVaults();void 0===a||0==a.length?n.pkLogger("no vaults found",n.PKMessageType.INFO):a.forEach(e=>{n.pkLogger(e,n.PKMessageType.INFO)})}))).addCommand(new i.default.Command("add").description("create new vault(s)").arguments("vault name(s)").action(n.actionRunner(async e=>{const t=await o.default(),a=e.args.values();for(const e of a)await t.createVault(e),n.pkLogger(`vault created at ${t.polykeyPath}/${e}`,n.PKMessageType.SUCCESS)}))).addCommand(new i.default.Command("remove").description("destroy an existing vault").option("-n, --vault-name <vaultName>","name of vault").option("-a, --all","remove all vaults").option("-v, --verbose","increase verbosity by one level").action(n.actionRunner(async e=>{var t,a;const r=await o.default(),i=null!==(t=e.verbose)&&void 0!==t&&t;if(null!==(a=e.all)&&void 0!==a&&a){const e=r.listVaults();if(void 0===e||0==e.length)n.pkLogger("no vaults found",n.PKMessageType.INFO);else{for(const t of e)await r.destroyVault(t),i&&n.pkLogger("destroyed "+t,n.PKMessageType.SUCCESS);n.pkLogger("all vaults destroyed successfully",n.PKMessageType.SUCCESS)}return}const u=e.vaultName;if(!u)throw new Error(s.default.red("error: did not receive vault name"));if(!await r.vaultExists(u))throw new Error(`vault '${u}' does not exist`);await r.destroyVault(u),n.pkLogger(`vault '${u}' destroyed ${await r.vaultExists(u)?"un-":""}successfully`,n.PKMessageType.SUCCESS)})))}},function(e){e.exports=JSON.parse('{"name":"polykey","bin":"bin/pk.js","version":"0.0.1","author":"Roger Qiu","description":"Polykey Core Library","keywords":["secrets"],"contributors":["Aaashwin Varshney","Robert Cronin"],"license":"Apache-2.0","repository":{"type":"git","url":"https://github.com/MatrixAI/js-polykey.git"},"main":"dist/polykey.js","types":"dist/index.d.ts","module":"dist/polykey.js","scripts":{"develop":"webpack --mode=development --watch & webpack-dev-server --mode=development & wait","build":"webpack --mode=\'production\'","build:types":"tsc src/lib/*.ts -d --declarationDir dist/ --declarationMap --emitDeclarationOnly","test":"jest"},"jest":{"verbose":true},"engines":{"node":">=12.14.0"},"dependencies":{"@grpc/grpc-js":"^1.0.5","@grpc/proto-loader":"^0.5.4","@types/commander":"^2.12.2","@types/configstore":"^4.0.0","@types/inquirer":"^6.5.0","chalk":"^4.0.0","cli-progress":"^3.8.2","commander":"^5.1.0","configstore":"^5.0.1","encryptedfs":"^0.1.0","fs-extra":"^9.0.0","futoin-hkdf":"^1.3.2","inquirer":"^7.1.0","inquirer-fuzzy-path":"^2.3.0","isomorphic-git":"^0.35.1","jsonfile":"^6.0.1","kbpgp":"^2.0.82","moniker":"^0.1.2","node-fetch":"^2.6.0","threads":"^1.6.0","virtualfs":"^2.2.0","zxcvbn":"^4.4.2"},"devDependencies":{"@types/jest":"^25.0.0","@types/node":"^13.13.1","copy-webpack-plugin":"^6.0.2","documentation":"^8.1.2","file-loader":"^6.0.0","jest":"^25.0.0","threads-plugin":"^1.3.1","ts-jest":"^25.0.0","ts-loader":"^6.2.2","ts-node":"^8.8.2","tsconfig-paths":"^3.9.0","tsconfig-paths-webpack-plugin":"^3.2.0","typescript":"^3.8.3","webpack":"^4.42.1","webpack-cli":"^3.3.11","webpack-node-externals":"^1.7.2"},"bugs":{"url":"https://github.com/MatrixAI/js-polykey/issues"},"homepage":"https://github.com/MatrixAI/js-polykey#readme"}')}])}));