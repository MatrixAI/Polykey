{"version":3,"sources":["webpack://polykey/webpack/universalModuleDefinition","webpack://polykey/webpack/bootstrap","webpack://polykey/external \"path\"","webpack://polykey/external \"os\"","webpack://polykey/external \"fs\"","webpack://polykey/external \"readable-stream\"","webpack://polykey/./src/lib/Polykey.ts","webpack://polykey/external \"crypto\"","webpack://polykey/external \"@grpc/grpc-js\"","webpack://polykey/proto/compiled/Git_grpc_pb\"","webpack://polykey/proto/compiled/Git_pb\"","webpack://polykey/./src/lib/git/upload-pack/GitPktLine.ts","webpack://polykey/./src/lib/git/upload-pack/GitRefManager.ts","webpack://polykey/external \"pako\"","webpack://polykey/./src/lib/git/pack-objects/GitCommit.ts","webpack://polykey/./src/lib/git/pack-objects/GitObjectManager.ts","webpack://polykey/./src/lib/peers/PeerInfo.ts","webpack://polykey/external \"isomorphic-git\"","webpack://polykey/external \"encryptedfs\"","webpack://polykey/external \"virtualfs\"","webpack://polykey/./src/lib/agent/PolykeyClient.ts","webpack://polykey/proto/js/Agent\"","webpack://polykey/./src/lib/keys/KeyManager.ts","webpack://polykey/external \"kbpgp\"","webpack://polykey/external \"util\"","webpack://polykey/./src/lib/peers/PeerManager.ts","webpack://polykey/./src/lib/git/GitClient.ts","webpack://polykey/./src/lib/git/GitBackend.ts","webpack://polykey/./src/lib/git/upload-pack/uploadPack.ts","webpack://polykey/./src/lib/git/upload-pack/GitPackedRefs.ts","webpack://polykey/./src/lib/git/side-band/GitSideBand.ts","webpack://polykey/external \"buffer\"","webpack://polykey/./src/lib/git/pack-objects/packObjects.ts","webpack://polykey/./src/lib/git/pack-objects/log.ts","webpack://polykey/./src/lib/git/pack-objects/GitObject.ts","webpack://polykey/./src/lib/git/pack-objects/shasum.ts","webpack://polykey/external \"sha.js/sha1\"","webpack://polykey/./src/lib/git/pack-objects/GitTree.ts","webpack://polykey/external \"sha.js\"","webpack://polykey/proto/js/Peer\"","webpack://polykey/./src/lib/utils.ts","webpack://polykey/./src/lib/peers/MulticastBroadcaster.ts","webpack://polykey/external \"dgram\"","webpack://polykey/external \"events\"","webpack://polykey/proto/js/Peer.js\"","webpack://polykey/./src/lib/vaults/VaultManager.ts","webpack://polykey/./src/lib/vaults/Vault.ts","webpack://polykey/./src/lib/agent/PolykeyAgent.ts","webpack://polykey/external \"net\"","webpack://polykey/external \"process\"","webpack://polykey/external \"child_process\"","webpack://polykey/external \"configstore\""],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","__importDefault","mod","os_1","KeyManager_1","KeyManager","default","PeerManager_1","PeerManager","VaultManager_1","VaultManager","PolykeyAgent_1","PolykeyAgent","PolykeyClient_1","PolykeyClient","polykeyPath","homedir","fileSystem","keyManager","vaultManager","peerManager","Buffer","from","line","hexlength","b","toString","repeat","length","padHex","concat","stream","async","slice","parseInt","buffer","err","console","log","path_1","GitPackedRefs_1","compareRefNames","a","_a","replace","_b","tmp","endsWith","GIT_FILES","GitRefManager","gitdir","text","readFileSync","encoding","refs","filepath","packedMap","packedRefs","files","recursiveDirectoryWalk","dir","Promise","resolve","reject","results","promises","readdir","then","list","pending","forEach","file","stat","isDirectory","res","push","catch","map","x","keys","startsWith","includes","sort","ref","depth","undefined","test","allpaths","refpaths","filter","sha","trim","Error","negateExceptForZero","formatTimezoneOffset","minutes","sign","Math","is","abs","hours","floor","strHours","String","strMinutes","parseTimezoneOffset","offset","match","Number","parseAuthor","author","email","timestamp","timezoneOffset","normalize","str","indent","split","join","GitCommit","commit","_commit","isBuffer","render","payload","signature","headers","justHeaders","message","justMessage","parseHeaders","assign","indexOf","hs","h","obj","parent","Array","isArray","committer","tree","gpgsig","renderHeaders","fs_1","pako_1","GitObject_1","PackfileCache","Map","GitObjectManager","oid","format","source","getExternalRefDelta","read","readdirSync","filename","offsets","has","pack","load","result","inflate","type","unwrap","Address","ip","port","addressString","components","addressInfo","address","pubKey","addresses","connectedAddr","publicKey","Set","addr","parse","add","values","Agent_1","AgentMessage","CreateSecretRequestMessage","CreateSecretResponseMessage","DeriveKeyRequestMessage","DeriveKeyResponseMessage","DestroySecretRequestMessage","DestroySecretResponseMessage","DestroyVaultRequestMessage","DestroyVaultResponseMessage","ErrorMessage","GetSecretRequestMessage","GetSecretResponseMessage","ListNodesRequestMessage","ListNodesResponseMessage","ListSecretsRequestMessage","ListSecretsResponseMessage","ListVaultsRequestMessage","ListVaultsResponseMessage","NewNodeRequestMessage","NewNodeResponseMessage","NewVaultRequestMessage","NewVaultResponseMessage","RegisterNodeRequestMessage","RegisterNodeResponseMessage","SignFileRequestMessage","SignFileResponseMessage","Type","VerifyFileRequestMessage","VerifyFileResponseMessage","agent","getStream","request","responseList","on","data","write","end","nodePath","agentMessage","encode","isResponse","subMessage","finish","sendRequestToAgent","agentMessageList","response","decode","ERROR","error","path","passphrase","registerNodeRequest","encodedResponse","handleAgentCommunication","REGISTER_NODE","successful","nbits","newNodeRequest","NEW_NODE","unlockedOnly","LIST_NODES","nodes","keyName","DERIVE_KEY","filePath","privateKeyPath","SIGN_FILE","signaturePath","VERIFY_FILE","verified","LIST_VAULTS","vaultNames","vaultName","NEW_VAULT","DESTROY_VAULT","LIST_SECRETS","secretNames","secretName","secretPath","CREATE_SECRET","DESTROY_SECRET","GET_SECRET","secret","STATUS","STOP_AGENT","getAgentStatus","kbpgp_1","crypto_1","util_1","polyKeyPath","useWebWorkers","workerPool","primaryKeyPair","private","public","metadata","publicKeyPath","pkiKeyPath","pkiCertPath","caCertPath","pkiInfo","cert","caCert","derivedKeys","keypairPath","existsSync","mkdirSync","recursive","metadataPath","loadMetadata","loadKeyPair","loadPKIInfo","replacePrimary","progressCallback","flags","openpgp","params","asp","ASP","progress_hook","userid","primary","certify_keys","sign_data","auth","encrypt_comm","encrypt_storage","expire_in","subkeys","identity","promisify","generate","export_pgp_public","keypair","export_pgp_private","primaryIdentity","writeFile","writeMetadata","privateKey","loadPrivateKey","loadPublicKey","keyBuffer","getPublicKey","getPrivateKey","import_from_armored_pgp","armored","merge_pgp_private","is_pgp_locked","unlock_pgp","writeFileSync","salt","randomBytes","pbkdf2Sync","pbkdf2","readFile","dest","createPath","dirname","mkdir","keyPassphrase","resolvedIdentity","getIdentityFromPrivateKey","queue","workerCrypto","signData","msg","sign_with","result_string","box","signedBuffer","signedPath","ring","keyring","KeyRing","getIdentityFromPublicKey","add_key_manager","verifyData","keyfetch","dataSigner","unbox","get_data_signer","get_key_manager","get_pgp_fingerprint","fileBuffer","signatureBuffer","encryptData","encrypt_for","decryptData","literals","writeToFile","storagePath","JSON","stringify","__importStar","k","grpc","GitClient_1","GitBackend_1","Peer_1","utils_1","PeerInfo_1","MulticastBroadcaster_1","Git_grpc_pb_1","Git_pb_1","keybaseDiscovery","findUser","handle","service","url","fetch","json","them","public_keys","bundle","peerInfo","socialDiscoveryServices","localPeerInfo","serverStarted","hasPublicKey","peerStore","multicastBroadcaster","addPeer","peerConnections","gitBackend","server","Server","addService","GitServerService","requestInfo","requestPack","PKIInfo","credentials","ServerCredentials","createInsecure","bindAsync","process","env","PK_PORT","boundPort","start","connect","callback","getVaultname","infoReply","InfoReply","setVaultname","setBody","handleInfoRequest","packRequest","body","getBody_asB64","reply","PackReply","handlePackRequest","set","requestPeerContact","timedOutPubKey","tasks","socialDiscovery","pubKeyOrFail","firstPromiseFulfilled","pubKeyFound","findPubKey","peer","existingSocket","peerAddress","getPeer","conn","PeerInfoMessage","AdressStringList","client","GitServerClient","method","onProgress","u","URL","pathname","infoResponse","statusCode","statusMessage","iteratorFromData","packResponse","InfoRequest","PackRequest","ended","next","done","readable_stream_1","uploadPack_1","GitSideBand_1","packObjects_1","vault","getVault","peerCanAccess","responseBuffers","exists","createGitPacketLine","EncryptedFS","buffers","buffersToWrite","wantedObjectId","packResult","readable","PassThrough","progressStream","sideBand","mux","packstream","hexPrefix","GitPktLine_1","GitRefManager_1","advertiseRefs","capabilities","listRefs","unshift","symrefs","syms","entries","caps","flush","writeRefsAdResponse","caller","GitPackedRefs","parsedConfig","comment","peeled","buffer_1","splitBuffer","maxBytes","index","buf","input","streamReader","packetlines","packfile","progress","nextBit","destroy","protocol","MAX_PACKET_LENGTH","output","packfileWasEmpty","packfileEnded","progressEnded","goodbye","log_1","GitTree_1","sha_js_1","GitCommit_1","GitObjectManager_1","types","blob","tag","ofs_delta","ref_delta","listObjects","oids","commits","trees","blobs","walk","entry","outputStream","hash","chunk","enc","update","writeObject","stype","lastFour","multibyte","byte","unpaddedChunk","deflate","digest","haves","shallows","unshallows","acks","oldshallows","objects","logCommit","signing","withoutSignature","compareAge","since","sinceTimestamp","valueOf","tips","pop","shasum_1","byteLength","actualLength","sha1_1","nudgeIntoShape","limitModeToAllowed","GitTree","_entries","cursor","space","nullchar","parseBuffer","iterator","invertPromise","rej","randomString","random","substr","ps","all","dgram_1","events_1","Peer_js_1","HandshakeMessage","UDP_MULTICAST_PORT","UDP_MULTICAST_ADDR","MulticastBroadcaster","EventEmitter","super","peerPubKeyMessages","interval","queryInterval","socket","createSocket","reuseAddr","addMembership","handleHandshakeMessages","queryLAN","pubKeyBuf","randomMessage","encryptedPeerPubKey","encryptedRandomMessage","encryptedLocalPubKey","rawRandomMessage","query","peerMessage","handshakeMessage","targetPubKey","requestingPubKey","send","setInterval","rinfo","responsePeerInfo","decryptedMessage","decryptedTargetPubKey","decryptedRequestingPubKey","myPubKey","originalMessage","newPeerInfo","delete","emit","encryptedTargetPubKey","encryptedMessage","encryptedPubKey","encodedLocalPeerInfo","isomorphic_git_1","Vault_1","encryptedfs_1","vaults","vaultKeys","vaultKey","validateVault","vaultExists","generateKey","initRepository","destroyVault","gitClient","vaultUrl","getRemoteInfo","http","vfsInstance","VirtualFS","newEfs","clone","fs","singleBranch","rmdirSync","vaultPath","encryptedMetadata","identityLoaded","symKey","baseDir","keyLen","efs","secrets","loadSecrets","writePath","commitChanges","secretBuf","unlink","sharedPubKeys","currentBranch","fullname","pull","init","fileContents","action","remove","net_1","process_1","child_process_1","Polykey_1","configstore_1","persistentStore","polykeyMap","socketPath","SocketPath","unlinkSync","nodePaths","removeFromNodePaths","createServer","listen","handleClientCommunication","getPolykey","AllNodePaths","close","pk","nodePathSet","encodedMessage","stop","exit","registerNode","newNode","listNodes","deriveKey","signFile","verifyFile","listVaults","newVault","listSecrets","createSecret","destroySecret","getSecret","errorResponse","unlockIdentity","km","addToNodePaths","generateKeyPair","info","UnlockedNodePaths","nodePathList","createVault","addSecret","removeSecret","passThrough","createConnection","pipe","platform","userInfo","cwd","uid","tmpdir","daemon","options","getuid","detached","LogPath","stdio","openSync","agentProcess","fork","DAEMON_SCRIPT_PATH","pid","unref","__dirname"],"mappings":"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","file":"polykey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"polykey\"] = factory();\n\telse\n\t\troot[\"polykey\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = require(\"path\");","module.exports = require(\"os\");","module.exports = require(\"fs\");","module.exports = require(\"readable-stream\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os_1 = __importDefault(require(\"os\"));\nconst KeyManager_1 = __importDefault(require(\"./keys/KeyManager\"));\nexports.KeyManager = KeyManager_1.default;\nconst PeerManager_1 = __importDefault(require(\"./peers/PeerManager\"));\nexports.PeerManager = PeerManager_1.default;\nconst VaultManager_1 = __importDefault(require(\"./vaults/VaultManager\"));\nexports.VaultManager = VaultManager_1.default;\nconst PolykeyAgent_1 = __importDefault(require(\"./agent/PolykeyAgent\"));\nexports.PolykeyAgent = PolykeyAgent_1.default;\nconst PolykeyClient_1 = __importDefault(require(\"./agent/PolykeyClient\"));\nexports.PolykeyClient = PolykeyClient_1.default;\nclass Polykey {\n    constructor(polykeyPath = `${os_1.default.homedir()}/.polykey`, fileSystem, keyManager, vaultManager, peerManager) {\n        this.polykeyPath = polykeyPath;\n        // Set key manager\n        this.keyManager = keyManager !== null && keyManager !== void 0 ? keyManager : new KeyManager_1.default(this.polykeyPath, fileSystem);\n        // Set or Initialize vaultManager\n        this.vaultManager = vaultManager !== null && vaultManager !== void 0 ? vaultManager : new VaultManager_1.default(this.polykeyPath, fileSystem, this.keyManager);\n        // Initialize peer store and peer discovery classes\n        this.peerManager = peerManager !== null && peerManager !== void 0 ? peerManager : new PeerManager_1.default(this.polykeyPath, fileSystem, this.keyManager, this.vaultManager);\n    }\n}\nexports.default = Polykey;\n","module.exports = require(\"crypto\");","module.exports = require(\"@grpc/grpc-js\");","module.exports = require(\"../../proto/compiled/Git_grpc_pb\");","module.exports = require(\"../../proto/compiled/Git_pb\");","\"use strict\";\n/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementors MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padHex(b, n) {\n    const s = n.toString(16);\n    return '0'.repeat(b - s.length) + s;\n}\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\nclass GitPktLine {\n    static flush() {\n        return Buffer.from('0000', 'utf8');\n    }\n    static encode(line) {\n        if (typeof line === 'string') {\n            line = Buffer.from(line);\n        }\n        const length = line.length + 4;\n        const hexlength = padHex(4, length);\n        return Buffer.concat([Buffer.from(hexlength, 'utf8'), line]);\n    }\n    static streamReader(stream) {\n        return async function read() {\n            try {\n                let length = await stream.slice(4);\n                if (length === null)\n                    return true;\n                length = parseInt(length.toString('utf8'), 16);\n                if (length === 0)\n                    return null;\n                let buffer = await stream.slice(length - 4);\n                if (buffer === null)\n                    return true;\n                return buffer;\n            }\n            catch (err) {\n                console.log('error', err);\n                return true;\n            }\n        };\n    }\n}\nexports.default = GitPktLine;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This is a convenience wrapper for reading and writing files in the 'refs' directory.\nconst path_1 = __importDefault(require(\"path\"));\nconst GitPackedRefs_1 = __importDefault(require(\"./GitPackedRefs\"));\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst refpaths = ref => [\n    `${ref}`,\n    `refs/${ref}`,\n    `refs/tags/${ref}`,\n    `refs/heads/${ref}`,\n    `refs/remotes/${ref}`,\n    `refs/remotes/${ref}/HEAD`,\n];\nfunction compareRefNames(a, b) {\n    // https://stackoverflow.com/a/40355107/2168416\n    const _a = a.replace(/\\^\\{\\}$/, '');\n    const _b = b.replace(/\\^\\{\\}$/, '');\n    const tmp = -(_a < _b) || +(_a > _b);\n    if (tmp === 0) {\n        return a.endsWith('^{}') ? 1 : -1;\n    }\n    return tmp;\n}\n// @see https://git-scm.com/docs/gitrepository-layout\nconst GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir'];\n// This function is used to get all the files in the refs folder for listRefs function\nasync function recursiveDirectoryWalk(dir, fileSystem) {\n    return new Promise((resolve, reject) => {\n        let results = [];\n        fileSystem.promises.readdir(dir).then(async (list) => {\n            var pending = list.length;\n            if (!pending)\n                return resolve(results);\n            list.forEach(async function (file) {\n                file = path_1.default.resolve(dir, file);\n                fileSystem.promises.stat(file).then(async (stat) => {\n                    if (stat && stat.isDirectory()) {\n                        const res = await recursiveDirectoryWalk(file, fileSystem);\n                        results = results.concat(res);\n                        if (!--pending)\n                            resolve(results);\n                    }\n                    else {\n                        results.push(file);\n                        if (!--pending)\n                            resolve(results);\n                    }\n                });\n            });\n        }).catch((err) => {\n            if (err)\n                return reject(err);\n        });\n    });\n}\n;\nclass GitRefManager {\n    static async packedRefs(fileSystem, gitdir) {\n        const text = fileSystem.readFileSync(`${gitdir}/packed-refs`, { encoding: 'utf8' });\n        const packed = GitPackedRefs_1.default.from(text);\n        return packed.refs;\n    }\n    // List all the refs that match the `filepath` prefix\n    static async listRefs(fileSystem, gitdir, filepath) {\n        const packedMap = GitRefManager.packedRefs(fileSystem, gitdir);\n        let files = [];\n        try {\n            files = await recursiveDirectoryWalk(`${gitdir}/${filepath}`, fileSystem);\n            files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''));\n        }\n        catch (err) {\n            files = [];\n        }\n        for (let key of (await packedMap).keys()) {\n            // filter by prefix\n            if (key.startsWith(filepath)) {\n                // remove prefix\n                key = key.replace(filepath + '/', '');\n                // Don't include duplicates; the loose files have precedence anyway\n                if (!files.includes(key)) {\n                    files.push(key);\n                }\n            }\n        }\n        // since we just appended things onto an array, we need to sort them now\n        files.sort(compareRefNames);\n        return files;\n    }\n    static async resolve(fileSystem, gitdir, ref, depth) {\n        if (depth !== undefined) {\n            depth--;\n            if (depth === -1) {\n                return ref;\n            }\n        }\n        // Is it a ref pointer?\n        if (ref.startsWith('ref: ')) {\n            ref = ref.slice('ref: '.length);\n            return GitRefManager.resolve(fileSystem, gitdir, ref, depth);\n        }\n        // Is it a complete and valid SHA?\n        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n            return ref;\n        }\n        // We need to alternate between the file system and the packed-refs\n        const packedMap = await GitRefManager.packedRefs(fileSystem, gitdir);\n        // Look in all the proper paths, in this order\n        const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)); // exclude git system files (#709)\n        for (const ref of allpaths) {\n            const sha = (fileSystem.readFileSync(`${gitdir}/${ref}`, { encoding: 'utf8' }).toString()) || packedMap.get(ref);\n            if (sha) {\n                return GitRefManager.resolve(fileSystem, gitdir, sha.trim(), depth);\n            }\n        }\n        // Do we give up?\n        throw (Error('RefNotFound'));\n    }\n}\nexports.default = GitRefManager;\n","module.exports = require(\"pako\");","\"use strict\";\n// The amount of work that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction simpleSign(n) {\n    return Math.sign(n) || (Object.is(n, -0) ? -1 : 1);\n}\nfunction negateExceptForZero(n) {\n    return n === 0 ? n : -n;\n}\nfunction formatTimezoneOffset(minutes) {\n    let sign = simpleSign(negateExceptForZero(minutes));\n    minutes = Math.abs(minutes);\n    let hours = Math.floor(minutes / 60);\n    minutes -= hours * 60;\n    let strHours = String(hours);\n    let strMinutes = String(minutes);\n    if (strHours.length < 2)\n        strHours = '0' + strHours;\n    if (strMinutes.length < 2)\n        strMinutes = '0' + strMinutes;\n    return (sign === -1 ? '-' : '+') + strHours + strMinutes;\n}\nfunction parseTimezoneOffset(offset) {\n    let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/);\n    minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes));\n    return negateExceptForZero(minutes);\n}\nfunction parseAuthor(author) {\n    let [, name, email, timestamp, offset] = author.match(/^(.*) <(.*)> (.*) (.*)$/);\n    return {\n        name: name,\n        email: email,\n        timestamp: Number(timestamp),\n        timezoneOffset: parseTimezoneOffset(offset)\n    };\n}\nfunction normalize(str) {\n    // remove all <CR>\n    str = str.replace(/\\r/g, '');\n    // no extra newlines up front\n    str = str.replace(/^\\n+/, '');\n    // and a single newline at the end\n    str = str.replace(/\\n+$/, '') + '\\n';\n    return str;\n}\nfunction indent(str) {\n    return (str\n        .trim()\n        .split('\\n')\n        .map(x => ' ' + x)\n        .join('\\n') + '\\n');\n}\nfunction outdent(str) {\n    return str\n        .split('\\n')\n        .map(x => x.replace(/^ /, ''))\n        .join('\\n');\n}\n// TODO: Make all functions have static async signature?\nclass GitCommit {\n    constructor(commit) {\n        if (typeof commit === 'string') {\n            this._commit = commit;\n        }\n        else if (Buffer.isBuffer(commit)) {\n            this._commit = commit.toString('utf8');\n        }\n        else if (typeof commit === 'object') {\n            this._commit = GitCommit.render(commit);\n        }\n        else {\n            throw (new Error('invalid type passed to GitCommit constructor'));\n        }\n    }\n    static fromPayloadSignature({ payload, signature }) {\n        let headers = GitCommit.justHeaders(payload);\n        let message = GitCommit.justMessage(payload);\n        let commit = normalize(headers + '\\ngpgsig' + indent(signature) + '\\n' + message);\n        return new GitCommit(commit);\n    }\n    static from(commit) {\n        return new GitCommit(commit);\n    }\n    toObject() {\n        return Buffer.from(this._commit, 'utf8');\n    }\n    // Todo: allow setting the headers and message\n    headers() {\n        return this.parseHeaders();\n    }\n    // Todo: allow setting the headers and message\n    message() {\n        return GitCommit.justMessage(this._commit);\n    }\n    parse() {\n        return Object.assign({ message: this.message() }, this.headers());\n    }\n    static justMessage(commit) {\n        return normalize(commit.slice(commit.indexOf('\\n\\n') + 2));\n    }\n    static justHeaders(commit) {\n        return commit.slice(0, commit.indexOf('\\n\\n'));\n    }\n    parseHeaders() {\n        let headers = GitCommit.justHeaders(this._commit).split('\\n');\n        let hs = [];\n        for (let h of headers) {\n            if (h[0] === ' ') {\n                // combine with previous header (without space indent)\n                hs[hs.length - 1] += '\\n' + h.slice(1);\n            }\n            else {\n                hs.push(h);\n            }\n        }\n        let obj = {\n            parent: []\n        };\n        for (let h of hs) {\n            let key = h.slice(0, h.indexOf(' '));\n            let value = h.slice(h.indexOf(' ') + 1);\n            if (Array.isArray(obj[key])) {\n                obj[key].push(value);\n            }\n            else {\n                obj[key] = value;\n            }\n        }\n        if (obj.author) {\n            obj.author = parseAuthor(obj.author);\n        }\n        if (obj.committer) {\n            obj.committer = parseAuthor(obj.committer);\n        }\n        return obj;\n    }\n    static renderHeaders(obj) {\n        let headers = '';\n        if (obj.tree) {\n            headers += `tree ${obj.tree}\\n`;\n        }\n        else {\n            headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n`; // the null tree\n        }\n        if (obj.parent) {\n            if (obj.parent.length === undefined) {\n                throw (new Error(`commit 'parent' property should be an array`));\n            }\n            for (let p of obj.parent) {\n                headers += `parent ${p}\\n`;\n            }\n        }\n        let author = obj.author;\n        headers += `author ${author.name} <${author.email}> ${author.timestamp} ${formatTimezoneOffset(author.timezoneOffset)}\\n`;\n        let committer = obj.committer || obj.author;\n        headers += `committer ${committer.name} <${committer.email}> ${committer.timestamp} ${formatTimezoneOffset(committer.timezoneOffset)}\\n`;\n        if (obj.gpgsig) {\n            headers += 'gpgsig' + indent(obj.gpgsig);\n        }\n        return headers;\n    }\n    static render(obj) {\n        return GitCommit.renderHeaders(obj) + '\\n' + normalize(obj.message);\n    }\n    render() {\n        return this._commit;\n    }\n    withoutSignature() {\n        let commit = normalize(this._commit);\n        if (commit.indexOf('\\ngpgsig') === -1)\n            return commit;\n        let headers = commit.slice(0, commit.indexOf('\\ngpgsig'));\n        let message = commit.slice(commit.indexOf('-----END PGP SIGNATURE-----\\n') +\n            '-----END PGP SIGNATURE-----\\n'.length);\n        return normalize(headers + '\\n' + message);\n    }\n    isolateSignature() {\n        let signature = this._commit.slice(this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'), this._commit.indexOf('-----END PGP SIGNATURE-----') +\n            '-----END PGP SIGNATURE-----'.length);\n        return outdent(signature);\n    }\n}\nexports.default = GitCommit;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\"));\nconst pako_1 = __importDefault(require(\"pako\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst GitObject_1 = __importDefault(require(\"./GitObject\"));\nconst PackfileCache = new Map();\nclass GitObjectManager {\n    static async read(fileSystem, gitdir, oid, format = 'content') {\n        // Look for it in the loose object directory.\n        let file = fileSystem.readFileSync(`${gitdir}/objects/${oid.slice(0, 2)}/${oid.slice(2)}`);\n        let source = `./objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n        // Check to see if it's in a packfile.\n        if (!file) {\n            // Curry the current read method so that the packfile un-deltification\n            // process can acquire external ref-deltas.\n            const getExternalRefDelta = oid => GitObjectManager.read(fileSystem, gitdir, oid);\n            // Iterate through all the .pack files\n            let list = fs_1.default.readdirSync(path_1.default.join(gitdir, '/objects/pack'));\n            list = list.filter(x => x.endsWith('.pack'));\n            for (let filename of list) {\n                // Try to get the packfile from the in-memory cache\n                let p = PackfileCache.get(filename);\n                // If the packfile DOES have the oid we're looking for...\n                if (p.offsets.has(oid)) {\n                    // Make sure the packfile is loaded in memory\n                    if (!p.pack) {\n                        const pack = fileSystem.readFileSync(`${gitdir}/objects/pack/${filename}`);\n                        await p.load({ pack });\n                    }\n                    // Get the resolved git object from the packfile\n                    let result = await p.read({ oid, getExternalRefDelta });\n                    result.source = `./objects/pack/${filename}`;\n                    return result;\n                }\n            }\n        }\n        // Check to see if it's in shallow commits.\n        if (!file) {\n            let text = fileSystem.readFileSync(`${gitdir}/shallow`, { encoding: 'utf8' });\n            if (text !== null && text.includes(oid)) {\n                throw (new Error(`ReadShallowObjectFail: ${oid}`));\n            }\n        }\n        // Finally\n        if (!file) {\n            throw (new Error(`ReadObjectFail: ${oid}`));\n        }\n        if (format === 'deflated') {\n            return { format: 'deflated', object: file, source };\n        }\n        let buffer = Buffer.from(pako_1.default.inflate(file));\n        if (format === 'wrapped') {\n            return { format: 'wrapped', object: buffer, source };\n        }\n        let { type, object } = GitObject_1.default.unwrap({ oid, buffer });\n        if (format === 'content')\n            return { type, format: 'content', object, source };\n    }\n}\nexports.default = GitObjectManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Address {\n    constructor(ip, port) {\n        this.ip = ip;\n        this.port = port;\n    }\n    /**\n     * Create an address object from a address string\n     * @param addressString Address string in the format of `${this.ip}:${this.port}`\n     */\n    static parse(addressString) {\n        const components = addressString.split(':');\n        const ip = components[0];\n        const port = components[1];\n        return new Address(ip, port);\n    }\n    /**\n     * Create an address object from a net.AddressInfo\n     * @param addressInfo AddressInfo of desired address\n     */\n    static fromAddressInfo(addressInfo) {\n        const ip = (addressInfo.address == '::') ? 'localhost' : addressInfo.address;\n        return new Address(ip, addressInfo.port.toString());\n    }\n    /**\n     * Convert address into string of format `${this.ip}:${this.port}`\n     */\n    toString() {\n        return `${this.ip}:${this.port}`;\n    }\n}\nexports.Address = Address;\nAddress.prototype.toString = function () {\n    return `${this.ip}:${this.port}`;\n};\nclass PeerInfo {\n    constructor(pubKey, addresses = [], connectedAddr) {\n        this.publicKey = pubKey;\n        this.addresses = new Set(addresses.map((addr) => {\n            return Address.parse(addr);\n        }));\n        this.connectedAddr = (connectedAddr) ? Address.parse(connectedAddr) : undefined;\n    }\n    /**\n     * Sets the main server address for the peer\n     * @param address Main server address for peer\n     */\n    connect(address) {\n        if (!this.addresses.has(address)) {\n            this.addresses.add(address);\n        }\n        this.connectedAddr = address;\n    }\n    /**\n     * Clears the main server address for the peer\n     */\n    disconnect() {\n        this.connectedAddr = undefined;\n    }\n    get AdressStringList() {\n        return Array.from(this.addresses.values()).map((addr) => {\n            return addr.toString();\n        });\n    }\n}\nexports.default = PeerInfo;\n","module.exports = require(\"isomorphic-git\");","module.exports = require(\"encryptedfs\");","module.exports = require(\"virtualfs\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Agent_1 = require(\"../../../proto/js/Agent\");\nconst { AgentMessage, CreateSecretRequestMessage, CreateSecretResponseMessage, DeriveKeyRequestMessage, DeriveKeyResponseMessage, DestroySecretRequestMessage, DestroySecretResponseMessage, DestroyVaultRequestMessage, DestroyVaultResponseMessage, ErrorMessage, GetSecretRequestMessage, GetSecretResponseMessage, ListNodesRequestMessage, ListNodesResponseMessage, ListSecretsRequestMessage, ListSecretsResponseMessage, ListVaultsRequestMessage, ListVaultsResponseMessage, NewNodeRequestMessage, NewNodeResponseMessage, NewVaultRequestMessage, NewVaultResponseMessage, RegisterNodeRequestMessage, RegisterNodeResponseMessage, SignFileRequestMessage, SignFileResponseMessage, Type, VerifyFileRequestMessage, VerifyFileResponseMessage } = Agent_1.agent;\nclass PolykeyClient {\n    constructor(getStream) {\n        this.getStream = getStream;\n    }\n    async sendRequestToAgent(request) {\n        const stream = this.getStream();\n        const responseList = await new Promise((resolve, reject) => {\n            try {\n                const responseList = [];\n                stream.on('data', (data) => {\n                    responseList.push(data);\n                });\n                stream.on('error', (err) => {\n                    reject(err);\n                });\n                stream.on('end', () => {\n                    resolve(responseList);\n                });\n                stream.write(request);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n        stream.end();\n        return responseList;\n    }\n    async handleAgentCommunication(type, nodePath, request) {\n        // Encode message and sent\n        const agentMessage = AgentMessage.encode({ type: type, isResponse: false, nodePath: nodePath, subMessage: request }).finish();\n        const responseList = await this.sendRequestToAgent(agentMessage);\n        const agentMessageList = [];\n        for (const response of responseList) {\n            const { subMessage, type } = AgentMessage.decode(response);\n            if (type == Type.ERROR) {\n                const { error } = ErrorMessage.decode(subMessage);\n                const reason = new Error(error);\n                throw reason;\n            }\n            else {\n                agentMessageList.push(AgentMessage.decode(response));\n            }\n        }\n        return agentMessageList;\n    }\n    async registerNode(path, passphrase) {\n        const registerNodeRequest = RegisterNodeRequestMessage.encode({ passphrase }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.REGISTER_NODE, path, registerNodeRequest);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = RegisterNodeResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    async newNode(path, name, email, passphrase, nbits) {\n        const newNodeRequest = NewNodeRequestMessage.encode({ name, email, passphrase, nbits }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.NEW_NODE, path, newNodeRequest);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = NewNodeResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    async listNodes(unlockedOnly = true) {\n        const newNodeRequest = ListNodesRequestMessage.encode({ unlockedOnly }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.LIST_NODES, undefined, newNodeRequest);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { nodes } = ListNodesResponseMessage.decode(encodedResponse[0].subMessage);\n        return nodes;\n    }\n    /////////////////////\n    // Crypto commands //\n    /////////////////////\n    async deriveKey(nodePath, keyName, passphrase) {\n        const request = DeriveKeyRequestMessage.encode({ keyName, passphrase }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.DERIVE_KEY, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = DeriveKeyResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    /////////////////////\n    // Crypto commands //\n    /////////////////////\n    async signFile(nodePath, filePath, privateKeyPath, passphrase) {\n        const request = SignFileRequestMessage.encode({ filePath, privateKeyPath, passphrase }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.SIGN_FILE, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { signaturePath } = SignFileResponseMessage.decode(encodedResponse[0].subMessage);\n        return signaturePath;\n    }\n    async verifyFile(nodePath, filePath, signaturePath) {\n        const request = VerifyFileRequestMessage.encode({ filePath, signaturePath }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.VERIFY_FILE, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { verified } = VerifyFileResponseMessage.decode(encodedResponse[0].subMessage);\n        return verified;\n    }\n    //////////////////////\n    // Vault Operations //\n    //////////////////////\n    async listVaults(nodePath) {\n        const encodedResponse = await this.handleAgentCommunication(Type.LIST_VAULTS, nodePath);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { vaultNames } = ListVaultsResponseMessage.decode(encodedResponse[0].subMessage);\n        return vaultNames;\n    }\n    async newVault(nodePath, vaultName) {\n        const request = NewVaultRequestMessage.encode({ vaultName }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.NEW_VAULT, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = NewVaultResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    async destroyVault(nodePath, vaultName) {\n        const request = DestroyVaultRequestMessage.encode({ vaultName }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.DESTROY_VAULT, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = DestroyVaultResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    ///////////////////////\n    // Secret Operations //\n    ///////////////////////\n    async listSecrets(nodePath, vaultName) {\n        const request = ListSecretsRequestMessage.encode({ vaultName }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.LIST_SECRETS, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { secretNames } = ListSecretsResponseMessage.decode(encodedResponse[0].subMessage);\n        return secretNames;\n    }\n    async createSecret(nodePath, vaultName, secretName, secretPath) {\n        const request = CreateSecretRequestMessage.encode({ vaultName, secretName, secretPath }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.CREATE_SECRET, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = CreateSecretResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    async destroySecret(nodePath, vaultName, secretName) {\n        const request = DestroySecretRequestMessage.encode({ vaultName, secretName }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.DESTROY_SECRET, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { successful } = DestroySecretResponseMessage.decode(encodedResponse[0].subMessage);\n        return successful;\n    }\n    async getSecret(nodePath, vaultName, secretName) {\n        const request = GetSecretRequestMessage.encode({ vaultName, secretName }).finish();\n        const encodedResponse = await this.handleAgentCommunication(Type.GET_SECRET, nodePath, request);\n        if (encodedResponse.length == 0) {\n            throw Error('agent did not respond');\n        }\n        const { secret } = GetSecretResponseMessage.decode(encodedResponse[0].subMessage);\n        return Buffer.from(secret);\n    }\n    ///////////////////\n    // Agent control //\n    ///////////////////\n    async getAgentStatus() {\n        try {\n            const encodedResponse = await this.handleAgentCommunication(Type.STATUS);\n            if (encodedResponse.length == 0) {\n                throw Error('agent did not respond');\n            }\n            const status = encodedResponse[0].subMessage.toString();\n            return status;\n        }\n        catch (err) {\n            return 'stopped';\n        }\n    }\n    async stopAgent() {\n        try {\n            // Tell it to start shutting and wait for response\n            await this.handleAgentCommunication(Type.STOP_AGENT);\n            return true;\n        }\n        catch (err) {\n            return (await this.getAgentStatus() != 'online');\n        }\n    }\n}\nexports.default = PolykeyClient;\n","module.exports = require(\"../../proto/js/Agent\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os_1 = __importDefault(require(\"os\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst kbpgp_1 = __importDefault(require(\"kbpgp\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst util_1 = require(\"util\");\nclass KeyManager {\n    constructor(polyKeyPath = `${os_1.default.homedir()}/.polykey`, fileSystem, useWebWorkers = false, workerPool) {\n        this.primaryKeyPair = { private: null, public: null };\n        this.metadata = {\n            privateKeyPath: null,\n            publicKeyPath: null,\n            pkiKeyPath: null,\n            pkiCertPath: null,\n            caCertPath: null,\n        };\n        /////////\n        // PKI //\n        /////////\n        this.pkiInfo = { key: null, cert: null, caCert: null };\n        this.useWebWorkers = useWebWorkers;\n        this.workerPool = workerPool;\n        this.derivedKeys = new Map();\n        this.fileSystem = fileSystem;\n        // Load key manager metadata\n        this.polykeyPath = polyKeyPath;\n        this.keypairPath = path_1.default.join(polyKeyPath, '.keypair');\n        if (!this.fileSystem.existsSync(this.keypairPath)) {\n            this.fileSystem.mkdirSync(this.keypairPath, { recursive: true });\n        }\n        this.metadataPath = path_1.default.join(this.keypairPath, 'metadata');\n        this.loadMetadata();\n        // Load keys if they were provided\n        if (this.metadata.privateKeyPath && this.metadata.publicKeyPath) {\n            // Load files into memory\n            this.loadKeyPair(this.metadata.publicKeyPath, this.metadata.privateKeyPath);\n        }\n        /////////\n        // PKI //\n        /////////\n        // Load pki keys and certs\n        if (this.metadata.pkiKeyPath) {\n            this.pkiInfo.key = fs_1.default.readFileSync(this.metadata.pkiKeyPath);\n        }\n        if (this.metadata.pkiCertPath) {\n            this.pkiInfo.cert = fs_1.default.readFileSync(this.metadata.pkiCertPath);\n        }\n        if (this.metadata.caCertPath) {\n            this.pkiInfo.caCert = fs_1.default.readFileSync(this.metadata.caCertPath);\n        }\n        this.loadPKIInfo(this.pkiInfo.key, this.pkiInfo.cert, this.pkiInfo.caCert, true);\n    }\n    get identityLoaded() {\n        return (this.primaryIdentity) ? true : false;\n    }\n    /**\n     * Generates a new assymetric key pair (publicKey and privateKey).\n     * @param name Name of keypair owner\n     * @param email Email of keypair owner\n     * @param passphrase Passphrase to lock the keypair\n     * @param nbits Size of the new keypair\n     * @param replacePrimary If true, the generated keypair becomes the new primary identity of the key manager\n     * @param progressCallback A progress hook for keypair generation\n     */\n    async generateKeyPair(name, email, passphrase, nbits = 4096, replacePrimary = false, progressCallback) {\n        // kbpgp doesn't seem to work for small nbits so set a minimum of 1024\n        if (nbits < 1024) {\n            throw new Error('nbits must be greater than 1024 for keypair generation');\n        }\n        // Define options\n        const flags = kbpgp_1.default[\"const\"].openpgp;\n        const params = {\n            asp: (progressCallback) ? new kbpgp_1.default.ASP({ progress_hook: progressCallback }) : undefined,\n            userid: `${name} <${email}>`,\n            primary: {\n                nbits: nbits,\n                flags: flags.certify_keys | flags.sign_data | flags.auth | flags.encrypt_comm | flags.encrypt_storage,\n                expire_in: 0 // never expire\n            },\n            subkeys: []\n        };\n        const identity = await util_1.promisify(kbpgp_1.default.KeyManager.generate)(params);\n        await util_1.promisify(identity.sign.bind(identity))({});\n        // Export pub key first\n        const publicKey = await util_1.promisify(identity.export_pgp_public.bind(identity))({});\n        // Finally export priv key\n        const privateKey = await util_1.promisify(identity.export_pgp_private.bind(identity))({ passphrase: passphrase });\n        // Resolve to parent promise\n        const keypair = { private: privateKey, public: publicKey };\n        if (replacePrimary) {\n            // Set the new keypair\n            this.primaryKeyPair = keypair;\n            // Set the new identity\n            this.primaryIdentity = identity;\n            // Overwrite in memory\n            const privateKeyPath = path_1.default.join(this.keypairPath, 'private_key');\n            const publicKeyPath = path_1.default.join(this.keypairPath, 'public_key');\n            await this.fileSystem.promises.writeFile(privateKeyPath, keypair.private);\n            await this.fileSystem.promises.writeFile(publicKeyPath, keypair.public);\n            // Set metadata\n            this.metadata.privateKeyPath = privateKeyPath;\n            this.metadata.publicKeyPath = publicKeyPath;\n            this.writeMetadata();\n        }\n        return keypair;\n    }\n    /**\n     * Get the primary keypair\n     */\n    getKeyPair() {\n        return this.primaryKeyPair;\n    }\n    /**\n     * Determines whether public key is loaded or not\n     */\n    hasPublicKey() {\n        return (this.primaryKeyPair.public) ? true : false;\n    }\n    /**\n     * Get the public key of the primary keypair\n     */\n    getPublicKey() {\n        if (!this.primaryKeyPair.public) {\n            throw new Error('Public key does not exist in memory');\n        }\n        return this.primaryKeyPair.public;\n    }\n    /**\n     * Get the private key of the primary keypair\n     */\n    getPrivateKey() {\n        if (!this.primaryKeyPair.private) {\n            throw new Error('Private key does not exist in memory');\n        }\n        return this.primaryKeyPair.private;\n    }\n    /**\n     * Loads the keypair into the key manager as the primary identity\n     * @param publicKey Public Key\n     * @param privateKey Private Key\n     */\n    loadKeyPair(publicKey, privateKey) {\n        this.loadPrivateKey(privateKey);\n        this.loadPublicKey(publicKey);\n    }\n    /**\n     * Loads the private key into the primary keypair\n     * @param privateKey Private Key\n     */\n    loadPrivateKey(privateKey) {\n        let keyBuffer;\n        if (typeof privateKey === 'string') {\n            keyBuffer = this.fileSystem.readFileSync(privateKey);\n            this.metadata.privateKeyPath = privateKey;\n            this.writeMetadata();\n        }\n        else {\n            keyBuffer = privateKey;\n        }\n        this.primaryKeyPair.private = keyBuffer.toString();\n    }\n    /**\n     * Loads the public key into the primary keypair\n     * @param publicKey Public Key\n     */\n    loadPublicKey(publicKey) {\n        let keyBuffer;\n        if (typeof publicKey === 'string') {\n            keyBuffer = this.fileSystem.readFileSync(publicKey);\n            this.metadata.publicKeyPath = publicKey;\n            this.writeMetadata();\n        }\n        else {\n            keyBuffer = publicKey;\n        }\n        this.primaryKeyPair.public = keyBuffer.toString();\n    }\n    /**\n     * Loads the primary identity into the key manager from the existing keypair\n     * @param passphrase Passphrase to unlock the private key\n     */\n    async unlockIdentity(passphrase) {\n        const publicKey = this.getPublicKey();\n        const privateKey = this.getPrivateKey();\n        const identity = await util_1.promisify(kbpgp_1.default.KeyManager.import_from_armored_pgp)({ armored: publicKey });\n        await util_1.promisify(identity.merge_pgp_private.bind(identity))({ armored: privateKey });\n        if (identity.is_pgp_locked.bind(identity)()) {\n            await util_1.promisify(identity.unlock_pgp.bind(identity))({ passphrase: passphrase });\n        }\n        this.primaryIdentity = identity;\n    }\n    /**\n     * Export the primary private key to a specified location\n     * @param path Destination path\n     */\n    exportPrivateKey(path) {\n        this.fileSystem.writeFileSync(path, this.primaryKeyPair.private);\n        this.metadata.privateKeyPath = path;\n        this.writeMetadata();\n    }\n    /**\n     * Export the primary public key to a specified location\n     * @param path Destination path\n     */\n    exportPublicKey(path) {\n        this.fileSystem.writeFileSync(path, this.primaryKeyPair.public);\n        this.metadata.publicKeyPath = path;\n        this.writeMetadata();\n    }\n    /**\n     * Synchronously generates a new symmetric key and stores it in the key manager\n     * @param name Unique name of the generated key\n     * @param passphrase Passphrase to derive the key from\n     */\n    generateKeySync(name, passphrase) {\n        const salt = crypto_1.default.randomBytes(32);\n        this.derivedKeys[name] = crypto_1.default.pbkdf2Sync(passphrase, salt, 10000, 256 / 8, 'sha256');\n        return this.derivedKeys[name];\n    }\n    /**\n     * Asynchronously Generates a new symmetric key and stores it in the key manager\n     * @param name Unique name of the generated key\n     * @param passphrase Passphrase to derive the key from\n     */\n    async generateKey(name, passphrase) {\n        const salt = crypto_1.default.randomBytes(32);\n        this.derivedKeys[name] = await util_1.promisify(crypto_1.default.pbkdf2)(passphrase, salt, 10000, 256 / 8, 'sha256');\n        return this.derivedKeys[name];\n    }\n    /**\n     * Synchronously imports an existing key from file or Buffer\n     * @param name Unique name of the imported key\n     * @param key Key to be imported\n     */\n    importKeySync(name, key) {\n        if (typeof key === 'string') {\n            this.derivedKeys[name] = this.fileSystem.readFileSync(key);\n        }\n        else {\n            this.derivedKeys[name] = key;\n        }\n    }\n    /**\n     * Asynchronously imports an existing key from file or Buffer\n     * @param name Unique name of the imported key\n     * @param key Key to be imported\n     */\n    async importKey(name, key) {\n        if (typeof key === 'string') {\n            this.derivedKeys[name] = await this.fileSystem.promises.readFile(key);\n        }\n        else {\n            this.derivedKeys[name] = key;\n        }\n    }\n    /**\n     * Synchronously exports an existing key from file or Buffer\n     * @param name Name of the key to be exported\n     * @param dest Destination path\n     * @param createPath If set to true, the path is recursively created\n     */\n    exportKeySync(name, dest, createPath) {\n        if (!this.derivedKeys.has(name)) {\n            throw Error(`There is no key loaded for name: ${name}`);\n        }\n        if (createPath) {\n            this.fileSystem.mkdirSync(path_1.default.dirname(dest), { recursive: true });\n        }\n        this.fileSystem.writeFileSync(dest, this.derivedKeys[name]);\n    }\n    /**\n     * Asynchronously exports an existing key from file or Buffer\n     * @param name Name of the key to be exported\n     * @param dest Destination path\n     * @param createPath If set to true, the path is recursively created\n     */\n    async exportKey(name, dest, createPath) {\n        if (!this.derivedKeys.has(name)) {\n            throw Error(`There is no key loaded for name: ${name}`);\n        }\n        if (createPath) {\n            await this.fileSystem.promises.mkdir(path_1.default.dirname(dest), { recursive: true });\n        }\n        await this.fileSystem.promises.writeFile(dest, this.derivedKeys[name]);\n    }\n    /**\n     * Loads an identity from the given public key\n     * @param publicKey Buffer containing the public key\n     */\n    async getIdentityFromPublicKey(publicKey) {\n        const identity = await util_1.promisify(kbpgp_1.default.KeyManager.import_from_armored_pgp)({ armored: publicKey });\n        return identity;\n    }\n    /**\n     * Loads an identity from the given private key\n     * @param publicKey Buffer containing the public key\n     */\n    async getIdentityFromPrivateKey(privateKey, passphrase) {\n        const identity = await util_1.promisify(kbpgp_1.default.KeyManager.import_from_armored_pgp)({ armored: privateKey });\n        if (identity.is_pgp_locked()) {\n            await util_1.promisify(identity.unlock_pgp)({ passphrase: passphrase });\n        }\n        return identity;\n    }\n    /**\n     * Signs the given data with the provided key or the primary key if none is specified\n     * @param data Buffer or file containing the data to be signed\n     * @param privateKey Buffer containing the key to sign with. Defaults to primary private key if no key is given.\n     * @param keyPassphrase Required if privateKey is provided.\n     */\n    async signData(data, privateKey, keyPassphrase) {\n        let resolvedIdentity;\n        if (privateKey) {\n            if (!keyPassphrase) {\n                throw new Error('passphrase for private key was not provided');\n            }\n            resolvedIdentity = await this.getIdentityFromPrivateKey(privateKey, keyPassphrase);\n        }\n        else if (this.primaryIdentity) {\n            resolvedIdentity = this.primaryIdentity;\n        }\n        else {\n            throw new Error('key pair is not loaded');\n        }\n        if (this.useWebWorkers && this.workerPool) {\n            const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n                return await workerCrypto.signData(data, resolvedIdentity);\n            });\n            return workerResponse;\n        }\n        else {\n            const params = {\n                msg: data.toString(),\n                sign_with: resolvedIdentity\n            };\n            const result_string = await util_1.promisify(kbpgp_1.default.box)(params);\n            return Buffer.from(result_string);\n        }\n    }\n    /**\n     * Signs the given file with the provided key or the primary key if none is specified\n     * @param filePath Path to file containing the data to be signed\n     * @param privateKey The key to sign with. Defaults to primary public key if no key is given.\n     * @param keyPassphrase Required if privateKey is provided.\n     */\n    async signFile(filePath, privateKey, keyPassphrase) {\n        // Get key if provided\n        let keyBuffer;\n        if (privateKey) {\n            if (typeof privateKey === 'string') { // Path\n                // Read in from fs\n                keyBuffer = this.fileSystem.readFileSync(privateKey);\n            }\n            else { // Buffer\n                keyBuffer = privateKey;\n            }\n        }\n        // Read file into buffer\n        const buffer = this.fileSystem.readFileSync(filePath);\n        // Sign the buffer\n        const signedBuffer = await this.signData(buffer, keyBuffer, keyPassphrase);\n        // Write buffer to signed file\n        const signedPath = `${filePath}.sig`;\n        this.fileSystem.writeFileSync(signedPath, signedBuffer);\n        return signedPath;\n    }\n    /**\n     * Verifies the given data with the provided key or the primary key if none is specified\n     * @param data Buffer or file containing the data to be verified\n     * @param signature The PGP signature\n     * @param publicKey Buffer containing the key to verify with. Defaults to primary public key if no key is given.\n     */\n    async verifyData(data, signature, publicKey) {\n        const ring = new kbpgp_1.default.keyring.KeyRing;\n        let resolvedIdentity;\n        if (publicKey) {\n            resolvedIdentity = await this.getIdentityFromPublicKey(publicKey);\n        }\n        else if (this.primaryIdentity) {\n            resolvedIdentity = this.primaryIdentity;\n        }\n        else {\n            throw new Error('key pair is not loaded');\n        }\n        ring.add_key_manager(resolvedIdentity);\n        if (this.useWebWorkers && this.workerPool) {\n            const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n                return await workerCrypto.verifyData(data, signature, resolvedIdentity);\n            });\n            return workerResponse;\n        }\n        else {\n            const params = {\n                armored: signature,\n                data: data,\n                keyfetch: ring\n            };\n            const literals = await util_1.promisify(kbpgp_1.default.unbox)(params);\n            // Get the identity that signed the data if any\n            let dataSigner = literals[0].get_data_signer();\n            // Retrieve the key manager associated with that data signer\n            let keyManager;\n            if (dataSigner) {\n                keyManager = dataSigner.get_key_manager();\n            }\n            // If we know the pgp finger print then we say the data is verified.\n            // Otherwise it is unverified.\n            if (keyManager) {\n                if (keyManager.get_pgp_fingerprint()) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    /**\n     * Verifies the given file with the provided key or the primary key if none is specified\n     * @param filePath Path to file containing the data to be verified\n     * @param signaturePath The path to the file containing the PGP signature\n     * @param publicKey Buffer containing the key to verify with. Defaults to primary public key if no key is given.\n     */\n    async verifyFile(filePath, signaturePath, publicKey) {\n        // Get key if provided\n        let keyBuffer;\n        if (publicKey) {\n            if (typeof publicKey === 'string') { // Path\n                // Read in from fs\n                keyBuffer = this.fileSystem.readFileSync(publicKey);\n            }\n            else { // Buffer\n                keyBuffer = publicKey;\n            }\n        }\n        // Read in file buffer and signature\n        const fileBuffer = this.fileSystem.readFileSync(filePath);\n        const signatureBuffer = this.fileSystem.readFileSync(signaturePath);\n        const isVerified = await this.verifyData(fileBuffer, signatureBuffer, keyBuffer);\n        return isVerified;\n    }\n    /**\n     * Encrypts the given data for a specific public key\n     * @param data The data to be encrypted\n     * @param publicKey The key to encrypt for\n     */\n    async encryptData(data, publicKey) {\n        let resolvedIdentity;\n        if (publicKey) {\n            resolvedIdentity = await this.getIdentityFromPublicKey(publicKey);\n        }\n        else if (this.primaryIdentity) {\n            resolvedIdentity = this.primaryIdentity;\n        }\n        else {\n            throw new Error(`Identity could not be resolved for encrypting`);\n        }\n        if (this.useWebWorkers && this.workerPool) {\n            const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n                return await workerCrypto.encryptData(data, resolvedIdentity);\n            });\n            return workerResponse;\n        }\n        else {\n            const params = {\n                msg: data,\n                encrypt_for: resolvedIdentity\n            };\n            const result_string = await util_1.promisify(kbpgp_1.default.box)(params);\n            return result_string;\n        }\n    }\n    /**\n     * Decrypts the given data with the provided key or the primary key if none is given\n     * @param data The data to be decrypted\n     * @param privateKey The key to decrypt with. Defaults to primary private key if no key is given.\n     * @param keyPassphrase Required if privateKey is provided.\n     */\n    async decryptData(data, privateKey, keyPassphrase) {\n        var ring = new kbpgp_1.default.keyring.KeyRing;\n        let resolvedIdentity;\n        if (privateKey) {\n            if (keyPassphrase) {\n                resolvedIdentity = await this.getIdentityFromPrivateKey(privateKey, keyPassphrase);\n            }\n            else {\n                throw new Error('A key passphrase must be supplied if a privateKey is specified');\n            }\n        }\n        else if (this.primaryIdentity) {\n            resolvedIdentity = this.primaryIdentity;\n        }\n        else {\n            throw Error('no identity available for decrypting');\n        }\n        if (this.useWebWorkers && this.workerPool) {\n            const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n                return await workerCrypto.decryptData(data, resolvedIdentity);\n            });\n            return workerResponse;\n        }\n        else {\n            ring.add_key_manager(resolvedIdentity);\n            const params = {\n                armored: data.toString(),\n                keyfetch: ring\n            };\n            const literals = await util_1.promisify(kbpgp_1.default.unbox)(params);\n            const decryptedData = Buffer.from(literals[0].toString());\n            return decryptedData;\n        }\n    }\n    /////////\n    // PKI //\n    /////////\n    get PKIInfo() {\n        return this.pkiInfo;\n    }\n    loadPKIInfo(key, cert, caCert, writeToFile = false) {\n        if (key) {\n            this.pkiInfo.key = key;\n        }\n        if (cert) {\n            this.pkiInfo.cert = cert;\n        }\n        if (caCert) {\n            this.pkiInfo.caCert = caCert;\n        }\n        if (writeToFile) {\n            // Store in the metadata path folder\n            const storagePath = path_1.default.dirname(this.metadataPath);\n            if (key) {\n                this.metadata.pkiKeyPath = path_1.default.join(storagePath, 'pki_private_key');\n                fs_1.default.writeFileSync(this.metadata.pkiKeyPath, key);\n            }\n            if (cert) {\n                this.metadata.pkiCertPath = path_1.default.join(storagePath, 'pki_cert');\n                fs_1.default.writeFileSync(this.metadata.pkiCertPath, cert);\n            }\n            if (caCert) {\n                this.metadata.caCertPath = path_1.default.join(storagePath, 'ca_cert');\n                fs_1.default.writeFileSync(this.metadata.caCertPath, caCert);\n            }\n        }\n    }\n    /* ============ HELPERS =============== */\n    /**\n     * Get the key for a given name\n     * @param name The unique name of the desired key\n     */\n    getKey(name) {\n        return this.derivedKeys[name];\n    }\n    /**\n     * Determines if the Key Manager has a certain key\n     * @param name The unique name of the desired key\n     */\n    hasKey(name) {\n        if (this.derivedKeys[name]) {\n            return true;\n        }\n        return false;\n    }\n    writeMetadata() {\n        const metadata = JSON.stringify(this.metadata);\n        this.fileSystem.writeFileSync(this.metadataPath, metadata);\n    }\n    loadMetadata() {\n        // Check if file exists\n        if (this.fileSystem.existsSync(this.metadataPath)) {\n            const metadata = this.fileSystem.readFileSync(this.metadataPath).toString();\n            this.metadata = JSON.parse(metadata);\n        }\n    }\n}\nexports.default = KeyManager;\n","module.exports = require(\"kbpgp\");","module.exports = require(\"util\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst grpc = __importStar(require(\"@grpc/grpc-js\"));\nconst GitClient_1 = __importDefault(require(\"../git/GitClient\"));\nconst GitBackend_1 = __importDefault(require(\"../git/GitBackend\"));\nconst Peer_1 = require(\"../../../proto/js/Peer\");\nconst utils_1 = require(\"../utils\");\nconst PeerInfo_1 = __importStar(require(\"../peers/PeerInfo\"));\nconst MulticastBroadcaster_1 = __importDefault(require(\"../peers/MulticastBroadcaster\"));\nconst Git_grpc_pb_1 = require(\"../../../proto/compiled/Git_grpc_pb\");\nconst Git_pb_1 = require(\"../../../proto/compiled/Git_pb\");\nconst keybaseDiscovery = {\n    name: 'Keybase',\n    findUser: async (handle, service) => {\n        const url = `https://keybase.io/_/api/1.0/user/lookup.json?${service}=${handle}`;\n        try {\n            const response = await fetch(url);\n            const data = await response.json();\n            const pubKey = data.them[0].public_keys.primary.bundle;\n            return pubKey;\n        }\n        catch (err) {\n            throw new Error(`User was not found: ${err.message}`);\n        }\n    }\n};\nclass PeerManager {\n    constructor(polykeyPath = `${os_1.default.homedir()}/.polykey`, fileSystem, keyManager, vaultManager, peerInfo, socialDiscoveryServices = []) {\n        var _a;\n        this.metadata = { localPeerInfo: null };\n        this.serverStarted = false;\n        this.fileSystem = fileSystem;\n        this.fileSystem.mkdirSync(polykeyPath, { recursive: true });\n        this.metadataPath = path_1.default.join(polykeyPath, '.peerMetadata');\n        // Set given variables\n        this.keyManager = keyManager;\n        this.socialDiscoveryServices = socialDiscoveryServices;\n        // Load metadata with peer info\n        this.loadMetadata();\n        // Load peer store and local peer info\n        if (peerInfo) {\n            this.localPeerInfo = peerInfo;\n            this.writeMetadata();\n        }\n        else if (this.metadata.localPeerInfo) {\n            this.localPeerInfo = this.metadata.localPeerInfo;\n        }\n        else if (this.keyManager.hasPublicKey()) {\n            this.localPeerInfo = new PeerInfo_1.default(this.keyManager.getPublicKey());\n        }\n        this.peerStore = new Map();\n        this.socialDiscoveryServices = [];\n        this.socialDiscoveryServices.push(keybaseDiscovery);\n        for (const service of socialDiscoveryServices) {\n            this.socialDiscoveryServices.push(service);\n        }\n        this.multicastBroadcaster = new MulticastBroadcaster_1.default(this.addPeer, this.localPeerInfo, this.keyManager);\n        this.peerConnections = new Map();\n        /////////////////\n        // GRPC Server //\n        /////////////////\n        this.gitBackend = new GitBackend_1.default(polykeyPath, vaultManager);\n        this.server = new grpc.Server();\n        // Add service\n        this.server.addService(Git_grpc_pb_1.GitServerService, {\n            requestInfo: this.requestInfo.bind(this),\n            requestPack: this.requestPack.bind(this)\n        });\n        // Create the server credentials. SSL only if ca cert exists\n        const pkiInfo = this.keyManager.PKIInfo;\n        // if (pkiInfo.caCert && pkiInfo.cert && pkiInfo.key) {\n        //   this.credentials = grpc.ServerCredentials.createSsl(\n        //     pkiInfo.caCert,\n        //     [{\n        //       private_key: pkiInfo.key,\n        //       cert_chain: pkiInfo.cert,\n        //     }],\n        //     true\n        //   )\n        // } else {\n        this.credentials = grpc.ServerCredentials.createInsecure();\n        // }\n        this.server.bindAsync(`0.0.0.0:${(_a = process.env.PK_PORT) !== null && _a !== void 0 ? _a : 0}`, this.credentials, (err, boundPort) => {\n            if (err) {\n                throw err;\n            }\n            else {\n                const address = new PeerInfo_1.Address('localhost', boundPort.toString());\n                this.server.start();\n                this.localPeerInfo.connect(address);\n                this.serverStarted = true;\n            }\n        });\n    }\n    async requestInfo(call, callback) {\n        const infoRequest = call.request;\n        const vaultName = infoRequest.getVaultname();\n        const infoReply = new Git_pb_1.InfoReply();\n        infoReply.setVaultname(vaultName);\n        infoReply.setBody(await this.gitBackend.handleInfoRequest(vaultName));\n        callback(null, infoReply);\n    }\n    async requestPack(call, callback) {\n        const packRequest = call.request;\n        const vaultName = packRequest.getVaultname();\n        const body = Buffer.from(packRequest.getBody_asB64(), 'base64');\n        const reply = new Git_pb_1.PackReply();\n        reply.setVaultname(vaultName);\n        reply.setBody(await this.gitBackend.handlePackRequest(vaultName, body));\n        callback(null, reply);\n    }\n    ////////////////\n    // Peer store //\n    ////////////////\n    /**\n     * Get the peer info of the current keynode\n     */\n    getLocalPeerInfo() {\n        return this.localPeerInfo;\n    }\n    /**\n     * Set the address of the active server\n     * @param adress Address of active server\n     */\n    connectLocalPeerInfo(address) {\n        this.localPeerInfo.connect(address);\n    }\n    /**\n     * Add a peer's info to the peerStore\n     * @param peerInfo Info of the peer to be added\n     */\n    addPeer(peerInfo) {\n        this.peerStore.set(peerInfo.publicKey, peerInfo);\n    }\n    /**\n     * Retrieves a peer for the given public key\n     * @param publicKey Public key of the desired peer\n     */\n    getPeer(publicKey) {\n        var _a;\n        return (_a = this.peerStore.get(publicKey)) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Determines if the peerStore contains the desired peer\n     * @param publicKey Public key of the desired peer\n     */\n    hasPeer(pubKey) {\n        return this.peerStore.has(pubKey);\n    }\n    //////////////////////\n    // Social discovery //\n    //////////////////////\n    /**\n     * Finds an existing peer using multicast peer discovery\n     * @param publicKey Public key of the desired peer\n     */\n    async findPubKey(publicKey) {\n        return new Promise((resolve, reject) => {\n            this.multicastBroadcaster.requestPeerContact(publicKey);\n            this.multicastBroadcaster.on('found', (peerInfo) => {\n                if (peerInfo.publicKey == publicKey) {\n                    resolve(peerInfo);\n                }\n            });\n            this.multicastBroadcaster.on('timeout', (timedOutPubKey) => {\n                if (timedOutPubKey == publicKey) {\n                    reject('The broadcaster stopped looking');\n                }\n            });\n        });\n    }\n    /**\n     * Finds an existing peer given a social service and handle\n     * @param handle Username or handle of the user (e.g. @john-smith)\n     * @param service Service on which to search for the user (e.g. github)\n     */\n    async findSocialUser(handle, service) {\n        const tasks = [];\n        for (const socialDiscovery of this.socialDiscoveryServices) {\n            try {\n                tasks.push(socialDiscovery.findUser(handle, service));\n            }\n            catch (error) {\n                console.log(`Could not find user on this discovery service: ${socialDiscovery.name}`);\n            }\n        }\n        const pubKeyOrFail = await utils_1.firstPromiseFulfilled(tasks);\n        if (pubKeyOrFail.length > 1) {\n            throw new Error('Could not find public key from services');\n        }\n        const pubKeyFound = pubKeyOrFail[0];\n        const peerInfo = await this.findPubKey(pubKeyFound);\n        return peerInfo;\n    }\n    ///////////////////////\n    // Peers Connections //\n    ///////////////////////\n    /**\n     * Get a secure connection to the peer\n     * @param peer Public key of an existing peer or address of new peer\n     */\n    connectToPeer(peer) {\n        var _a;\n        // Throw error if trying to connect to self\n        if (peer == this.localPeerInfo.connectedAddr || peer == this.localPeerInfo.publicKey) {\n            throw new Error('Cannot connect to self');\n        }\n        let address;\n        if (typeof peer == 'string') {\n            const existingSocket = this.peerConnections.get(peer);\n            if (existingSocket) {\n                return existingSocket;\n            }\n            const peerAddress = (_a = this.getPeer(peer)) === null || _a === void 0 ? void 0 : _a.connectedAddr;\n            if (peerAddress) {\n                address = peerAddress;\n            }\n            else {\n                throw new Error('Peer does not exist in peer store');\n            }\n        }\n        else {\n            address = peer;\n        }\n        const conn = new GitClient_1.default(address, this.keyManager);\n        if (typeof peer == 'string') {\n            this.peerConnections.set(peer, conn);\n        }\n        return conn;\n    }\n    /* ============ HELPERS =============== */\n    writeMetadata() {\n        var _a;\n        const peerInfo = this.localPeerInfo;\n        const metadata = Peer_1.peer.PeerInfoMessage.encode({\n            addresses: peerInfo.AdressStringList,\n            connectedAddr: (_a = peerInfo.connectedAddr) === null || _a === void 0 ? void 0 : _a.toString(),\n            pubKey: peerInfo.publicKey\n        }).finish();\n        this.fileSystem.writeFileSync(this.metadataPath, metadata);\n    }\n    loadMetadata() {\n        // Check if file exists\n        if (this.fileSystem.existsSync(this.metadataPath)) {\n            const metadata = this.fileSystem.readFileSync(this.metadataPath);\n            const { addresses, connectedAddr, pubKey } = Peer_1.peer.PeerInfoMessage.decode(metadata);\n            this.localPeerInfo = new PeerInfo_1.default(pubKey, addresses, connectedAddr);\n        }\n    }\n}\nexports.default = PeerManager;\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grpc = __importStar(require(\"@grpc/grpc-js\"));\nconst Git_grpc_pb_1 = require(\"../../../proto/compiled/Git_grpc_pb\");\nconst Git_pb_1 = require(\"../../../proto/compiled/Git_pb\");\n/**\n * Responsible for converting HTTP messages from isomorphic-git into requests and sending them to a specific peer.\n */\nclass GitClient {\n    constructor(address, keyManager) {\n        // const pkiInfo = keyManager.PKIInfo\n        // if (pkiInfo.caCert && pkiInfo.cert && pkiInfo.key) {\n        //   this.credentials = grpc.credentials.createSsl(\n        //     pkiInfo.caCert,\n        //     pkiInfo.key,\n        //     pkiInfo.cert,\n        //   )\n        // } else {\n        this.credentials = grpc.credentials.createInsecure();\n        // }\n        this.client = new Git_grpc_pb_1.GitServerClient(address.toString(), this.credentials);\n    }\n    /**\n     * The custom http request method to feed into isomorphic-git's [custom http object](https://isomorphic-git.org/docs/en/http)\n     */\n    async request({ url, method, headers, body, onProgress }) {\n        return new Promise(async (resolve, reject) => {\n            const u = new URL(url);\n            // Parse request\n            if (method == 'GET') {\n                // Info request\n                const match = u.pathname.match(/\\/(.+)\\/info\\/refs$/);\n                if (!match || /\\.\\./.test(match[1])) {\n                    reject(new Error('Error'));\n                }\n                const vaultName = match[1];\n                const infoResponse = await this.requestInfo(vaultName);\n                resolve({\n                    url: url,\n                    method: method,\n                    statusCode: 200,\n                    statusMessage: 'OK',\n                    body: this.iteratorFromData(infoResponse),\n                    headers: headers\n                });\n            }\n            else if (method == 'POST') {\n                // Info request\n                const match = u.pathname.match(/\\/(.+)\\/git-(.+)/);\n                if (!match || /\\.\\./.test(match[1])) {\n                    reject(new Error('Error'));\n                }\n                const vaultName = match[1];\n                const packResponse = await this.requestPack(vaultName, body[0]);\n                resolve({\n                    url: url,\n                    method: method,\n                    statusCode: 200,\n                    statusMessage: 'OK',\n                    body: this.iteratorFromData(packResponse),\n                    headers: headers\n                });\n            }\n            else {\n                reject(new Error('Method not supported'));\n            }\n        });\n    }\n    // ==== HELPER METHODS ==== //\n    /**\n     * Requests remote info from the connected peer for the named vault.\n     * @param vaultName Name of the desired vault\n     */\n    async requestInfo(vaultName) {\n        return new Promise((resolve, reject) => {\n            const request = new Git_pb_1.InfoRequest();\n            request.setVaultname(vaultName);\n            this.client.requestInfo(request, function (err, response) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(Buffer.from(response.getBody_asB64(), 'base64'));\n                }\n            });\n        });\n    }\n    /**\n     * Requests a pack from the connected peer for the named vault.\n     * @param vaultName Name of the desired vault\n     */\n    async requestPack(vaultName, body) {\n        return new Promise((resolve, reject) => {\n            const request = new Git_pb_1.PackRequest;\n            request.setVaultname(vaultName);\n            request.setBody(body);\n            this.client.requestPack(request, function (err, response) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(Buffer.from(response.getBody_asB64(), 'base64'));\n                }\n            });\n        });\n    }\n    /**\n     * Converts a buffer into an iterator expected by isomorphic git.\n     * @param data Data to be turned into an iterator\n     */\n    iteratorFromData(data) {\n        let ended = false;\n        return {\n            next() {\n                return new Promise((resolve, reject) => {\n                    if (ended) {\n                        return resolve({ done: true });\n                    }\n                    else {\n                        ended = true;\n                        resolve({ value: data, done: false });\n                    }\n                });\n            },\n        };\n    }\n}\nexports.default = GitClient;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path_1 = __importDefault(require(\"path\"));\nconst readable_stream_1 = require(\"readable-stream\");\nconst uploadPack_1 = __importDefault(require(\"./upload-pack/uploadPack\"));\nconst GitSideBand_1 = __importDefault(require(\"./side-band/GitSideBand\"));\nconst packObjects_1 = __importDefault(require(\"./pack-objects/packObjects\"));\n// Here is the protocol git outlines for sending pack files over http:\n// https://git-scm.com/docs/pack-protocol/2.17.0\n// https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt\n// This should be consulted in developing our upload pack implementation\n// This git backend (as well as HttpDuplex class) is heavily inspired by node-git-server:\n// https://github.com/gabrielcsapo/node-git-server\n// We need someway to notify other agents about what vaults we have based on some type of authorisation because they don't explicitly know about them\nclass GitBackend {\n    constructor(polykeyPath, vaultManager) {\n        this.polykeyPath = polykeyPath;\n        this.vaultManager = vaultManager;\n    }\n    /**\n     * Find out whether vault exists.\n     * @param vaultName Name of vault to check\n     * @param publicKey Public key of peer trying to access vault\n     */\n    exists(vaultName, publicKey) {\n        try {\n            const vault = this.vaultManager.getVault(vaultName);\n            if (vault) {\n                return vault.peerCanAccess(publicKey);\n            }\n            return false;\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    async handleInfoRequest(vaultName) {\n        var _a;\n        // Only handle upload-pack for now\n        const service = 'upload-pack';\n        const connectingPublicKey = '';\n        const responseBuffers = [];\n        if (!this.exists(vaultName, connectingPublicKey)) {\n            throw new Error('Vault does not exist');\n        }\n        else {\n            responseBuffers.push(Buffer.from(this.createGitPacketLine('# service=git-' + service + '\\n')));\n            responseBuffers.push(Buffer.from('0000'));\n            const fileSystem = (_a = this.vaultManager.getVault(vaultName)) === null || _a === void 0 ? void 0 : _a.EncryptedFS;\n            const buffers = await uploadPack_1.default(fileSystem, path_1.default.join(this.polykeyPath, vaultName), undefined, true);\n            const buffersToWrite = buffers !== null && buffers !== void 0 ? buffers : [];\n            responseBuffers.push(...buffersToWrite);\n        }\n        return Buffer.concat(responseBuffers);\n    }\n    async handlePackRequest(vaultName, body) {\n        return new Promise(async (resolve, reject) => {\n            var _a;\n            const responseBuffers = [];\n            // Check if vault exists\n            const connectingPublicKey = '';\n            if (!this.exists(vaultName, connectingPublicKey)) {\n                throw new Error('Vault does not exist');\n            }\n            const fileSystem = (_a = this.vaultManager.getVault(vaultName)) === null || _a === void 0 ? void 0 : _a.EncryptedFS;\n            if (fileSystem) {\n                if (body.toString().slice(4, 8) == 'want') {\n                    const wantedObjectId = body.toString().slice(9, 49);\n                    const packResult = await packObjects_1.default(fileSystem, path_1.default.join(this.polykeyPath, vaultName), [wantedObjectId], undefined);\n                    // This the 'wait for more data' line as I understand it\n                    responseBuffers.push(Buffer.from('0008NAK\\n'));\n                    // This is to get the side band stuff working\n                    const readable = new readable_stream_1.PassThrough();\n                    const progressStream = new readable_stream_1.PassThrough();\n                    const sideBand = GitSideBand_1.default.mux('side-band-64', readable, packResult.packstream, progressStream, []);\n                    sideBand.on('data', (data) => {\n                        responseBuffers.push(data);\n                    });\n                    sideBand.on('end', () => {\n                        resolve(Buffer.concat(responseBuffers));\n                    });\n                    sideBand.on('error', (err) => {\n                        reject(err);\n                    });\n                    // Write progress to the client\n                    progressStream.write(Buffer.from('0014progress is at 50%\\n'));\n                    progressStream.end();\n                }\n            }\n        });\n    }\n    // ============ Helper functions ============ //\n    createGitPacketLine(line) {\n        const hexPrefix = (4 + line.length).toString(16);\n        return Array(4 - hexPrefix.length + 1).join('0') + hexPrefix + line;\n    }\n}\nexports.default = GitBackend;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path_1 = __importDefault(require(\"path\"));\nconst GitPktLine_1 = __importDefault(require(\"./GitPktLine\"));\nconst GitRefManager_1 = __importDefault(require(\"./GitRefManager\"));\nasync function writeRefsAdResponse({ capabilities, refs, symrefs }) {\n    const stream = [];\n    // Compose capabilities string\n    let syms = '';\n    for (const [key, value] of Object.entries(symrefs)) {\n        syms += `symref=${key}:${value} `;\n    }\n    let caps = `\\x00${[...capabilities].join(' ')} ${syms}agent=git/isomorphic-git@1.4.0`;\n    // stream.write(GitPktLine.encode(`# service=${service}\\n`))\n    // stream.write(GitPktLine.flush())\n    // Note: In the edge case of a brand new repo, zero refs (and zero capabilities)\n    // are returned.\n    for (const [key, value] of Object.entries(refs)) {\n        stream.push(GitPktLine_1.default.encode(`${value} ${key}${caps}\\n`));\n        caps = '';\n    }\n    stream.push(GitPktLine_1.default.flush());\n    return stream;\n}\nasync function uploadPack(fileSystem, dir, gitdir = path_1.default.join(dir, '.git'), advertiseRefs = false) {\n    try {\n        if (advertiseRefs) {\n            // Send a refs advertisement\n            const capabilities = [\n                'side-band-64k',\n            ];\n            let keys = await GitRefManager_1.default.listRefs(fileSystem, gitdir, 'refs');\n            keys = keys.map(ref => `refs/${ref}`);\n            const refs = {};\n            keys.unshift('HEAD'); // HEAD must be the first in the list\n            for (const key of keys) {\n                refs[key] = await GitRefManager_1.default.resolve(fileSystem, gitdir, key);\n            }\n            const symrefs = {};\n            symrefs['HEAD'] = await GitRefManager_1.default.resolve(fileSystem, gitdir, 'HEAD', 2);\n            return writeRefsAdResponse({\n                capabilities,\n                refs,\n                symrefs,\n            });\n        }\n    }\n    catch (err) {\n        err.caller = 'git.uploadPack';\n        throw err;\n    }\n}\nexports.default = uploadPack;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass GitPackedRefs {\n    constructor(text) {\n        this.refs = new Map();\n        this.parsedConfig = [];\n        if (text) {\n            let key;\n            this.parsedConfig = text\n                .trim()\n                .split('\\n')\n                .map(line => {\n                if (/^\\s*#/.test(line)) {\n                    return { line: line, comment: true };\n                }\n                const i = line.indexOf(' ');\n                if (line.startsWith('^')) {\n                    // This is a oid for the commit associated with the annotated tag immediately preceding this line.\n                    // Trim off the '^'\n                    const value = line.slice(1);\n                    // The tagname^{} syntax is based on the output of `git show-ref --tags -d`\n                    this.refs.set(key + '^{}', value);\n                    return { line: line, ref: key, peeled: value };\n                }\n                else {\n                    // This is an oid followed by the ref name\n                    const value = line.slice(0, i);\n                    key = line.slice(i + 1);\n                    this.refs.set(key, value);\n                    return { line: line, ref: key, oid: value };\n                }\n            });\n        }\n        return this;\n    }\n    static from(text) {\n        return new GitPackedRefs(text);\n    }\n}\nexports.default = GitPackedRefs;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\nconst buffer_1 = require(\"buffer\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst GitPktLine_1 = __importDefault(require(\"../upload-pack/GitPktLine\"));\nfunction splitBuffer(buffer, maxBytes) {\n    const result = [];\n    let index = 0;\n    while (index < buffer.length) {\n        const buf = buffer.slice(index, index + maxBytes);\n        result.push(buf);\n        index += buf.length;\n    }\n    result.push(buffer.slice(index));\n    return result;\n}\nclass GitSideBand {\n    static demux(input) {\n        let read = GitPktLine_1.default.streamReader(input);\n        // And now for the ridiculous side-band or side-band-64k protocol\n        let packetlines = new readable_stream_1.PassThrough();\n        let packfile = new readable_stream_1.PassThrough();\n        let progress = new readable_stream_1.PassThrough();\n        // TODO: Use a proper through stream?\n        const nextBit = async function () {\n            let line = await read();\n            // Skip over flush packets\n            if (line === null)\n                return nextBit();\n            // A made up convention to signal there's no more to read.\n            if (line === true) {\n                packetlines.end();\n                progress.end();\n                packfile.end();\n                return;\n            }\n            // Examine first byte to determine which output \"stream\" to use\n            switch (line[0]) {\n                case 1: // pack data\n                    packfile.write(line.slice(1));\n                    break;\n                case 2: // progress message\n                    progress.write(line.slice(1));\n                    break;\n                case 3: // fatal error message just before stream aborts\n                    let error = line.slice(1);\n                    progress.write(error);\n                    packfile.destroy(new Error(error.toString('utf8')));\n                    return;\n                default:\n                    // Not part of the side-band-64k protocol\n                    packetlines.write(line.slice(0));\n            }\n            // Careful not to blow up the stack.\n            // I think Promises in a tail-call position should be OK.\n            nextBit();\n        };\n        nextBit();\n        return {\n            packetlines,\n            packfile,\n            progress\n        };\n    }\n    static mux(protocol, // 'side-band' or 'side-band-64k'\n    packetlines, packfile, progress, error) {\n        const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519;\n        let output = new readable_stream_1.PassThrough();\n        packetlines.on('data', data => {\n            if (data === null) {\n                output.write(GitPktLine_1.default.flush());\n            }\n            else {\n                output.write(GitPktLine_1.default.encode(data));\n            }\n        });\n        let packfileWasEmpty = true;\n        let packfileEnded = false;\n        let progressEnded = false;\n        let errorEnded = true;\n        let goodbye = buffer_1.Buffer.concat([\n            GitPktLine_1.default.encode(buffer_1.Buffer.from('010A', 'hex')),\n            GitPktLine_1.default.flush()\n        ]);\n        packfile\n            .on('data', data => {\n            packfileWasEmpty = false;\n            const buffers = splitBuffer(data, MAX_PACKET_LENGTH);\n            for (const buffer of buffers) {\n                output.write(GitPktLine_1.default.encode(buffer_1.Buffer.concat([buffer_1.Buffer.from('01', 'hex'), buffer])));\n            }\n        })\n            .on('end', () => {\n            packfileEnded = true;\n            if (!packfileWasEmpty)\n                output.write(goodbye);\n            if (progressEnded && errorEnded)\n                output.end();\n        });\n        progress\n            .on('data', data => {\n            const buffers = splitBuffer(data, MAX_PACKET_LENGTH);\n            for (const buffer of buffers) {\n                output.write(GitPktLine_1.default.encode(buffer_1.Buffer.concat([buffer_1.Buffer.from('02', 'hex'), buffer])));\n            }\n        })\n            .on('end', () => {\n            progressEnded = true;\n            if (packfileEnded && errorEnded)\n                output.end();\n        });\n        // error\n        //   .on('data', data => {\n        //     const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n        //     for (const buffer of buffers) {\n        //       output.write(\n        //         GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n        //       )\n        //     }\n        //   })\n        //   .on('end', () => {\n        //     errorEnded = true\n        //     if (progressEnded && packfileEnded) output.end()\n        //   })\n        return output;\n    }\n}\nexports.default = GitSideBand;\n","module.exports = require(\"buffer\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pako_1 = __importDefault(require(\"pako\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst log_1 = __importDefault(require(\"./log\"));\nconst GitTree_1 = __importDefault(require(\"./GitTree\"));\nconst sha_js_1 = __importDefault(require(\"sha.js\"));\nconst GitCommit_1 = __importDefault(require(\"./GitCommit\"));\nconst readable_stream_1 = require(\"readable-stream\");\nconst GitObjectManager_1 = __importDefault(require(\"./GitObjectManager\"));\nconst types = {\n    commit: 0b0010000,\n    tree: 0b0100000,\n    blob: 0b0110000,\n    tag: 0b1000000,\n    ofs_delta: 0b1100000,\n    ref_delta: 0b1110000\n};\n/**\n * Create a packfile stream\n *\n * @link https://isomorphic-git.github.io/docs/packObjects.html\n */\nasync function packObjects(fileSystem, dir, refs, depth, haves) {\n    const gitdir = path_1.default.join(dir, '.git');\n    let oids = new Set();\n    let shallows = new Set();\n    let unshallows = new Set();\n    let acks = [];\n    haves = (haves) ? haves : [];\n    const emitter = undefined;\n    const since = undefined;\n    for (const ref of refs) {\n        try {\n            let commits = await log_1.default(fileSystem, dir, gitdir, emitter, ref, depth, since);\n            let oldshallows = [];\n            for (let i = 0; i < commits.length; i++) {\n                let commit = commits[i];\n                if (haves.includes(commit.oid)) {\n                    acks.push({\n                        oid: ref\n                    });\n                    break;\n                }\n                oids.add(commit.oid);\n                if (i === commits.length - 1) {\n                    if (!oldshallows.includes(commit.oid) &&\n                        (depth !== undefined || since !== undefined)) {\n                        console.log('make it shallow', commit.oid);\n                        shallows.add(commit.oid);\n                    }\n                }\n                else if (oldshallows.includes(commit.oid)) {\n                    console.log('make it unshallow', commit.oid);\n                    unshallows.add(commit.oid);\n                }\n            }\n        }\n        catch (err) {\n            console.log(err);\n            // oh well.\n        }\n    }\n    let objects = await listObjects(fileSystem, dir, gitdir, Array.from(oids));\n    let packstream = new readable_stream_1.PassThrough();\n    pack(fileSystem, dir, undefined, [...objects], packstream);\n    return { packstream, shallows, unshallows, acks };\n}\nasync function listObjects(fileSystem, dir, gitdir = path_1.default.join(dir, '.git'), oids) {\n    let commits = new Set();\n    let trees = new Set();\n    let blobs = new Set();\n    // We don't do the purest simplest recursion, because we can\n    // avoid reading Blob objects entirely since the Tree objects\n    // tell us which oids are Blobs and which are Trees. And we\n    // do not need to recurse through commit parents.\n    async function walk(oid) {\n        let { type, object } = await GitObjectManager_1.default.read(fileSystem, gitdir, oid);\n        if (type === 'commit') {\n            commits.add(oid);\n            let commit = GitCommit_1.default.from(object);\n            let tree = commit.headers().tree;\n            await walk(tree);\n        }\n        else if (type === 'tree') {\n            trees.add(oid);\n            let tree = GitTree_1.default.from(object);\n            for (let entry of tree) {\n                if (entry.type === 'blob') {\n                    blobs.add(entry.oid);\n                }\n                // only recurse for trees\n                if (entry.type === 'tree') {\n                    await walk(entry.oid);\n                }\n            }\n        }\n    }\n    // Let's go walking!\n    for (let oid of oids) {\n        await walk(oid);\n    }\n    return [...commits, ...trees, ...blobs];\n}\nexports.listObjects = listObjects;\nasync function pack(fileSystem, dir, gitdir = path_1.default.join(dir, '.git'), oids, outputStream) {\n    let hash = sha_js_1.default('sha1');\n    function write(chunk, enc = undefined) {\n        if (enc) {\n            outputStream.write(chunk, enc);\n        }\n        else {\n            outputStream.write(chunk);\n        }\n        hash.update(chunk, enc);\n    }\n    function writeObject(object, stype) {\n        let lastFour;\n        let multibyte;\n        let length;\n        // Object type is encoded in bits 654\n        let type = types[stype];\n        if (type === undefined)\n            throw new Error('Unrecognized type: ' + stype);\n        // The length encoding get complicated.\n        length = object.length;\n        // Whether the next byte is part of the variable-length encoded number\n        // is encoded in bit 7\n        multibyte = length > 0b1111 ? 0b10000000 : 0b0;\n        // Last four bits of length is encoded in bits 3210\n        lastFour = length & 0b1111;\n        // Discard those bits\n        length = length >>> 4;\n        // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)\n        let byte = (multibyte | type | lastFour).toString(16);\n        write(byte, 'hex');\n        // Now we keep chopping away at length 7-bits at a time until its zero,\n        // writing out the bytes in what amounts to little-endian order.\n        while (multibyte) {\n            multibyte = length > 0b01111111 ? 0b10000000 : 0b0;\n            byte = multibyte | (length & 0b01111111);\n            const unpaddedChunk = byte.toString(16);\n            const paddedChunk = '0'.repeat(2 - unpaddedChunk.length) + unpaddedChunk;\n            write(paddedChunk, 'hex');\n            length = length >>> 7;\n        }\n        // Lastly, we can compress and write the object.\n        write(Buffer.from(pako_1.default.deflate(object)));\n    }\n    write('PACK');\n    write('00000002', 'hex');\n    // Write a 4 byte (32-bit) int\n    const unpaddedChunk = oids.length.toString(16);\n    const paddedChunk = '0'.repeat(8 - unpaddedChunk.length) + unpaddedChunk;\n    write(paddedChunk, 'hex');\n    for (let oid of oids) {\n        let { type, object } = await GitObjectManager_1.default.read(fileSystem, gitdir, oid);\n        writeObject(object, type);\n    }\n    // Write SHA1 checksum\n    let digest = hash.digest();\n    outputStream.end(digest);\n    return outputStream;\n}\nexports.pack = pack;\nexports.default = packObjects;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst GitCommit_1 = __importDefault(require(\"./GitCommit\"));\nconst GitObjectManager_1 = __importDefault(require(\"./GitObjectManager\"));\nconst GitRefManager_1 = __importDefault(require(\"../upload-pack/GitRefManager\"));\nasync function logCommit(fileSystem, gitdir, oid, signing) {\n    try {\n        let { type, object } = await GitObjectManager_1.default.read(fileSystem, gitdir, oid);\n        if (type !== 'commit') {\n            throw (new Error('expected type to be commit'));\n        }\n        const commit = GitCommit_1.default.from(object);\n        const result = Object.assign({ oid }, commit.parse());\n        if (signing) {\n            result.payload = commit.withoutSignature();\n        }\n        return result;\n    }\n    catch (err) {\n        return {\n            oid,\n            error: err\n        };\n    }\n}\nexports.logCommit = logCommit;\nfunction compareAge(a, b) {\n    return a.committer.timestamp - b.committer.timestamp;\n}\n/**\n * Get commit descriptions from the git history\n *\n * @link https://isomorphic-git.github.io/docs/log.html\n */\nasync function log(fileSystem, dir, gitdir = path.join(dir, '.git'), ref = 'HEAD', depth, since, // Date\nsigning = false) {\n    try {\n        let sinceTimestamp = since === undefined ? undefined : Math.floor(since.valueOf() / 1000);\n        // TODO: In the future, we may want to have an API where we return a\n        // async iterator that emits commits.\n        let commits = [];\n        let oid = await GitRefManager_1.default.resolve(fileSystem, gitdir, ref);\n        let tips /* : Array */ = [await logCommit(fileSystem, gitdir, oid, signing)];\n        while (true) {\n            let commit = tips.pop();\n            // Stop the loop if we encounter an error\n            if (commit.error) {\n                commits.push(commit);\n                break;\n            }\n            // Stop the log if we've hit the age limit\n            if (sinceTimestamp !== undefined &&\n                commit.committer.timestamp <= sinceTimestamp) {\n                break;\n            }\n            commits.push(commit);\n            // Stop the loop if we have enough commits now.\n            if (depth !== undefined && commits.length === depth)\n                break;\n            // Add the parents of this commit to the queue\n            // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.\n            for (const oid of commit.parent) {\n                let commit = await logCommit(fileSystem, gitdir, oid, signing);\n                if (!tips.map(commit => commit.oid).includes(commit.oid)) {\n                    tips.push(commit);\n                }\n            }\n            // Stop the loop if there are no more commit parents\n            if (tips.length === 0)\n                break;\n            // Process tips in order by age\n            tips.sort(compareAge);\n        }\n        return commits;\n    }\n    catch (err) {\n        err.caller = 'git.log';\n        throw err;\n    }\n}\nexports.default = log;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shasum_1 = __importDefault(require(\"./shasum\"));\nclass GitObject {\n    static hash({ type, object }) {\n        let buffer = Buffer.concat([\n            Buffer.from(`${type} ${object.byteLength.toString()}\\0`),\n            Buffer.from(object)\n        ]);\n        let oid = shasum_1.default(buffer);\n        return oid;\n    }\n    static wrap({ type, object }) {\n        let buffer = Buffer.concat([\n            Buffer.from(`${type} ${object.byteLength.toString()}\\0`),\n            object\n        ]);\n        let oid = shasum_1.default(buffer);\n        return {\n            oid,\n            buffer\n        };\n    }\n    static unwrap({ oid, buffer }) {\n        if (oid) {\n            let sha = shasum_1.default(buffer);\n            if (sha !== oid) {\n                throw (new Error(`SHA check failed! Expected ${oid}, computed ${sha}`));\n            }\n        }\n        let s = buffer.indexOf(32); // first space\n        let i = buffer.indexOf(0); // first null value\n        let type = buffer.slice(0, s).toString('utf8'); // get type of object\n        let length = buffer.slice(s + 1, i).toString('utf8'); // get type of object\n        let actualLength = buffer.length - (i + 1);\n        // verify length\n        if (parseInt(length) !== actualLength) {\n            throw (new Error(`Length mismatch: expected ${length} bytes but got ${actualLength} instead.`));\n        }\n        return {\n            type,\n            object: Buffer.from(buffer.slice(i + 1))\n        };\n    }\n}\nexports.default = GitObject;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sha1_1 = __importDefault(require(\"sha.js/sha1\"));\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasum(buffer) {\n    return new sha1_1.default().update(buffer).digest('hex');\n}\nexports.default = shasum;\n","module.exports = require(\"sha.js/sha1\");","\"use strict\";\n/*::\ntype TreeEntry = {\n  mode: string,\n  path: string,\n  oid: string,\n  type?: string\n}\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction parseBuffer(buffer) {\n    let _entries = [];\n    let cursor = 0;\n    while (cursor < buffer.length) {\n        let space = buffer.indexOf(32, cursor);\n        if (space === -1) {\n            throw (new Error(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`));\n        }\n        let nullchar = buffer.indexOf(0, cursor);\n        if (nullchar === -1) {\n            throw (new Error(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`));\n        }\n        let mode = buffer.slice(cursor, space).toString('utf8');\n        if (mode === '40000')\n            mode = '040000'; // makes it line up neater in printed output\n        let type = mode === '040000' ? 'tree' : 'blob';\n        let path = buffer.slice(space + 1, nullchar).toString('utf8');\n        let oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex');\n        cursor = nullchar + 21;\n        _entries.push({ mode, path, oid, type });\n    }\n    return _entries;\n}\nfunction limitModeToAllowed(mode) {\n    if (typeof mode === 'number') {\n        mode = mode.toString(8);\n    }\n    // tree\n    if (mode.match(/^0?4.*/))\n        return '40000'; // Directory\n    if (mode.match(/^1006.*/))\n        return '100644'; // Regular non-executable file\n    if (mode.match(/^1007.*/))\n        return '100755'; // Regular executable file\n    if (mode.match(/^120.*/))\n        return '120000'; // Symbolic link\n    if (mode.match(/^160.*/))\n        return '160000'; // Commit (git submodule reference)\n    throw (new Error(`Could not understand file mode: ${mode}`));\n}\nfunction nudgeIntoShape(entry) {\n    if (!entry.oid && entry.sha) {\n        entry.oid = entry.sha; // Github\n    }\n    entry.mode = limitModeToAllowed(entry.mode); // index\n    if (!entry.type) {\n        entry.type = 'blob'; // index\n    }\n    return entry;\n}\nclass GitTree {\n    constructor(entries) {\n        if (Buffer.isBuffer(entries)) {\n            this._entries = parseBuffer(entries);\n        }\n        else if (Array.isArray(entries)) {\n            this._entries = entries.map(nudgeIntoShape);\n        }\n        else {\n            throw (new Error('invalid type passed to GitTree constructor'));\n        }\n    }\n    static from(tree) {\n        return new GitTree(tree);\n    }\n    render() {\n        return this._entries\n            .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)\n            .join('\\n');\n    }\n    toObject() {\n        return Buffer.concat(this._entries.map((entry) => {\n            let mode = Buffer.from(entry.mode.replace(/^0/, ''));\n            let space = Buffer.from(' ');\n            let path = Buffer.from(entry.path);\n            // let path = Buffer.from(entry.path, { encoding: 'utf8' })\n            let nullchar = Buffer.from([0]);\n            let oid = Buffer.from(entry.oid.match(/../g).map(n => parseInt(n, 16)));\n            return Buffer.concat([mode, space, path, nullchar, oid]);\n        }));\n    }\n    entries() {\n        return this._entries;\n    }\n    *[Symbol.iterator]() {\n        for (let entry of this._entries) {\n            yield entry;\n        }\n    }\n}\nexports.default = GitTree;\n","module.exports = require(\"sha.js\");","module.exports = require(\"../../proto/js/Peer\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a 5 character long random string of lower case letters\n */\nfunction randomString() {\n    return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nexports.randomString = randomString;\n/**\n * Inverts the provided promise\n * @param p Promise to invert\n */\nfunction invertPromise(p) {\n    return new Promise((res, rej) => p.then(rej, res));\n}\n/**\n * Gets the first promise fulfiled\n * @param ps List of promises\n */\nfunction firstPromiseFulfilled(ps) {\n    return invertPromise(Promise.all(ps.map(invertPromise)));\n}\nexports.firstPromiseFulfilled = firstPromiseFulfilled;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a, _b;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dgram_1 = __importDefault(require(\"dgram\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst PeerInfo_1 = __importDefault(require(\"./PeerInfo\"));\nconst events_1 = require(\"events\");\nconst Peer_js_1 = require(\"../../../proto/js/Peer.js\");\nconst { HandshakeMessage, PeerInfoMessage } = Peer_js_1.peer;\n// This module is based heavily on libp2p's mDNS module:\n// https://github.com/libp2p/js-libp2p-mdns\n// It is supposed to discover peers on the local network\n// This module was also generated with the help of:\n// https://nrempel.com/using-udp-multicast-with-node-js/\n//\n// \"\"\"\n// In computer networking, the multicast DNS (mDNS) protocol\n// resolves hostnames to IP addresses within small networks\n// that do not include a local name server\n// \"\"\"\nconst UDP_MULTICAST_PORT = parseInt((_a = process.env.UDP_MULTICAST_PORT) !== null && _a !== void 0 ? _a : '5353');\nconst UDP_MULTICAST_ADDR = (_b = process.env.UDP_MULTICAST_ADDR) !== null && _b !== void 0 ? _b : \"224.0.0.251\";\nclass MulticastBroadcaster extends events_1.EventEmitter {\n    constructor(addPeer, localPeerInfo, keyManager) {\n        super();\n        this.peerPubKeyMessages = new Map();\n        this.addPeer = addPeer;\n        this.localPeerInfo = localPeerInfo;\n        this.keyManager = keyManager;\n        this.interval = (1e3);\n        this.queryInterval = null;\n        // Create socket\n        this.socket = dgram_1.default.createSocket({ type: \"udp4\", reuseAddr: true });\n        this.socket.bind(UDP_MULTICAST_PORT);\n        // Set up listener\n        this.socket.on(\"listening\", (() => {\n            this.socket.addMembership(UDP_MULTICAST_ADDR);\n            const address = this.socket.address();\n        }).bind(this));\n        // Handle messages\n        this.socket.on(\"message\", this.handleHandshakeMessages.bind(this));\n        // Start the query process\n        this.queryInterval = this.queryLAN();\n    }\n    /**\n     * Request a peer contact for the multicast peer discovery to check for\n     * @param publicKey Public key of the desired peer\n     */\n    async requestPeerContact(publicKey) {\n        const pubKeyBuf = Buffer.from(publicKey);\n        const randomMessage = crypto_1.default.randomBytes(16);\n        // Encrypt message\n        const encryptedPeerPubKey = await this.keyManager.encryptData(pubKeyBuf, pubKeyBuf);\n        const encryptedRandomMessage = await this.keyManager.encryptData(randomMessage, pubKeyBuf);\n        const encryptedLocalPubKey = await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()), pubKeyBuf);\n        // Add to peer messages to be sent over multicast\n        this.peerPubKeyMessages.set(publicKey, {\n            encryptedLocalPubKey: Buffer.from(encryptedLocalPubKey),\n            encryptedPeerPubKey: Buffer.from(encryptedPeerPubKey),\n            rawRandomMessage: randomMessage,\n            encryptedRandomMessage: Buffer.from(encryptedRandomMessage)\n        });\n    }\n    // ==== Helper methods ==== //\n    queryLAN() {\n        const query = () => {\n            for (const pubKey of this.peerPubKeyMessages.keys()) {\n                const peerMessage = this.peerPubKeyMessages.get(pubKey);\n                if (peerMessage) {\n                    const handshakeMessage = HandshakeMessage.encode({\n                        targetPubKey: peerMessage.encryptedPeerPubKey,\n                        requestingPubKey: peerMessage.encryptedLocalPubKey,\n                        message: peerMessage.encryptedRandomMessage\n                    }).finish();\n                    this.socket.send(handshakeMessage, 0, handshakeMessage.length, UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR);\n                }\n            }\n        };\n        // Immediately start a query, then do it every interval.\n        query();\n        return setInterval(query, this.interval);\n    }\n    async handleHandshakeMessages(request, rinfo) {\n        var _a, _b;\n        try {\n            const { message, requestingPubKey, responsePeerInfo, targetPubKey } = HandshakeMessage.decode(request);\n            // Try to decrypt message and pubKey\n            const decryptedMessage = await this.keyManager.decryptData(Buffer.from(message));\n            const decryptedTargetPubKey = await this.keyManager.decryptData(Buffer.from(targetPubKey));\n            const decryptedRequestingPubKey = await this.keyManager.decryptData(Buffer.from(requestingPubKey));\n            const myPubKey = this.keyManager.getPublicKey();\n            if (decryptedRequestingPubKey.toString() == myPubKey) { // Response\n                // Make sure decrypted bytes equal raw bytes in memory\n                const originalMessage = (_a = this.peerPubKeyMessages.get(decryptedTargetPubKey.toString())) === null || _a === void 0 ? void 0 : _a.rawRandomMessage;\n                if (decryptedMessage.toString() == (originalMessage === null || originalMessage === void 0 ? void 0 : originalMessage.toString())) { // Validated!\n                    // Add peer info to peerStore\n                    const { addresses, connectedAddr, pubKey } = PeerInfoMessage.decode(responsePeerInfo);\n                    const newPeerInfo = new PeerInfo_1.default(pubKey, addresses, connectedAddr);\n                    if (newPeerInfo) {\n                        this.addPeer(newPeerInfo);\n                        // Remove peerId from requested messages\n                        const pubKey = newPeerInfo.publicKey;\n                        this.peerPubKeyMessages.delete(pubKey);\n                        console.log(`New peer added to the store`);\n                        this.emit('found', newPeerInfo);\n                    }\n                    else {\n                        this.emit('error', \"I got a validated response. But no peerInfo\");\n                    }\n                }\n            }\n            else { // Requests on target node\n                // Try decrypting message\n                // Re-encrypt the data and send it on its way\n                const encryptedTargetPubKey = await this.keyManager.encryptData(Buffer.from(myPubKey), decryptedRequestingPubKey);\n                const encryptedMessage = await this.keyManager.encryptData(decryptedMessage, decryptedRequestingPubKey);\n                const encryptedPubKey = await this.keyManager.encryptData(decryptedRequestingPubKey, decryptedRequestingPubKey);\n                const encodedLocalPeerInfo = PeerInfoMessage.encode({\n                    addresses: this.localPeerInfo.AdressStringList,\n                    connectedAddr: (_b = this.localPeerInfo.connectedAddr) === null || _b === void 0 ? void 0 : _b.toString(),\n                    pubKey: this.localPeerInfo.publicKey\n                }).finish();\n                const handshakeMessage = HandshakeMessage.encode({\n                    targetPubKey: Buffer.from(encryptedTargetPubKey),\n                    requestingPubKey: Buffer.from(encryptedPubKey),\n                    message: Buffer.from(encryptedMessage),\n                    responsePeerInfo: encodedLocalPeerInfo\n                }).finish();\n                this.socket.send(handshakeMessage, 0, handshakeMessage.length, UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR);\n            }\n        }\n        catch (err) { // Couldn't decode message\n            // We don't want the multicast discovery to error on every message it coudln't decode!\n        }\n    }\n}\nexports.default = MulticastBroadcaster;\n","module.exports = require(\"dgram\");","module.exports = require(\"events\");","module.exports = require(\"../../proto/js/Peer.js\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst isomorphic_git_1 = __importDefault(require(\"isomorphic-git\"));\nconst Vault_1 = __importDefault(require(\"../vaults/Vault\"));\nconst encryptedfs_1 = require(\"encryptedfs\");\nclass VaultManager {\n    constructor(polykeyPath = `${os_1.default.homedir()}/.polykey`, fileSystem, keyManager) {\n        this.polykeyPath = polykeyPath;\n        this.fileSystem = fileSystem;\n        this.keyManager = keyManager;\n        this.metadataPath = path_1.default.join(polykeyPath, '.vaultKeys');\n        // Make polykeyPath if it doesn't exist\n        this.fileSystem.mkdirSync(this.polykeyPath, { recursive: true });\n        // Initialize stateful variables\n        this.vaults = new Map();\n        this.vaultKeys = new Map();\n        // Read in vault keys\n        this.loadMetadata();\n        // Initialize vaults in memory\n        for (const [vaultName, vaultKey] of this.vaultKeys.entries()) {\n            const path = path_1.default.join(this.polykeyPath, vaultName);\n            if (this.fileSystem.existsSync(path)) {\n                const vault = new Vault_1.default(vaultName, vaultKey, this.polykeyPath);\n                this.vaults.set(vaultName, vault);\n            }\n        }\n    }\n    /**\n     * Get a vault from the vault manager\n     * @param vaultName Name of desired vault\n     */\n    getVault(vaultName) {\n        if (this.vaults.has(vaultName)) {\n            const vault = this.vaults.get(vaultName);\n            return vault;\n        }\n        else if (this.vaultKeys.has(vaultName)) {\n            // vault not in map, create new instance\n            this.validateVault(vaultName);\n            const vaultKey = this.vaultKeys.get(vaultName);\n            const vault = new Vault_1.default(vaultName, vaultKey, this.polykeyPath);\n            this.vaults.set(vaultName, vault);\n            return vault;\n        }\n        else {\n            throw new Error('Vault does not exist in memory');\n        }\n    }\n    /**\n     * Get a vault from the vault manager\n     * @param vaultName Unique name of new vault\n     * @param key Optional key to use for the vault encryption, otherwise it is generated\n     */\n    async createVault(vaultName, key) {\n        if (this.vaultExists(vaultName)) {\n            throw Error('Vault already exists!');\n        }\n        try {\n            const path = path_1.default.join(this.polykeyPath, vaultName);\n            // Directory not present, create one\n            this.fileSystem.mkdirSync(path, { recursive: true });\n            // Create key if not provided\n            let vaultKey;\n            if (!key) {\n                // Generate new key\n                vaultKey = await this.keyManager.generateKey(`${vaultName}-Key`, this.keyManager.getPrivateKey());\n            }\n            else {\n                // Assign key if it is provided\n                vaultKey = key;\n            }\n            this.vaultKeys.set(vaultName, vaultKey);\n            this.writeMetadata();\n            const vault = new Vault_1.default(vaultName, vaultKey, this.polykeyPath);\n            await vault.initRepository();\n            this.vaults.set(vaultName, vault);\n            return this.getVault(vaultName);\n        }\n        catch (err) {\n            // Delete vault dir and garbage collect\n            this.destroyVault(vaultName);\n            throw err;\n        }\n    }\n    /**\n     * Get a vault from the vault manager\n     * @param vaultName Name of vault to be cloned\n     * @param address Address of polykey node that owns vault to be cloned\n     * @param getSocket Function to get an active connection to provided address\n     */\n    async cloneVault(vaultName, gitClient) {\n        // Confirm it doesn't exist locally already\n        if (this.vaultExists(vaultName)) {\n            throw new Error('Vault name already exists locally, try pulling instead');\n        }\n        const vaultUrl = `http://0.0.0.0/${vaultName}`;\n        // First check if it exists on remote\n        const info = await isomorphic_git_1.default.getRemoteInfo({\n            http: gitClient,\n            url: vaultUrl\n        });\n        if (!info.refs) {\n            throw new Error(`Peer does not have vault: '${vaultName}'`);\n        }\n        // Create new efs first\n        // Generate new key\n        const vaultKey = await this.keyManager.generateKey(`${vaultName}-Key`, this.keyManager.getPrivateKey());\n        // Set filesystem\n        const vfsInstance = new (require('virtualfs')).VirtualFS;\n        const newEfs = new encryptedfs_1.EncryptedFS(vaultKey, vfsInstance, vfsInstance, this.fileSystem, process);\n        // Clone vault from address\n        await isomorphic_git_1.default.clone({\n            fs: { promises: newEfs.promises },\n            http: gitClient,\n            dir: path_1.default.join(this.polykeyPath, vaultName),\n            url: vaultUrl,\n            ref: 'master',\n            singleBranch: true\n        });\n        // Finally return the vault\n        const vault = new Vault_1.default(vaultName, vaultKey, this.polykeyPath);\n        this.vaults.set(vaultName, vault);\n        return vault;\n    }\n    /**\n     * Determines whether the vault exists\n     * @param vaultName Name of desired vault\n     */\n    vaultExists(vaultName) {\n        const path = path_1.default.join(this.polykeyPath, vaultName);\n        const vaultExists = this.fileSystem.existsSync(path);\n        return vaultExists;\n    }\n    /**\n     * [WARNING] Destroys a certain vault and all its secrets\n     * @param vaultName Name of vault to be destroyed\n     */\n    destroyVault(vaultName) {\n        // this is convenience function for removing all tags\n        // and triggering garbage collection\n        // destruction is a better word as we should ensure all traces is removed\n        const path = path_1.default.join(this.polykeyPath, vaultName);\n        // Remove directory on file system\n        if (this.fileSystem.existsSync(path)) {\n            this.fileSystem.rmdirSync(path, { recursive: true });\n        }\n        // Remove from maps\n        this.vaults.delete(vaultName);\n        this.vaultKeys.delete(vaultName);\n        // Write to metadata file\n        this.writeMetadata();\n        const vaultPathExists = this.fileSystem.existsSync(path);\n        if (vaultPathExists) {\n            throw new Error('Vault folder could not be destroyed!');\n        }\n    }\n    /**\n     * List the names of all vaults in memory\n     */\n    listVaults() {\n        return Array.from(this.vaults.keys());\n    }\n    /* ============ HELPERS =============== */\n    validateVault(vaultName) {\n        if (!this.vaults.has(vaultName)) {\n            throw Error('Vault does not exist in memory');\n        }\n        if (!this.vaultKeys.has(vaultName)) {\n            throw Error('Vault key does not exist in memory');\n        }\n        const vaultPath = path_1.default.join(this.polykeyPath, vaultName);\n        if (!this.fileSystem.existsSync(vaultPath)) {\n            throw Error('Vault directory does not exist');\n        }\n    }\n    async writeMetadata() {\n        const metadata = JSON.stringify([...this.vaultKeys]);\n        const encryptedMetadata = await this.keyManager.encryptData(Buffer.from(metadata));\n        await this.fileSystem.promises.writeFile(this.metadataPath, encryptedMetadata);\n    }\n    async loadMetadata() {\n        // Check if file exists\n        if (this.fileSystem.existsSync(this.metadataPath) && this.keyManager.identityLoaded) {\n            const encryptedMetadata = this.fileSystem.readFileSync(this.metadataPath);\n            const metadata = (await this.keyManager.decryptData(encryptedMetadata)).toString();\n            for (const [key, value] of new Map(JSON.parse(metadata))) {\n                this.vaultKeys[key] = Buffer.from(value);\n            }\n        }\n    }\n}\nexports.default = VaultManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst isomorphic_git_1 = __importDefault(require(\"isomorphic-git\"));\nconst encryptedfs_1 = require(\"encryptedfs\");\nclass Vault {\n    constructor(name, symKey, baseDir) {\n        // how do we create pub/priv key pair?\n        // do we use the same gpg pub/priv keypair\n        this.key = symKey;\n        this.keyLen = symKey.length;\n        // Set filesystem\n        const vfsInstance = new (require('virtualfs')).VirtualFS;\n        this.efs = new encryptedfs_1.EncryptedFS(this.key, vfsInstance, vfsInstance, fs_1.default, process);\n        this.name = name;\n        this.vaultPath = path_1.default.join(baseDir, name);\n        // make the vault directory\n        this.efs.mkdirSync(this.vaultPath, { recursive: true });\n        this.secrets = new Map();\n        this.loadSecrets();\n        // Load metadata\n        this.metadataPath = path_1.default.join(this.vaultPath, '.vault', 'metadata');\n        this.loadMetadata();\n    }\n    /**\n     * Returns the Encrypted File System used for vault operations\n     */\n    get EncryptedFS() {\n        return this.efs;\n    }\n    /**\n     * Determines whether a secret exists in the vault\n     * @param secretName Name of desired secret\n     */\n    secretExists(secretName) {\n        const secretPath = path_1.default.join(this.vaultPath, secretName);\n        return this.secrets.has(secretName) && this.efs.existsSync(secretPath);\n    }\n    /**\n     * Adds a secret to the vault\n     * @param secretName Name of new secret\n     * @param secret Content of new secret\n     */\n    async addSecret(secretName, secret) {\n        // Check if secret already exists\n        if (this.secrets.has(secretName)) {\n            throw new Error('Secret already exists, try updating it instead.');\n        }\n        const writePath = path_1.default.join(this.vaultPath, secretName);\n        // Write secret\n        await this.efs.promises.writeFile(writePath, secret, {});\n        // Update secrets map\n        this.secrets.set(secretName, secret);\n        // Auto commit message\n        await this.commitChanges(`Add secret: ${secretName}`, secretName, 'added');\n    }\n    /**\n     * Updates a secret in the vault\n     * @param secretName Name of secret to be updated\n     * @param secret Content of updated secret\n     */\n    async updateSecret(secretName, secret) {\n        // Check if secret already exists\n        if (!this.secrets.has(secretName)) {\n            throw new Error('Secret does not exist, try adding it instead.');\n        }\n        const writePath = path_1.default.join(this.vaultPath, secretName);\n        // Write secret\n        await this.efs.promises.writeFile(writePath, secret, {});\n        // Update secrets map\n        this.secrets.set(secretName, secret);\n        // Auto commit message\n        await this.commitChanges(`Update secret: ${secretName}`, secretName, 'modified');\n    }\n    /**\n     * Get a secret from the vault\n     * @param secretName Name of secret to be retrieved\n     */\n    getSecret(secretName) {\n        if (this.secrets.has(secretName)) {\n            const secret = this.secrets.get(secretName);\n            if (secret) {\n                return secret;\n            }\n            else {\n                const secretPath = path_1.default.join(this.vaultPath, secretName);\n                // TODO: this should be async\n                const secretBuf = this.efs.readFileSync(secretPath, {});\n                this.secrets.set(secretName, secretBuf);\n                return secretBuf;\n            }\n        }\n        throw Error('Secret: ' + secretName + ' does not exist');\n    }\n    /**\n     * [WARNING] Removes a secret from the vault\n     * @param secretName Name of secret to be removed\n     */\n    async removeSecret(secretName) {\n        if (this.secrets.has(secretName)) {\n            const successful = this.secrets.delete(secretName);\n            // Remove from fs\n            await this.efs.promises.unlink(path_1.default.join(this.vaultPath, secretName));\n            // Auto commit message\n            await this.commitChanges(`Remove secret: ${secretName}`, secretName, 'removed');\n            if (successful) {\n                return;\n            }\n            throw Error('Secret: ' + secretName + ' was not removed');\n        }\n        throw Error('Secret: ' + secretName + ' does not exist');\n    }\n    /**\n     * Lists all the secrets currently in the vault\n     */\n    listSecrets() {\n        let secrets = Array.from(this.secrets.keys());\n        return secrets;\n    }\n    tagVault() {\n    }\n    untagVault() {\n    }\n    /////////////\n    // Sharing //\n    /////////////\n    /**\n     * Allows a particular public key to access the vault\n     * @param publicKey Public key to share with\n     */\n    shareVault(publicKey) {\n        if (this.sharedPubKeys.has(name)) {\n            throw new Error('Vault is already shared with given public key');\n        }\n        this.sharedPubKeys.add(publicKey);\n        // Write metadata\n        this.writeMetadata();\n    }\n    /**\n     * Removes access to the vault for a particular public key\n     * @param publicKey Public key to unshare with\n     */\n    unshareVault(publicKey) {\n        if (!this.sharedPubKeys.has(publicKey)) {\n            throw new Error('Vault is not shared with given public key');\n        }\n        this.sharedPubKeys.delete(publicKey);\n        // Write metadata\n        this.writeMetadata();\n    }\n    /**\n     * Determines if a particular public key can access the vault\n     * @param publicKey Public key to check\n     */\n    peerCanAccess(publicKey) {\n        // return this.sharedPubKeys.has(publicKey)\n        return true;\n    }\n    /**\n     * Pulls the vault from a specific address\n     * @param address Address of polykey node that owns vault to be pulled\n     * @param getSocket Function to get an active connection to provided address\n     */\n    async pullVault(gitClient) {\n        // Strangely enough this is needed for pulls along with ref set to 'HEAD'\n        // In isogit's documentation, this is just to get the currentBranch name\n        // But it solves a bug whereby if not used, git.pull complains that it can't\n        // find the master branch or HEAD\n        await isomorphic_git_1.default.currentBranch({\n            fs: { promises: this.efs.promises },\n            dir: this.vaultPath,\n            fullname: true\n        });\n        // First pull\n        await isomorphic_git_1.default.pull({\n            fs: { promises: this.efs.promises },\n            http: gitClient,\n            dir: this.vaultPath,\n            url: \"http://\" + '0.0.0.0:0' + '/' + this.name,\n            ref: 'HEAD',\n            singleBranch: true,\n            author: {\n                name: this.name\n            }\n        });\n        // Load any new secrets\n        this.loadSecrets();\n    }\n    /**\n     * Initializes the git repository for new vaults\n     */\n    async initRepository() {\n        const fileSystem = this.efs;\n        await isomorphic_git_1.default.init({\n            fs: fileSystem,\n            dir: this.vaultPath\n        });\n        // Initial commit\n        await isomorphic_git_1.default.commit({\n            fs: fileSystem,\n            dir: this.vaultPath,\n            author: {\n                name: this.name\n            },\n            message: \"init commit\"\n        });\n        // Write packed-refs file because isomorphic git goes searching for it\n        // and apparently its not autogenerated\n        this.efs.writeFileSync(path_1.default.join(this.vaultPath, '.git', 'packed-refs'), '# pack-refs with: peeled fully-peeled sorted');\n    }\n    // ============== Helper methods ============== //\n    writeMetadata() {\n        // mkdir first\n        this.efs.mkdirSync(path_1.default.dirname(this.metadataPath), { recursive: true });\n        // Create and write metadata\n        const metadata = {\n            sharedPubKeys: Array.from(this.sharedPubKeys.keys())\n        };\n        this.efs.writeFileSync(this.metadataPath, JSON.stringify(metadata));\n    }\n    loadMetadata() {\n        if (this.efs.existsSync(this.metadataPath)) {\n            const fileContents = this.efs.readFileSync(this.metadataPath).toString();\n            const metadata = JSON.parse(fileContents);\n            this.sharedPubKeys = new Set(metadata.sharedPubKeys);\n        }\n        else {\n            // Need to create it\n            this.sharedPubKeys = new Set();\n            this.writeMetadata();\n        }\n    }\n    async commitChanges(message, secretName, action) {\n        if (action == 'removed') {\n            await isomorphic_git_1.default.remove({\n                fs: this.efs,\n                dir: this.vaultPath,\n                filepath: secretName\n            });\n        }\n        else {\n            await isomorphic_git_1.default.add({\n                fs: this.efs,\n                dir: this.vaultPath,\n                filepath: secretName\n            });\n        }\n        return await isomorphic_git_1.default.commit({\n            fs: this.efs,\n            dir: this.vaultPath,\n            author: {\n                name: this.name\n            },\n            message: message\n        });\n    }\n    loadSecrets() {\n        const secrets = fs_1.default.readdirSync(this.vaultPath, undefined);\n        for (const secret of secrets.filter((s) => s[0] != '.')) {\n            this.secrets.set(secret, null);\n        }\n    }\n}\nexports.default = Vault;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os_1 = __importDefault(require(\"os\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst net_1 = __importDefault(require(\"net\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst process_1 = __importDefault(require(\"process\"));\nconst child_process_1 = require(\"child_process\");\nconst Polykey_1 = __importStar(require(\"../Polykey\"));\nconst configstore_1 = __importDefault(require(\"configstore\"));\nconst PolykeyClient_1 = __importDefault(require(\"./PolykeyClient\"));\nconst Agent_1 = require(\"../../../proto/js/Agent\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst { AgentMessage, CreateSecretRequestMessage, CreateSecretResponseMessage, DeriveKeyRequestMessage, DeriveKeyResponseMessage, DestroySecretRequestMessage, DestroySecretResponseMessage, DestroyVaultRequestMessage, DestroyVaultResponseMessage, ErrorMessage, GetSecretRequestMessage, GetSecretResponseMessage, ListNodesRequestMessage, ListNodesResponseMessage, ListSecretsRequestMessage, ListSecretsResponseMessage, ListVaultsRequestMessage, ListVaultsResponseMessage, NewNodeRequestMessage, NewNodeResponseMessage, NewVaultRequestMessage, NewVaultResponseMessage, RegisterNodeRequestMessage, RegisterNodeResponseMessage, SignFileRequestMessage, SignFileResponseMessage, Type, VerifyFileRequestMessage, VerifyFileResponseMessage } = Agent_1.agent;\nclass PolykeyAgent {\n    constructor() {\n        this.persistentStore = new configstore_1.default('polykey');\n        // For storing the state of each polykey node\n        // Keys are the paths to the polykey node, e.g. '~/.polykey'\n        this.polykeyMap = new Map();\n        this.socketPath = PolykeyAgent.SocketPath;\n        // Make sure the socket file doesn't already exist (agent is already running)\n        if (fs_1.default.existsSync(this.socketPath)) {\n            fs_1.default.unlinkSync(this.socketPath);\n        }\n        // Make the socket path if it doesn't exist\n        if (!fs_1.default.existsSync(path_1.default.dirname(this.socketPath))) {\n            fs_1.default.promises.mkdir(path_1.default.dirname(this.socketPath));\n        }\n        // Load polykeys\n        const nodePaths = this.persistentStore.get('nodePaths');\n        if (nodePaths) {\n            for (const path of nodePaths) {\n                if (fs_1.default.existsSync(path)) {\n                    this.polykeyMap.set(path, new Polykey_1.default(path, fs_1.default));\n                }\n                else {\n                    this.removeFromNodePaths(path);\n                }\n            }\n        }\n        else {\n            this.persistentStore.set('nodePaths', []);\n        }\n        // Start the server\n        this.server = net_1.default.createServer().listen(this.socketPath);\n        this.server.on('connection', (socket) => {\n            this.handleClientCommunication(socket);\n        });\n    }\n    get AllNodePaths() {\n        return Array.from(this.polykeyMap.keys()).filter((nodePath) => {\n            try {\n                this.getPolykey(nodePath);\n                return true;\n            }\n            catch (_a) {\n                return false;\n            }\n        });\n    }\n    get UnlockedNodePaths() {\n        return this.AllNodePaths.filter((nodePath) => {\n            try {\n                return this.getPolykey(nodePath).keyManager.identityLoaded;\n            }\n            catch (_a) {\n                return false;\n            }\n        });\n    }\n    stop() {\n        this.server.close();\n    }\n    addToNodePaths(nodePath, pk) {\n        this.polykeyMap.set(nodePath, pk);\n        const nodePathSet = new Set(this.persistentStore.get('nodePaths'));\n        nodePathSet.add(nodePath);\n        this.persistentStore.set('nodePaths', Array.from(nodePathSet.values()));\n    }\n    removeFromNodePaths(nodePath) {\n        this.polykeyMap.delete(nodePath);\n        const nodePathSet = new Set(this.persistentStore.get('nodePaths'));\n        nodePathSet.delete(nodePath);\n        this.persistentStore.set('nodePaths', Array.from(nodePathSet.values()));\n    }\n    handleClientCommunication(socket) {\n        socket.on('data', async (encodedMessage) => {\n            var _a;\n            try {\n                const { type, nodePath, subMessage } = AgentMessage.decode(encodedMessage);\n                let response = undefined;\n                switch (type) {\n                    case Type.STATUS:\n                        response = Buffer.from('online');\n                        break;\n                    case Type.STOP_AGENT:\n                        this.stop();\n                        process_1.default.exit();\n                    case Type.REGISTER_NODE:\n                        response = await this.registerNode(nodePath, subMessage);\n                        break;\n                    case Type.NEW_NODE:\n                        response = await this.newNode(nodePath, subMessage);\n                        break;\n                    case Type.LIST_NODES:\n                        response = this.listNodes(subMessage);\n                        break;\n                    case Type.DERIVE_KEY:\n                        response = await this.deriveKey(nodePath, subMessage);\n                        break;\n                    case Type.SIGN_FILE:\n                        response = await this.signFile(nodePath, subMessage);\n                        break;\n                    case Type.VERIFY_FILE:\n                        response = await this.verifyFile(nodePath, subMessage);\n                        break;\n                    case Type.LIST_VAULTS:\n                        response = await this.listVaults(nodePath);\n                        break;\n                    case Type.NEW_VAULT:\n                        response = await this.newVault(nodePath, subMessage);\n                        break;\n                    case Type.DESTROY_VAULT:\n                        response = await this.destroyVault(nodePath, subMessage);\n                        break;\n                    case Type.LIST_SECRETS:\n                        response = await this.listSecrets(nodePath, subMessage);\n                        break;\n                    case Type.CREATE_SECRET:\n                        response = await this.createSecret(nodePath, subMessage);\n                        break;\n                    case Type.DESTROY_SECRET:\n                        response = await this.destroySecret(nodePath, subMessage);\n                        break;\n                    case Type.GET_SECRET:\n                        response = await this.getSecret(nodePath, subMessage);\n                        break;\n                    default:\n                        throw Error(`message type not supported: ${type}`);\n                }\n                if (response) {\n                    const encodedResponse = AgentMessage.encode({ type: type, isResponse: true, nodePath: nodePath, subMessage: response }).finish();\n                    socket.write(encodedResponse);\n                }\n                else {\n                    throw Error('something went wrong');\n                }\n            }\n            catch (err) {\n                const errorResponse = AgentMessage.encode({ type: Type.ERROR, isResponse: true, nodePath: undefined, subMessage: ErrorMessage.encode({ error: (_a = err.message) !== null && _a !== void 0 ? _a : err }).finish() }).finish();\n                socket.write(errorResponse);\n            }\n            // Close connection\n            socket.end();\n        });\n    }\n    // Register an existing polykey agent\n    async registerNode(nodePath, request) {\n        const { passphrase } = RegisterNodeRequestMessage.decode(request);\n        let pk = this.polykeyMap.get(nodePath);\n        if (pk) {\n            if (pk.keyManager.identityLoaded) {\n                throw Error(`node path is already loaded and unlocked: '${nodePath}'`);\n            }\n            await pk.keyManager.unlockIdentity(passphrase);\n        }\n        else {\n            const km = new Polykey_1.KeyManager(nodePath, fs_1.default);\n            await km.unlockIdentity(passphrase);\n            // Create polykey class\n            pk = new Polykey_1.default(nodePath, fs_1.default, km);\n        }\n        // Set polykey class\n        this.addToNodePaths(nodePath, pk);\n        // Encode and send response\n        const response = NewNodeResponseMessage.encode({ successful: pk.keyManager.identityLoaded && this.polykeyMap.has(nodePath) }).finish();\n        return response;\n    }\n    // Create a new polykey agent\n    async newNode(nodePath, request) {\n        // Throw if path already exists\n        if (this.polykeyMap.has(nodePath) && fs_1.default.existsSync(nodePath)) {\n            throw Error(`node path '${nodePath}' is already loaded`);\n        }\n        else if (fs_1.default.existsSync(nodePath)) {\n            throw Error(`node path already exists: '${nodePath}'`);\n        }\n        const { name, email, passphrase, nbits } = NewNodeRequestMessage.decode(request);\n        const km = new Polykey_1.KeyManager(nodePath, fs_1.default);\n        await km.generateKeyPair(name, email, passphrase, (nbits == 0) ? undefined : nbits, true, (info) => {\n            // socket.write(JSON.stringify(info))\n        });\n        // Create and set polykey class\n        const pk = new Polykey_1.default(nodePath, fs_1.default, km);\n        this.addToNodePaths(nodePath, pk);\n        // Encode and send response\n        const response = NewNodeResponseMessage.encode({ successful: km.identityLoaded && this.polykeyMap.has(nodePath) }).finish();\n        return response;\n    }\n    // Create a new polykey agent\n    listNodes(request) {\n        const { unlockedOnly } = ListNodesRequestMessage.decode(request);\n        if (unlockedOnly) {\n            return ListNodesResponseMessage.encode({ nodes: this.UnlockedNodePaths }).finish();\n        }\n        else {\n            return ListNodesResponseMessage.encode({ nodes: this.AllNodePaths }).finish();\n        }\n    }\n    getPolykey(nodePath) {\n        var _a;\n        if (this.polykeyMap.has(nodePath)) {\n            return this.polykeyMap.get(nodePath);\n        }\n        else if (fs_1.default.existsSync(nodePath)) {\n            throw Error(`polykey node has not been loaded yet: '${nodePath}'`);\n        }\n        else {\n            const nodePathList = new Set((_a = this.persistentStore.get('nodePaths')) !== null && _a !== void 0 ? _a : []);\n            nodePathList.delete(nodePath);\n            this.persistentStore.set('nodePaths', nodePathList);\n            throw Error(`node path does not exist: '${nodePath}'`);\n        }\n    }\n    /////////////////////////\n    // KeyManager commands //\n    /////////////////////////\n    async deriveKey(nodePath, request) {\n        const { keyName, passphrase } = DeriveKeyRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        await pk.keyManager.generateKey(keyName, passphrase);\n        return DeriveKeyResponseMessage.encode({ successful: true }).finish();\n    }\n    /////////////////////\n    // Crypto commands //\n    /////////////////////\n    async signFile(nodePath, request) {\n        const { filePath, privateKeyPath, passphrase } = SignFileRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        const signaturePath = await pk.keyManager.signFile(filePath, privateKeyPath, passphrase);\n        return SignFileResponseMessage.encode({ signaturePath }).finish();\n    }\n    async verifyFile(nodePath, request) {\n        const { filePath, signaturePath } = VerifyFileRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        const verified = await pk.keyManager.verifyFile(filePath, signaturePath);\n        return VerifyFileResponseMessage.encode({ verified }).finish();\n    }\n    //////////////////////\n    // Vault Operations //\n    //////////////////////\n    async listVaults(nodePath) {\n        const pk = this.getPolykey(nodePath);\n        const vaultNames = pk.vaultManager.listVaults();\n        return ListVaultsResponseMessage.encode({ vaultNames }).finish();\n    }\n    async newVault(nodePath, request) {\n        const { vaultName } = NewVaultRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        await pk.vaultManager.createVault(vaultName);\n        return NewVaultResponseMessage.encode({ successful: true }).finish();\n    }\n    async destroyVault(nodePath, request) {\n        const { vaultName } = DestroyVaultRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        pk.vaultManager.destroyVault(vaultName);\n        return DestroyVaultResponseMessage.encode({ successful: true }).finish();\n    }\n    ///////////////////////\n    // Secret Operations //\n    ///////////////////////\n    async listSecrets(nodePath, request) {\n        const { vaultName } = ListSecretsRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        const vault = pk.vaultManager.getVault(vaultName);\n        const secretNames = vault.listSecrets();\n        return ListSecretsResponseMessage.encode({ secretNames }).finish();\n    }\n    async createSecret(nodePath, request) {\n        const { vaultName, secretName, secretPath } = CreateSecretRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        const vault = pk.vaultManager.getVault(vaultName);\n        const secret = await fs_1.default.promises.readFile(secretPath);\n        await vault.addSecret(secretName, secret);\n        return CreateSecretResponseMessage.encode({ successful: true }).finish();\n    }\n    async destroySecret(nodePath, request) {\n        const { vaultName, secretName } = DestroySecretRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        const vault = pk.vaultManager.getVault(vaultName);\n        await vault.removeSecret(secretName);\n        return DestroySecretResponseMessage.encode({ successful: true }).finish();\n    }\n    async getSecret(nodePath, request) {\n        const { vaultName, secretName } = GetSecretRequestMessage.decode(request);\n        const pk = this.getPolykey(nodePath);\n        const vault = pk.vaultManager.getVault(vaultName);\n        const secret = Buffer.from(vault.getSecret(secretName));\n        return GetSecretResponseMessage.encode({ secret: secret }).finish();\n    }\n    ///////////////////////\n    // Client Connection //\n    ///////////////////////\n    static connectToAgent(getStream) {\n        const defaultStream = () => {\n            const passThrough = new readable_stream_1.PassThrough();\n            const socket = net_1.default.createConnection(PolykeyAgent.SocketPath);\n            socket.pipe(passThrough);\n            passThrough.pipe(socket);\n            return passThrough;\n        };\n        const client = new PolykeyClient_1.default(getStream !== null && getStream !== void 0 ? getStream : defaultStream);\n        // if (checkStatus) {\n        //   const status = await client.getAgentStatus()\n        //   if (status != 'online') {\n        //     throw Error(`agent status is: ${status}, restart with 'pk agent start'`)\n        //   }\n        // }\n        return client;\n    }\n    // ===== Helper methods===== //\n    static get SocketPath() {\n        const platform = os_1.default.platform();\n        const userInfo = os_1.default.userInfo();\n        if (platform == 'win32') {\n            return path_1.default.join('\\\\\\\\?\\\\pipe', process_1.default.cwd(), 'polykey-agent');\n        }\n        else {\n            return `/run/user/${userInfo.uid}/polykey/S.polykey-agent`;\n        }\n    }\n    static get LogPath() {\n        const platform = os_1.default.platform();\n        const userInfo = os_1.default.userInfo();\n        if (platform == 'win32') {\n            return path_1.default.join(os_1.default.tmpdir(), 'polykey', 'log');\n        }\n        else {\n            return `/run/user/${userInfo.uid}/polykey/log`;\n        }\n    }\n    static async startAgent(daemon = false) {\n        return new Promise((resolve, reject) => {\n            try {\n                let options = {\n                    uid: process_1.default.getuid(),\n                    detached: daemon\n                };\n                if (daemon) {\n                    fs_1.default.rmdirSync(PolykeyAgent.LogPath, { recursive: true });\n                    fs_1.default.mkdirSync(PolykeyAgent.LogPath, { recursive: true });\n                    options.stdio = [\n                        'ipc',\n                        fs_1.default.openSync(path_1.default.join(PolykeyAgent.LogPath, 'output.log'), 'a'),\n                        fs_1.default.openSync(path_1.default.join(PolykeyAgent.LogPath, 'error.log'), 'a'), ,\n                    ];\n                }\n                const agentProcess = child_process_1.fork(PolykeyAgent.DAEMON_SCRIPT_PATH, undefined, options);\n                const pid = agentProcess.pid;\n                agentProcess.unref();\n                resolve(pid);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    }\n}\n//////////////////////\n// Agent Operations //\n//////////////////////\nPolykeyAgent.DAEMON_SCRIPT_PATH = path_1.default.join(__dirname, 'internal', 'daemon-script.js');\nexports.default = PolykeyAgent;\n","module.exports = require(\"net\");","module.exports = require(\"process\");","module.exports = require(\"child_process\");","module.exports = require(\"configstore\");"],"sourceRoot":""}