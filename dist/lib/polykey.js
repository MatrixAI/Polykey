!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.polykey=t():e.polykey=t()}(this,(function(){return function(e){var t={};function s(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,s),a.l=!0,a.exports}return s.m=e,s.c=t,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)s.d(r,a,function(t){return e[t]}.bind(null,a));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=4)}([function(e,t){e.exports=require("path")},function(e,t){e.exports=require("os")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("readable-stream")},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(1)),i=r(s(20));t.KeyManager=i.default;const n=r(s(23));t.PeerManager=n.default;const o=r(s(43));t.VaultManager=o.default;const c=r(s(45));t.PolykeyAgent=c.default;const u=r(s(18));t.PolykeyClient=u.default;t.default=class{constructor(e=a.default.homedir()+"/.polykey",t,s,r,c){this.polykeyPath=e,this.keyManager=null!=s?s:new i.default(this.polykeyPath,t),this.vaultManager=null!=r?r:new o.default(this.polykeyPath,t,this.keyManager),this.peerManager=null!=c?c:new n.default(this.polykeyPath,t,this.keyManager,this.vaultManager)}}},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("@grpc/grpc-js")},function(e,t){e.exports=require("../../proto/compiled/Git_grpc_pb")},function(e,t){e.exports=require("../../proto/compiled/Git_pb")},function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{static flush(){return Buffer.from("0000","utf8")}static encode(e){"string"==typeof e&&(e=Buffer.from(e));const t=function(e,t){const s=t.toString(16);return"0".repeat(e-s.length)+s}(4,e.length+4);return Buffer.concat([Buffer.from(t,"utf8"),e])}static streamReader(e){return async function(){try{let t=await e.slice(4);if(null===t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;let s=await e.slice(t-4);return null===s||s}catch(e){return console.log("error",e),!0}}}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(0)),i=r(s(27));function n(e,t){const s=e.replace(/\^\{\}$/,""),r=t.replace(/\^\{\}$/,""),a=-(s<r)||+(s>r);return 0===a?e.endsWith("^{}")?1:-1:a}const o=["config","description","index","shallow","commondir"];class c{static async packedRefs(e,t){const s=e.readFileSync(t+"/packed-refs",{encoding:"utf8"});return i.default.from(s).refs}static async listRefs(e,t,s){const r=c.packedRefs(e,t);let i=[];try{i=await async function e(t,s){return new Promise((r,i)=>{let n=[];s.promises.readdir(t).then(async i=>{var o=i.length;if(!o)return r(n);i.forEach((async function(i){i=a.default.resolve(t,i),s.promises.stat(i).then(async t=>{if(t&&t.isDirectory()){const t=await e(i,s);n=n.concat(t),--o||r(n)}else n.push(i),--o||r(n)})}))}).catch(e=>{if(e)return i(e)})})}(`${t}/${s}`,e),i=i.map(e=>e.replace(`${t}/${s}/`,""))}catch(e){i=[]}for(let e of(await r).keys())e.startsWith(s)&&(e=e.replace(s+"/",""),i.includes(e)||i.push(e));return i.sort(n),i}static async resolve(e,t,s,r){if(void 0!==r&&-1===--r)return s;if(s.startsWith("ref: "))return s=s.slice("ref: ".length),c.resolve(e,t,s,r);if(40===s.length&&/[0-9a-f]{40}/.test(s))return s;const a=await c.packedRefs(e,t),i=(e=>[""+e,"refs/"+e,"refs/tags/"+e,"refs/heads/"+e,"refs/remotes/"+e,`refs/remotes/${e}/HEAD`])(s).filter(e=>!o.includes(e));for(const s of i){const i=e.readFileSync(`${t}/${s}`,{encoding:"utf8"}).toString()||a.get(s);if(i)return c.resolve(e,t,i.trim(),r)}throw Error("RefNotFound")}}t.default=c},function(e,t){e.exports=require("pako")},function(e,t,s){"use strict";function r(e){return 0===e?e:-e}function a(e){let t=(s=r(e),Math.sign(s)||(Object.is(s,-0)?-1:1));var s;e=Math.abs(e);let a=Math.floor(e/60);e-=60*a;let i=String(a),n=String(e);return i.length<2&&(i="0"+i),n.length<2&&(n="0"+n),(-1===t?"-":"+")+i+n}function i(e){let[,t,s,a]=e.match(/(\+|-)(\d\d)(\d\d)/);return a=("+"===t?1:-1)*(60*Number(s)+Number(a)),r(a)}function n(e){let[,t,s,r,a]=e.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:s,timestamp:Number(r),timezoneOffset:i(a)}}function o(e){return e=(e=(e=e.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function c(e){return e.trim().split("\n").map(e=>" "+e).join("\n")+"\n"}Object.defineProperty(t,"__esModule",{value:!0});class u{constructor(e){if("string"==typeof e)this._commit=e;else if(Buffer.isBuffer(e))this._commit=e.toString("utf8");else{if("object"!=typeof e)throw new Error("invalid type passed to GitCommit constructor");this._commit=u.render(e)}}static fromPayloadSignature({payload:e,signature:t}){let s=u.justHeaders(e),r=u.justMessage(e),a=o(s+"\ngpgsig"+c(t)+"\n"+r);return new u(a)}static from(e){return new u(e)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return u.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(e){return o(e.slice(e.indexOf("\n\n")+2))}static justHeaders(e){return e.slice(0,e.indexOf("\n\n"))}parseHeaders(){let e=u.justHeaders(this._commit).split("\n"),t=[];for(let s of e)" "===s[0]?t[t.length-1]+="\n"+s.slice(1):t.push(s);let s={parent:[]};for(let e of t){let t=e.slice(0,e.indexOf(" ")),r=e.slice(e.indexOf(" ")+1);Array.isArray(s[t])?s[t].push(r):s[t]=r}return s.author&&(s.author=n(s.author)),s.committer&&(s.committer=n(s.committer)),s}static renderHeaders(e){let t="";if(e.tree?t+=`tree ${e.tree}\n`:t+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",e.parent){if(void 0===e.parent.length)throw new Error("commit 'parent' property should be an array");for(let s of e.parent)t+=`parent ${s}\n`}let s=e.author;t+=`author ${s.name} <${s.email}> ${s.timestamp} ${a(s.timezoneOffset)}\n`;let r=e.committer||e.author;return t+=`committer ${r.name} <${r.email}> ${r.timestamp} ${a(r.timezoneOffset)}\n`,e.gpgsig&&(t+="gpgsig"+c(e.gpgsig)),t}static render(e){return u.renderHeaders(e)+"\n"+o(e.message)}render(){return this._commit}withoutSignature(){let e=o(this._commit);return-1===e.indexOf("\ngpgsig")?e:o(e.slice(0,e.indexOf("\ngpgsig"))+"\n"+e.slice(e.indexOf("-----END PGP SIGNATURE-----\n")+"-----END PGP SIGNATURE-----\n".length))}isolateSignature(){let e=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length);return e.split("\n").map(e=>e.replace(/^ /,"")).join("\n")}}t.default=u},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(2)),i=r(s(11)),n=r(s(0)),o=r(s(32)),c=new Map;class u{static async read(e,t,s,r="content"){let l=e.readFileSync(`${t}/objects/${s.slice(0,2)}/${s.slice(2)}`),d=`./objects/${s.slice(0,2)}/${s.slice(2)}`;if(!l){const r=s=>u.read(e,t,s);let i=a.default.readdirSync(n.default.join(t,"/objects/pack"));i=i.filter(e=>e.endsWith(".pack"));for(let a of i){let i=c.get(a);if(i.offsets.has(s)){if(!i.pack){const s=e.readFileSync(`${t}/objects/pack/${a}`);await i.load({pack:s})}let n=await i.read({oid:s,getExternalRefDelta:r});return n.source="./objects/pack/"+a,n}}}if(!l){let r=e.readFileSync(t+"/shallow",{encoding:"utf8"});if(null!==r&&r.includes(s))throw new Error("ReadShallowObjectFail: "+s)}if(!l)throw new Error("ReadObjectFail: "+s);if("deflated"===r)return{format:"deflated",object:l,source:d};let f=Buffer.from(i.default.inflate(l));if("wrapped"===r)return{format:"wrapped",object:f,source:d};let{type:h,object:y}=o.default.unwrap({oid:s,buffer:f});return"content"===r?{type:h,format:"content",object:y,source:d}:void 0}}t.default=u},function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(e,t){this.ip=e,this.port=t}static parse(e){const t=e.split(":"),s=t[0],a=t[1];return new r(s,a)}static fromAddressInfo(e){const t="::"==e.address?"localhost":e.address;return new r(t,e.port.toString())}toString(){return`${this.ip}:${this.port}`}}t.Address=r,r.prototype.toString=function(){return`${this.ip}:${this.port}`};t.default=class{constructor(e,t=[],s){this.publicKey=e,this.addresses=new Set(t.map(e=>r.parse(e))),this.connectedAddr=s?r.parse(s):void 0}connect(e){this.addresses.has(e)||this.addresses.add(e),this.connectedAddr=e}disconnect(){this.connectedAddr=void 0}get AdressStringList(){return Array.from(this.addresses.values()).map(e=>e.toString())}}},function(e,t){e.exports=require("isomorphic-git")},function(e,t){e.exports=require("encryptedfs")},function(e,t){e.exports=require("virtualfs")},function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=s(19),{AgentMessage:a,CreateSecretRequestMessage:i,CreateSecretResponseMessage:n,DeriveKeyRequestMessage:o,DeriveKeyResponseMessage:c,DestroySecretRequestMessage:u,DestroySecretResponseMessage:l,DestroyVaultRequestMessage:d,DestroyVaultResponseMessage:f,ErrorMessage:h,GetSecretRequestMessage:y,GetSecretResponseMessage:p,ListNodesRequestMessage:m,ListNodesResponseMessage:g,ListSecretsRequestMessage:w,ListSecretsResponseMessage:P,ListVaultsRequestMessage:S,ListVaultsResponseMessage:v,NewNodeRequestMessage:k,NewNodeResponseMessage:b,NewVaultRequestMessage:M,NewVaultResponseMessage:_,RegisterNodeRequestMessage:E,RegisterNodeResponseMessage:K,SignFileRequestMessage:R,SignFileResponseMessage:x,Type:j,VerifyFileRequestMessage:I,VerifyFileResponseMessage:A}=r.agent;t.default=class{constructor(e){this.getStream=e}async sendRequestToAgent(e){const t=this.getStream(),s=await new Promise((s,r)=>{try{const a=[];t.on("data",e=>{a.push(e)}),t.on("error",e=>{r(e)}),t.on("end",()=>{s(a)}),t.write(e)}catch(e){r(e)}});return t.end(),s}async handleAgentCommunication(e,t,s){const r=a.encode({type:e,isResponse:!1,nodePath:t,subMessage:s}).finish(),i=await this.sendRequestToAgent(r),n=[];for(const e of i){const{subMessage:t,type:s}=a.decode(e);if(s==j.ERROR){const{error:e}=h.decode(t);throw new Error(e)}n.push(a.decode(e))}return n}async registerNode(e,t){const s=E.encode({passphrase:t}).finish(),r=await this.handleAgentCommunication(j.REGISTER_NODE,e,s);if(0==r.length)throw Error("agent did not respond");const{successful:a}=K.decode(r[0].subMessage);return a}async newNode(e,t,s,r,a){const i=k.encode({name:t,email:s,passphrase:r,nbits:a}).finish(),n=await this.handleAgentCommunication(j.NEW_NODE,e,i);if(0==n.length)throw Error("agent did not respond");const{successful:o}=b.decode(n[0].subMessage);return o}async listNodes(e=!0){const t=m.encode({unlockedOnly:e}).finish(),s=await this.handleAgentCommunication(j.LIST_NODES,void 0,t);if(0==s.length)throw Error("agent did not respond");const{nodes:r}=g.decode(s[0].subMessage);return r}async deriveKey(e,t,s){const r=o.encode({keyName:t,passphrase:s}).finish(),a=await this.handleAgentCommunication(j.DERIVE_KEY,e,r);if(0==a.length)throw Error("agent did not respond");const{successful:i}=c.decode(a[0].subMessage);return i}async signFile(e,t,s,r){const a=R.encode({filePath:t,privateKeyPath:s,passphrase:r}).finish(),i=await this.handleAgentCommunication(j.SIGN_FILE,e,a);if(0==i.length)throw Error("agent did not respond");const{signaturePath:n}=x.decode(i[0].subMessage);return n}async verifyFile(e,t,s){const r=I.encode({filePath:t,signaturePath:s}).finish(),a=await this.handleAgentCommunication(j.VERIFY_FILE,e,r);if(0==a.length)throw Error("agent did not respond");const{verified:i}=A.decode(a[0].subMessage);return i}async listVaults(e){const t=await this.handleAgentCommunication(j.LIST_VAULTS,e);if(0==t.length)throw Error("agent did not respond");const{vaultNames:s}=v.decode(t[0].subMessage);return s}async newVault(e,t){const s=M.encode({vaultName:t}).finish(),r=await this.handleAgentCommunication(j.NEW_VAULT,e,s);if(0==r.length)throw Error("agent did not respond");const{successful:a}=_.decode(r[0].subMessage);return a}async destroyVault(e,t){const s=d.encode({vaultName:t}).finish(),r=await this.handleAgentCommunication(j.DESTROY_VAULT,e,s);if(0==r.length)throw Error("agent did not respond");const{successful:a}=f.decode(r[0].subMessage);return a}async listSecrets(e,t){const s=w.encode({vaultName:t}).finish(),r=await this.handleAgentCommunication(j.LIST_SECRETS,e,s);if(0==r.length)throw Error("agent did not respond");const{secretNames:a}=P.decode(r[0].subMessage);return a}async createSecret(e,t,s,r){const a=i.encode({vaultName:t,secretName:s,secretPath:r}).finish(),o=await this.handleAgentCommunication(j.CREATE_SECRET,e,a);if(0==o.length)throw Error("agent did not respond");const{successful:c}=n.decode(o[0].subMessage);return c}async destroySecret(e,t,s){const r=u.encode({vaultName:t,secretName:s}).finish(),a=await this.handleAgentCommunication(j.DESTROY_SECRET,e,r);if(0==a.length)throw Error("agent did not respond");const{successful:i}=l.decode(a[0].subMessage);return i}async getSecret(e,t,s){const r=y.encode({vaultName:t,secretName:s}).finish(),a=await this.handleAgentCommunication(j.GET_SECRET,e,r);if(0==a.length)throw Error("agent did not respond");const{secret:i}=p.decode(a[0].subMessage);return Buffer.from(i)}async getAgentStatus(){try{const e=await this.handleAgentCommunication(j.STATUS);if(0==e.length)throw Error("agent did not respond");return e[0].subMessage.toString()}catch(e){return"stopped"}}async stopAgent(){try{return await this.handleAgentCommunication(j.STOP_AGENT),!0}catch(e){return"online"!=await this.getAgentStatus()}}}},function(e,t){e.exports=require("../../proto/js/Agent")},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(1)),i=r(s(2)),n=r(s(0)),o=r(s(21)),c=r(s(5)),u=s(22);t.default=class{constructor(e=a.default.homedir()+"/.polykey",t,s=!1,r){this.primaryKeyPair={private:null,public:null},this.metadata={privateKeyPath:null,publicKeyPath:null,pkiKeyPath:null,pkiCertPath:null,caCertPath:null},this.pkiInfo={key:null,cert:null,caCert:null},this.useWebWorkers=s,this.workerPool=r,this.derivedKeys=new Map,this.fileSystem=t,this.polykeyPath=e,this.keypairPath=n.default.join(e,".keypair"),this.fileSystem.existsSync(this.keypairPath)||this.fileSystem.mkdirSync(this.keypairPath,{recursive:!0}),this.metadataPath=n.default.join(this.keypairPath,"metadata"),this.loadMetadata(),this.metadata.privateKeyPath&&this.metadata.publicKeyPath&&this.loadKeyPair(this.metadata.publicKeyPath,this.metadata.privateKeyPath),this.metadata.pkiKeyPath&&(this.pkiInfo.key=i.default.readFileSync(this.metadata.pkiKeyPath)),this.metadata.pkiCertPath&&(this.pkiInfo.cert=i.default.readFileSync(this.metadata.pkiCertPath)),this.metadata.caCertPath&&(this.pkiInfo.caCert=i.default.readFileSync(this.metadata.caCertPath)),this.loadPKIInfo(this.pkiInfo.key,this.pkiInfo.cert,this.pkiInfo.caCert,!0)}get identityLoaded(){return!!this.primaryIdentity}async generateKeyPair(e,t,s,r=4096,a=!1,i){if(r<1024)throw new Error("nbits must be greater than 1024 for keypair generation");const c=o.default.const.openpgp,l={asp:i?new o.default.ASP({progress_hook:i}):void 0,userid:`${e} <${t}>`,primary:{nbits:r,flags:c.certify_keys|c.sign_data|c.auth|c.encrypt_comm|c.encrypt_storage,expire_in:0},subkeys:[]},d=await u.promisify(o.default.KeyManager.generate)(l);await u.promisify(d.sign.bind(d))({});const f=await u.promisify(d.export_pgp_public.bind(d))({}),h={private:await u.promisify(d.export_pgp_private.bind(d))({passphrase:s}),public:f};if(a){this.primaryKeyPair=h,this.primaryIdentity=d;const e=n.default.join(this.keypairPath,"private_key"),t=n.default.join(this.keypairPath,"public_key");await this.fileSystem.promises.writeFile(e,h.private),await this.fileSystem.promises.writeFile(t,h.public),this.metadata.privateKeyPath=e,this.metadata.publicKeyPath=t,this.writeMetadata()}return h}getKeyPair(){return this.primaryKeyPair}hasPublicKey(){return!!this.primaryKeyPair.public}getPublicKey(){if(!this.primaryKeyPair.public)throw new Error("Public key does not exist in memory");return this.primaryKeyPair.public}getPrivateKey(){if(!this.primaryKeyPair.private)throw new Error("Private key does not exist in memory");return this.primaryKeyPair.private}loadKeyPair(e,t){this.loadPrivateKey(t),this.loadPublicKey(e)}loadPrivateKey(e){let t;"string"==typeof e?(t=this.fileSystem.readFileSync(e),this.metadata.privateKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.private=t.toString()}loadPublicKey(e){let t;"string"==typeof e?(t=this.fileSystem.readFileSync(e),this.metadata.publicKeyPath=e,this.writeMetadata()):t=e,this.primaryKeyPair.public=t.toString()}async unlockIdentity(e){const t=this.getPublicKey(),s=this.getPrivateKey(),r=await u.promisify(o.default.KeyManager.import_from_armored_pgp)({armored:t});await u.promisify(r.merge_pgp_private.bind(r))({armored:s}),r.is_pgp_locked.bind(r)()&&await u.promisify(r.unlock_pgp.bind(r))({passphrase:e}),this.primaryIdentity=r}exportPrivateKey(e){this.fileSystem.writeFileSync(e,this.primaryKeyPair.private),this.metadata.privateKeyPath=e,this.writeMetadata()}exportPublicKey(e){this.fileSystem.writeFileSync(e,this.primaryKeyPair.public),this.metadata.publicKeyPath=e,this.writeMetadata()}generateKeySync(e,t){const s=c.default.randomBytes(32);return this.derivedKeys[e]=c.default.pbkdf2Sync(t,s,1e4,32,"sha256"),this.derivedKeys[e]}async generateKey(e,t){const s=c.default.randomBytes(32);return this.derivedKeys[e]=await u.promisify(c.default.pbkdf2)(t,s,1e4,32,"sha256"),this.derivedKeys[e]}importKeySync(e,t){this.derivedKeys[e]="string"==typeof t?this.fileSystem.readFileSync(t):t}async importKey(e,t){this.derivedKeys[e]="string"==typeof t?await this.fileSystem.promises.readFile(t):t}exportKeySync(e,t,s){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);s&&this.fileSystem.mkdirSync(n.default.dirname(t),{recursive:!0}),this.fileSystem.writeFileSync(t,this.derivedKeys[e])}async exportKey(e,t,s){if(!this.derivedKeys.has(e))throw Error("There is no key loaded for name: "+e);s&&await this.fileSystem.promises.mkdir(n.default.dirname(t),{recursive:!0}),await this.fileSystem.promises.writeFile(t,this.derivedKeys[e])}async getIdentityFromPublicKey(e){return await u.promisify(o.default.KeyManager.import_from_armored_pgp)({armored:e})}async getIdentityFromPrivateKey(e,t){const s=await u.promisify(o.default.KeyManager.import_from_armored_pgp)({armored:e});return s.is_pgp_locked()&&await u.promisify(s.unlock_pgp)({passphrase:t}),s}async signData(e,t,s){let r;if(t){if(!s)throw new Error("passphrase for private key was not provided");r=await this.getIdentityFromPrivateKey(t,s)}else{if(!this.primaryIdentity)throw new Error("key pair is not loaded");r=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.signData(e,r))}{const t={msg:e.toString(),sign_with:r},s=await u.promisify(o.default.box)(t);return Buffer.from(s)}}async signFile(e,t,s){let r;t&&(r="string"==typeof t?this.fileSystem.readFileSync(t):t);const a=this.fileSystem.readFileSync(e),i=await this.signData(a,r,s),n=e+".sig";return this.fileSystem.writeFileSync(n,i),n}async verifyData(e,t,s){const r=new o.default.keyring.KeyRing;let a;if(s)a=await this.getIdentityFromPublicKey(s);else{if(!this.primaryIdentity)throw new Error("key pair is not loaded");a=this.primaryIdentity}if(r.add_key_manager(a),this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async s=>await s.verifyData(e,t,a))}{const s={armored:t,data:e,keyfetch:r};let a,i=(await u.promisify(o.default.unbox)(s))[0].get_data_signer();return i&&(a=i.get_key_manager()),!!a&&!!a.get_pgp_fingerprint()}}async verifyFile(e,t,s){let r;s&&(r="string"==typeof s?this.fileSystem.readFileSync(s):s);const a=this.fileSystem.readFileSync(e),i=this.fileSystem.readFileSync(t);return await this.verifyData(a,i,r)}async encryptData(e,t){let s;if(t)s=await this.getIdentityFromPublicKey(t);else{if(!this.primaryIdentity)throw new Error("Identity could not be resolved for encrypting");s=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.encryptData(e,s))}{const t={msg:e,encrypt_for:s};return await u.promisify(o.default.box)(t)}}async decryptData(e,t,s){var r=new o.default.keyring.KeyRing;let a;if(t){if(!s)throw new Error("A key passphrase must be supplied if a privateKey is specified");a=await this.getIdentityFromPrivateKey(t,s)}else{if(!this.primaryIdentity)throw Error("no identity available for decrypting");a=this.primaryIdentity}if(this.useWebWorkers&&this.workerPool){return await this.workerPool.queue(async t=>await t.decryptData(e,a))}{r.add_key_manager(a);const t={armored:e.toString(),keyfetch:r},s=await u.promisify(o.default.unbox)(t);return Buffer.from(s[0].toString())}}get PKIInfo(){return this.pkiInfo}loadPKIInfo(e,t,s,r=!1){if(e&&(this.pkiInfo.key=e),t&&(this.pkiInfo.cert=t),s&&(this.pkiInfo.caCert=s),r){const r=n.default.dirname(this.metadataPath);e&&(this.metadata.pkiKeyPath=n.default.join(r,"pki_private_key"),i.default.writeFileSync(this.metadata.pkiKeyPath,e)),t&&(this.metadata.pkiCertPath=n.default.join(r,"pki_cert"),i.default.writeFileSync(this.metadata.pkiCertPath,t)),s&&(this.metadata.caCertPath=n.default.join(r,"ca_cert"),i.default.writeFileSync(this.metadata.caCertPath,s))}}getKey(e){return this.derivedKeys[e]}hasKey(e){return!!this.derivedKeys[e]}writeMetadata(){const e=JSON.stringify(this.metadata);this.fileSystem.writeFileSync(this.metadataPath,e)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath).toString();this.metadata=JSON.parse(e)}}}},function(e,t){e.exports=require("kbpgp")},function(e,t){e.exports=require("util")},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var s in e)Object.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const i=r(s(1)),n=r(s(0)),o=a(s(6)),c=r(s(24)),u=r(s(25)),l=s(37),d=s(38),f=a(s(14)),h=r(s(39)),y=s(7),p=s(8),m={name:"Keybase",findUser:async(e,t)=>{const s=`https://keybase.io/_/api/1.0/user/lookup.json?${t}=${e}`;try{const e=await fetch(s);return(await e.json()).them[0].public_keys.primary.bundle}catch(e){throw new Error("User was not found: "+e.message)}}};t.default=class{constructor(e=i.default.homedir()+"/.polykey",t,s,r,a,c=[]){var l;this.metadata={localPeerInfo:null},this.serverStarted=!1,this.fileSystem=t,this.fileSystem.mkdirSync(e,{recursive:!0}),this.metadataPath=n.default.join(e,".peerMetadata"),this.keyManager=s,this.socialDiscoveryServices=c,this.loadMetadata(),a?(this.localPeerInfo=a,this.writeMetadata()):this.metadata.localPeerInfo?this.localPeerInfo=this.metadata.localPeerInfo:this.keyManager.hasPublicKey()&&(this.localPeerInfo=new f.default(this.keyManager.getPublicKey())),this.peerStore=new Map,this.socialDiscoveryServices=[],this.socialDiscoveryServices.push(m);for(const e of c)this.socialDiscoveryServices.push(e);this.multicastBroadcaster=new h.default(this.addPeer,this.localPeerInfo,this.keyManager),this.peerConnections=new Map,this.gitBackend=new u.default(e,r),this.server=new o.Server,this.server.addService(y.GitServerService,{requestInfo:this.requestInfo.bind(this),requestPack:this.requestPack.bind(this)});this.keyManager.PKIInfo;this.credentials=o.ServerCredentials.createInsecure(),this.server.bindAsync("0.0.0.0:"+(null!==(l=process.env.PK_PORT)&&void 0!==l?l:0),this.credentials,(e,t)=>{if(e)throw e;{const e=new f.Address("localhost",t.toString());this.server.start(),this.localPeerInfo.connect(e),this.serverStarted=!0}})}async requestInfo(e,t){const s=e.request.getVaultname(),r=new p.InfoReply;r.setVaultname(s),r.setBody(await this.gitBackend.handleInfoRequest(s)),t(null,r)}async requestPack(e,t){const s=e.request,r=s.getVaultname(),a=Buffer.from(s.getBody_asB64(),"base64"),i=new p.PackReply;i.setVaultname(r),i.setBody(await this.gitBackend.handlePackRequest(r,a)),t(null,i)}getLocalPeerInfo(){return this.localPeerInfo}connectLocalPeerInfo(e){this.localPeerInfo.connect(e)}addPeer(e){this.peerStore.set(e.publicKey,e)}getPeer(e){var t;return null!==(t=this.peerStore.get(e))&&void 0!==t?t:null}hasPeer(e){return this.peerStore.has(e)}async findPubKey(e){return new Promise((t,s)=>{this.multicastBroadcaster.requestPeerContact(e),this.multicastBroadcaster.on("found",s=>{s.publicKey==e&&t(s)}),this.multicastBroadcaster.on("timeout",t=>{t==e&&s("The broadcaster stopped looking")})})}async findSocialUser(e,t){const s=[];for(const r of this.socialDiscoveryServices)try{s.push(r.findUser(e,t))}catch(e){console.log("Could not find user on this discovery service: "+r.name)}const r=await d.firstPromiseFulfilled(s);if(r.length>1)throw new Error("Could not find public key from services");const a=r[0];return await this.findPubKey(a)}connectToPeer(e){var t;if(e==this.localPeerInfo.connectedAddr||e==this.localPeerInfo.publicKey)throw new Error("Cannot connect to self");let s;if("string"==typeof e){const r=this.peerConnections.get(e);if(r)return r;const a=null===(t=this.getPeer(e))||void 0===t?void 0:t.connectedAddr;if(!a)throw new Error("Peer does not exist in peer store");s=a}else s=e;const r=new c.default(s,this.keyManager);return"string"==typeof e&&this.peerConnections.set(e,r),r}writeMetadata(){var e;const t=this.localPeerInfo,s=l.peer.PeerInfoMessage.encode({addresses:t.AdressStringList,connectedAddr:null===(e=t.connectedAddr)||void 0===e?void 0:e.toString(),pubKey:t.publicKey}).finish();this.fileSystem.writeFileSync(this.metadataPath,s)}loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)){const e=this.fileSystem.readFileSync(this.metadataPath),{addresses:t,connectedAddr:s,pubKey:r}=l.peer.PeerInfoMessage.decode(e);this.localPeerInfo=new f.default(r,t,s)}}}},function(e,t,s){"use strict";var r=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var s in e)Object.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(6)),i=s(7),n=s(8);t.default=class{constructor(e,t){this.credentials=a.credentials.createInsecure(),this.client=new i.GitServerClient(e.toString(),this.credentials)}async request({url:e,method:t,headers:s,body:r,onProgress:a}){return new Promise(async(a,i)=>{const n=new URL(e);if("GET"==t){const r=n.pathname.match(/\/(.+)\/info\/refs$/);r&&!/\.\./.test(r[1])||i(new Error("Error"));const o=r[1],c=await this.requestInfo(o);a({url:e,method:t,statusCode:200,statusMessage:"OK",body:this.iteratorFromData(c),headers:s})}else if("POST"==t){const o=n.pathname.match(/\/(.+)\/git-(.+)/);o&&!/\.\./.test(o[1])||i(new Error("Error"));const c=o[1],u=await this.requestPack(c,r[0]);a({url:e,method:t,statusCode:200,statusMessage:"OK",body:this.iteratorFromData(u),headers:s})}else i(new Error("Method not supported"))})}async requestInfo(e){return new Promise((t,s)=>{const r=new n.InfoRequest;r.setVaultname(e),this.client.requestInfo(r,(function(e,r){e?s(e):t(Buffer.from(r.getBody_asB64(),"base64"))}))})}async requestPack(e,t){return new Promise((s,r)=>{const a=new n.PackRequest;a.setVaultname(e),a.setBody(t),this.client.requestPack(a,(function(e,t){e?r(e):s(Buffer.from(t.getBody_asB64(),"base64"))}))})}iteratorFromData(e){let t=!1;return{next:()=>new Promise((s,r)=>{if(t)return s({done:!0});t=!0,s({value:e,done:!1})})}}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(0)),i=s(3),n=r(s(26)),o=r(s(28)),c=r(s(30));t.default=class{constructor(e,t){this.polykeyPath=e,this.vaultManager=t}exists(e,t){try{const s=this.vaultManager.getVault(e);return!!s&&s.peerCanAccess(t)}catch(e){return!1}}async handleInfoRequest(e){var t;const s=[];if(!this.exists(e,""))throw new Error("Vault does not exist");{s.push(Buffer.from(this.createGitPacketLine("# service=git-upload-pack\n"))),s.push(Buffer.from("0000"));const r=null===(t=this.vaultManager.getVault(e))||void 0===t?void 0:t.EncryptedFS,i=await n.default(r,a.default.join(this.polykeyPath,e),void 0,!0),o=null!=i?i:[];s.push(...o)}return Buffer.concat(s)}async handlePackRequest(e,t){return new Promise(async(s,r)=>{var n;const u=[];if(!this.exists(e,""))throw new Error("Vault does not exist");const l=null===(n=this.vaultManager.getVault(e))||void 0===n?void 0:n.EncryptedFS;if(l&&"want"==t.toString().slice(4,8)){const n=t.toString().slice(9,49),d=await c.default(l,a.default.join(this.polykeyPath,e),[n],void 0);u.push(Buffer.from("0008NAK\n"));const f=new i.PassThrough,h=new i.PassThrough,y=o.default.mux("side-band-64",f,d.packstream,h,[]);y.on("data",e=>{u.push(e)}),y.on("end",()=>{s(Buffer.concat(u))}),y.on("error",e=>{r(e)}),h.write(Buffer.from("0014progress is at 50%\n")),h.end()}})}createGitPacketLine(e){const t=(4+e.length).toString(16);return Array(4-t.length+1).join("0")+t+e}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(0)),i=r(s(9)),n=r(s(10));t.default=async function(e,t,s=a.default.join(t,".git"),r=!1){try{if(r){const t=["side-band-64k"];let r=await n.default.listRefs(e,s,"refs");r=r.map(e=>"refs/"+e);const a={};r.unshift("HEAD");for(const t of r)a[t]=await n.default.resolve(e,s,t);const o={};return o.HEAD=await n.default.resolve(e,s,"HEAD",2),async function({capabilities:e,refs:t,symrefs:s}){const r=[];let a="";for(const[e,t]of Object.entries(s))a+=`symref=${e}:${t} `;let n=`\0${[...e].join(" ")} ${a}agent=git/isomorphic-git@1.4.0`;for(const[e,s]of Object.entries(t))r.push(i.default.encode(`${s} ${e}${n}\n`)),n="";return r.push(i.default.flush()),r}({capabilities:t,refs:a,symrefs:o})}}catch(e){throw e.caller="git.uploadPack",e}}},function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(e){if(this.refs=new Map,this.parsedConfig=[],e){let t;this.parsedConfig=e.trim().split("\n").map(e=>{if(/^\s*#/.test(e))return{line:e,comment:!0};const s=e.indexOf(" ");if(e.startsWith("^")){const s=e.slice(1);return this.refs.set(t+"^{}",s),{line:e,ref:t,peeled:s}}{const r=e.slice(0,s);return t=e.slice(s+1),this.refs.set(t,r),{line:e,ref:t,oid:r}}})}return this}static from(e){return new r(e)}}t.default=r},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(29),i=s(3),n=r(s(9));function o(e,t){const s=[];let r=0;for(;r<e.length;){const a=e.slice(r,r+t);s.push(a),r+=a.length}return s.push(e.slice(r)),s}t.default=class{static demux(e){let t=n.default.streamReader(e),s=new i.PassThrough,r=new i.PassThrough,a=new i.PassThrough;const o=async function(){let e=await t();if(null===e)return o();if(!0===e)return s.end(),a.end(),void r.end();switch(e[0]){case 1:r.write(e.slice(1));break;case 2:a.write(e.slice(1));break;case 3:let t=e.slice(1);return a.write(t),void r.destroy(new Error(t.toString("utf8")));default:s.write(e.slice(0))}o()};return o(),{packetlines:s,packfile:r,progress:a}}static mux(e,t,s,r,c){const u="side-band-64k"===e?999:65519;let l=new i.PassThrough;t.on("data",e=>{null===e?l.write(n.default.flush()):l.write(n.default.encode(e))});let d=!0,f=!1,h=!1,y=a.Buffer.concat([n.default.encode(a.Buffer.from("010A","hex")),n.default.flush()]);return s.on("data",e=>{d=!1;const t=o(e,u);for(const e of t)l.write(n.default.encode(a.Buffer.concat([a.Buffer.from("01","hex"),e])))}).on("end",()=>{f=!0,d||l.write(y),h&&l.end()}),r.on("data",e=>{const t=o(e,u);for(const e of t)l.write(n.default.encode(a.Buffer.concat([a.Buffer.from("02","hex"),e])))}).on("end",()=>{h=!0,f&&l.end()}),l}}},function(e,t){e.exports=require("buffer")},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(11)),i=r(s(0)),n=r(s(31)),o=r(s(35)),c=r(s(36)),u=r(s(12)),l=s(3),d=r(s(13)),f={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function h(e,t,s=i.default.join(t,".git"),r){let a=new Set,n=new Set,c=new Set;async function l(t){let{type:r,object:i}=await d.default.read(e,s,t);if("commit"===r){a.add(t);let e=u.default.from(i).headers().tree;await l(e)}else if("tree"===r){n.add(t);let e=o.default.from(i);for(let t of e)"blob"===t.type&&c.add(t.oid),"tree"===t.type&&await l(t.oid)}}for(let e of r)await l(e);return[...a,...n,...c]}async function y(e,t,s=i.default.join(t,".git"),r,n){let o=c.default("sha1");function u(e,t){t?n.write(e,t):n.write(e),o.update(e,t)}function l(e,t){let s,r,i,n=f[t];if(void 0===n)throw new Error("Unrecognized type: "+t);i=e.length,r=i>15?128:0,s=15&i,i>>>=4;let o=(r|n|s).toString(16);for(u(o,"hex");r;){r=i>127?128:0,o=r|127&i;const e=o.toString(16);u("0".repeat(2-e.length)+e,"hex"),i>>>=7}u(Buffer.from(a.default.deflate(e)))}u("PACK"),u("00000002","hex");const h=r.length.toString(16);u("0".repeat(8-h.length)+h,"hex");for(let t of r){let{type:r,object:a}=await d.default.read(e,s,t);l(a,r)}let y=o.digest();return n.end(y),n}t.listObjects=h,t.pack=y,t.default=async function(e,t,s,r,a){const o=i.default.join(t,".git");let c=new Set,u=new Set,d=new Set,f=[];a=a||[];for(const i of s)try{let s=await n.default(e,t,o,void 0,i,r,void 0),l=[];for(let e=0;e<s.length;e++){let t=s[e];if(a.includes(t.oid)){f.push({oid:i});break}c.add(t.oid),e===s.length-1?l.includes(t.oid)||void 0===r||(console.log("make it shallow",t.oid),u.add(t.oid)):l.includes(t.oid)&&(console.log("make it unshallow",t.oid),d.add(t.oid))}}catch(e){console.log(e)}let p=await h(e,t,o,Array.from(c)),m=new l.PassThrough;return y(e,t,void 0,[...p],m),{packstream:m,shallows:u,unshallows:d,acks:f}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=s(0),i=r(s(12)),n=r(s(13)),o=r(s(10));async function c(e,t,s,r){try{let{type:a,object:o}=await n.default.read(e,t,s);if("commit"!==a)throw new Error("expected type to be commit");const c=i.default.from(o),u=Object.assign({oid:s},c.parse());return r&&(u.payload=c.withoutSignature()),u}catch(e){return{oid:s,error:e}}}function u(e,t){return e.committer.timestamp-t.committer.timestamp}t.logCommit=c,t.default=async function(e,t,s=a.join(t,".git"),r="HEAD",i,n,l=!1){try{let t=void 0===n?void 0:Math.floor(n.valueOf()/1e3),a=[],d=await o.default.resolve(e,s,r),f=[await c(e,s,d,l)];for(;;){let r=f.pop();if(r.error){a.push(r);break}if(void 0!==t&&r.committer.timestamp<=t)break;if(a.push(r),void 0!==i&&a.length===i)break;for(const t of r.parent){let r=await c(e,s,t,l);f.map(e=>e.oid).includes(r.oid)||f.push(r)}if(0===f.length)break;f.sort(u)}return a}catch(e){throw e.caller="git.log",e}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(33));t.default=class{static hash({type:e,object:t}){let s=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),Buffer.from(t)]);return a.default(s)}static wrap({type:e,object:t}){let s=Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),t]);return{oid:a.default(s),buffer:s}}static unwrap({oid:e,buffer:t}){if(e){let s=a.default(t);if(s!==e)throw new Error(`SHA check failed! Expected ${e}, computed ${s}`)}let s=t.indexOf(32),r=t.indexOf(0),i=t.slice(0,s).toString("utf8"),n=t.slice(s+1,r).toString("utf8"),o=t.length-(r+1);if(parseInt(n)!==o)throw new Error(`Length mismatch: expected ${n} bytes but got ${o} instead.`);return{type:i,object:Buffer.from(t.slice(r+1))}}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(34));t.default=function(e){return(new a.default).update(e).digest("hex")}},function(e,t){e.exports=require("sha.js/sha1")},function(e,t,s){"use strict";function r(e){return!e.oid&&e.sha&&(e.oid=e.sha),e.mode=function(e){if("number"==typeof e&&(e=e.toString(8)),e.match(/^0?4.*/))return"40000";if(e.match(/^1006.*/))return"100644";if(e.match(/^1007.*/))return"100755";if(e.match(/^120.*/))return"120000";if(e.match(/^160.*/))return"160000";throw new Error("Could not understand file mode: "+e)}(e.mode),e.type||(e.type="blob"),e}Object.defineProperty(t,"__esModule",{value:!0});class a{constructor(e){if(Buffer.isBuffer(e))this._entries=function(e){let t=[],s=0;for(;s<e.length;){let r=e.indexOf(32,s);if(-1===r)throw new Error(`GitTree: Error parsing buffer at byte location ${s}: Could not find the next space character.`);let a=e.indexOf(0,s);if(-1===a)throw new Error(`GitTree: Error parsing buffer at byte location ${s}: Could not find the next null character.`);let i=e.slice(s,r).toString("utf8");"40000"===i&&(i="040000");let n="040000"===i?"tree":"blob",o=e.slice(r+1,a).toString("utf8"),c=e.slice(a+1,a+21).toString("hex");s=a+21,t.push({mode:i,path:o,oid:c,type:n})}return t}(e);else{if(!Array.isArray(e))throw new Error("invalid type passed to GitTree constructor");this._entries=e.map(r)}}static from(e){return new a(e)}render(){return this._entries.map(e=>`${e.mode} ${e.type} ${e.oid}    ${e.path}`).join("\n")}toObject(){return Buffer.concat(this._entries.map(e=>{let t=Buffer.from(e.mode.replace(/^0/,"")),s=Buffer.from(" "),r=Buffer.from(e.path),a=Buffer.from([0]),i=Buffer.from(e.oid.match(/../g).map(e=>parseInt(e,16)));return Buffer.concat([t,s,r,a,i])}))}entries(){return this._entries}*[Symbol.iterator](){for(let e of this._entries)yield e}}t.default=a},function(e,t){e.exports=require("sha.js")},function(e,t){e.exports=require("../../proto/js/Peer")},function(e,t,s){"use strict";function r(e){return new Promise((t,s)=>e.then(s,t))}Object.defineProperty(t,"__esModule",{value:!0}),t.randomString=function(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)},t.firstPromiseFulfilled=function(e){return r(Promise.all(e.map(r)))}},function(e,t,s){"use strict";var r,a,i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=i(s(40)),o=i(s(5)),c=i(s(14)),u=s(41),l=s(42),{HandshakeMessage:d,PeerInfoMessage:f}=l.peer,h=parseInt(null!==(r=process.env.UDP_MULTICAST_PORT)&&void 0!==r?r:"5353"),y=null!==(a=process.env.UDP_MULTICAST_ADDR)&&void 0!==a?a:"224.0.0.251";class p extends u.EventEmitter{constructor(e,t,s){super(),this.peerPubKeyMessages=new Map,this.addPeer=e,this.localPeerInfo=t,this.keyManager=s,this.interval=1e3,this.queryInterval=null,this.socket=n.default.createSocket({type:"udp4",reuseAddr:!0}),this.socket.bind(h),this.socket.on("listening",(()=>{this.socket.addMembership(y);this.socket.address()}).bind(this)),this.socket.on("message",this.handleHandshakeMessages.bind(this)),this.queryInterval=this.queryLAN()}async requestPeerContact(e){const t=Buffer.from(e),s=o.default.randomBytes(16),r=await this.keyManager.encryptData(t,t),a=await this.keyManager.encryptData(s,t),i=await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()),t);this.peerPubKeyMessages.set(e,{encryptedLocalPubKey:Buffer.from(i),encryptedPeerPubKey:Buffer.from(r),rawRandomMessage:s,encryptedRandomMessage:Buffer.from(a)})}queryLAN(){const e=()=>{for(const e of this.peerPubKeyMessages.keys()){const t=this.peerPubKeyMessages.get(e);if(t){const e=d.encode({targetPubKey:t.encryptedPeerPubKey,requestingPubKey:t.encryptedLocalPubKey,message:t.encryptedRandomMessage}).finish();this.socket.send(e,0,e.length,h,y)}}};return e(),setInterval(e,this.interval)}async handleHandshakeMessages(e,t){var s,r;try{const{message:t,requestingPubKey:a,responsePeerInfo:i,targetPubKey:n}=d.decode(e),o=await this.keyManager.decryptData(Buffer.from(t)),u=await this.keyManager.decryptData(Buffer.from(n)),l=await this.keyManager.decryptData(Buffer.from(a)),p=this.keyManager.getPublicKey();if(l.toString()==p){const e=null===(s=this.peerPubKeyMessages.get(u.toString()))||void 0===s?void 0:s.rawRandomMessage;if(o.toString()==(null==e?void 0:e.toString())){const{addresses:e,connectedAddr:t,pubKey:s}=f.decode(i),r=new c.default(s,e,t);if(r){this.addPeer(r);const e=r.publicKey;this.peerPubKeyMessages.delete(e),console.log("New peer added to the store"),this.emit("found",r)}else this.emit("error","I got a validated response. But no peerInfo")}}else{const e=await this.keyManager.encryptData(Buffer.from(p),l),t=await this.keyManager.encryptData(o,l),s=await this.keyManager.encryptData(l,l),a=f.encode({addresses:this.localPeerInfo.AdressStringList,connectedAddr:null===(r=this.localPeerInfo.connectedAddr)||void 0===r?void 0:r.toString(),pubKey:this.localPeerInfo.publicKey}).finish(),i=d.encode({targetPubKey:Buffer.from(e),requestingPubKey:Buffer.from(s),message:Buffer.from(t),responsePeerInfo:a}).finish();this.socket.send(i,0,i.length,h,y)}}catch(e){}}}t.default=p},function(e,t){e.exports=require("dgram")},function(e,t){e.exports=require("events")},function(e,t){e.exports=require("../../proto/js/Peer.js")},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(1)),i=r(s(0)),n=r(s(15)),o=r(s(44)),c=s(16);t.default=class{constructor(e=a.default.homedir()+"/.polykey",t,s){this.polykeyPath=e,this.fileSystem=t,this.keyManager=s,this.metadataPath=i.default.join(e,".vaultKeys"),this.fileSystem.mkdirSync(this.polykeyPath,{recursive:!0}),this.vaults=new Map,this.vaultKeys=new Map,this.loadMetadata();for(const[e,t]of this.vaultKeys.entries()){const s=i.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(s)){const s=new o.default(e,t,this.polykeyPath);this.vaults.set(e,s)}}}getVault(e){if(this.vaults.has(e)){return this.vaults.get(e)}if(this.vaultKeys.has(e)){this.validateVault(e);const t=this.vaultKeys.get(e),s=new o.default(e,t,this.polykeyPath);return this.vaults.set(e,s),s}throw new Error("Vault does not exist in memory")}async createVault(e,t){if(this.vaultExists(e))throw Error("Vault already exists!");try{const s=i.default.join(this.polykeyPath,e);let r;this.fileSystem.mkdirSync(s,{recursive:!0}),r=t||await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),this.vaultKeys.set(e,r),this.writeMetadata();const a=new o.default(e,r,this.polykeyPath);return await a.initRepository(),this.vaults.set(e,a),this.getVault(e)}catch(t){throw this.destroyVault(e),t}}async cloneVault(e,t){if(this.vaultExists(e))throw new Error("Vault name already exists locally, try pulling instead");const r="http://0.0.0.0/"+e;if(!(await n.default.getRemoteInfo({http:t,url:r})).refs)throw new Error(`Peer does not have vault: '${e}'`);const a=await this.keyManager.generateKey(e+"-Key",this.keyManager.getPrivateKey()),u=new(s(17).VirtualFS),l=new c.EncryptedFS(a,u,u,this.fileSystem,process);await n.default.clone({fs:{promises:l.promises},http:t,dir:i.default.join(this.polykeyPath,e),url:r,ref:"master",singleBranch:!0});const d=new o.default(e,a,this.polykeyPath);return this.vaults.set(e,d),d}vaultExists(e){const t=i.default.join(this.polykeyPath,e);return this.fileSystem.existsSync(t)}destroyVault(e){const t=i.default.join(this.polykeyPath,e);if(this.fileSystem.existsSync(t)&&this.fileSystem.rmdirSync(t,{recursive:!0}),this.vaults.delete(e),this.vaultKeys.delete(e),this.writeMetadata(),this.fileSystem.existsSync(t))throw new Error("Vault folder could not be destroyed!")}listVaults(){return Array.from(this.vaults.keys())}validateVault(e){if(!this.vaults.has(e))throw Error("Vault does not exist in memory");if(!this.vaultKeys.has(e))throw Error("Vault key does not exist in memory");const t=i.default.join(this.polykeyPath,e);if(!this.fileSystem.existsSync(t))throw Error("Vault directory does not exist")}async writeMetadata(){const e=JSON.stringify([...this.vaultKeys]),t=await this.keyManager.encryptData(Buffer.from(e));await this.fileSystem.promises.writeFile(this.metadataPath,t)}async loadMetadata(){if(this.fileSystem.existsSync(this.metadataPath)&&this.keyManager.identityLoaded){const e=this.fileSystem.readFileSync(this.metadataPath),t=(await this.keyManager.decryptData(e)).toString();for(const[e,s]of new Map(JSON.parse(t)))this.vaultKeys[e]=Buffer.from(s)}}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(s(2)),i=r(s(0)),n=r(s(15)),o=s(16);t.default=class{constructor(e,t,r){this.key=t,this.keyLen=t.length;const n=new(s(17).VirtualFS);this.efs=new o.EncryptedFS(this.key,n,n,a.default,process),this.name=e,this.vaultPath=i.default.join(r,e),this.efs.mkdirSync(this.vaultPath,{recursive:!0}),this.secrets=new Map,this.loadSecrets(),this.metadataPath=i.default.join(this.vaultPath,".vault","metadata"),this.loadMetadata()}get EncryptedFS(){return this.efs}secretExists(e){const t=i.default.join(this.vaultPath,e);return this.secrets.has(e)&&this.efs.existsSync(t)}async addSecret(e,t){if(this.secrets.has(e))throw new Error("Secret already exists, try updating it instead.");const s=i.default.join(this.vaultPath,e);await this.efs.promises.writeFile(s,t,{}),this.secrets.set(e,t),await this.commitChanges("Add secret: "+e,e,"added")}async updateSecret(e,t){if(!this.secrets.has(e))throw new Error("Secret does not exist, try adding it instead.");const s=i.default.join(this.vaultPath,e);await this.efs.promises.writeFile(s,t,{}),this.secrets.set(e,t),await this.commitChanges("Update secret: "+e,e,"modified")}getSecret(e){if(this.secrets.has(e)){const t=this.secrets.get(e);if(t)return t;{const t=i.default.join(this.vaultPath,e),s=this.efs.readFileSync(t,{});return this.secrets.set(e,s),s}}throw Error("Secret: "+e+" does not exist")}async removeSecret(e){if(this.secrets.has(e)){const t=this.secrets.delete(e);if(await this.efs.promises.unlink(i.default.join(this.vaultPath,e)),await this.commitChanges("Remove secret: "+e,e,"removed"),t)return;throw Error("Secret: "+e+" was not removed")}throw Error("Secret: "+e+" does not exist")}listSecrets(){return Array.from(this.secrets.keys())}tagVault(){}untagVault(){}shareVault(e){if(this.sharedPubKeys.has(name))throw new Error("Vault is already shared with given public key");this.sharedPubKeys.add(e),this.writeMetadata()}unshareVault(e){if(!this.sharedPubKeys.has(e))throw new Error("Vault is not shared with given public key");this.sharedPubKeys.delete(e),this.writeMetadata()}peerCanAccess(e){return!0}async pullVault(e){await n.default.currentBranch({fs:{promises:this.efs.promises},dir:this.vaultPath,fullname:!0}),await n.default.pull({fs:{promises:this.efs.promises},http:e,dir:this.vaultPath,url:"http://0.0.0.0:0/"+this.name,ref:"HEAD",singleBranch:!0,author:{name:this.name}}),this.loadSecrets()}async initRepository(){const e=this.efs;await n.default.init({fs:e,dir:this.vaultPath}),await n.default.commit({fs:e,dir:this.vaultPath,author:{name:this.name},message:"init commit"}),this.efs.writeFileSync(i.default.join(this.vaultPath,".git","packed-refs"),"# pack-refs with: peeled fully-peeled sorted")}writeMetadata(){this.efs.mkdirSync(i.default.dirname(this.metadataPath),{recursive:!0});const e={sharedPubKeys:Array.from(this.sharedPubKeys.keys())};this.efs.writeFileSync(this.metadataPath,JSON.stringify(e))}loadMetadata(){if(this.efs.existsSync(this.metadataPath)){const e=this.efs.readFileSync(this.metadataPath).toString(),t=JSON.parse(e);this.sharedPubKeys=new Set(t.sharedPubKeys)}else this.sharedPubKeys=new Set,this.writeMetadata()}async commitChanges(e,t,s){return"removed"==s?await n.default.remove({fs:this.efs,dir:this.vaultPath,filepath:t}):await n.default.add({fs:this.efs,dir:this.vaultPath,filepath:t}),await n.default.commit({fs:this.efs,dir:this.vaultPath,author:{name:this.name},message:e})}loadSecrets(){const e=a.default.readdirSync(this.vaultPath,void 0);for(const t of e.filter(e=>"."!=e[0]))this.secrets.set(t,null)}}},function(e,t,s){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var s in e)Object.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const i=r(s(1)),n=r(s(2)),o=r(s(46)),c=r(s(0)),u=r(s(47)),l=s(48),d=a(s(4)),f=r(s(49)),h=r(s(18)),y=s(19),p=s(3),{AgentMessage:m,CreateSecretRequestMessage:g,CreateSecretResponseMessage:w,DeriveKeyRequestMessage:P,DeriveKeyResponseMessage:S,DestroySecretRequestMessage:v,DestroySecretResponseMessage:k,DestroyVaultRequestMessage:b,DestroyVaultResponseMessage:M,ErrorMessage:_,GetSecretRequestMessage:E,GetSecretResponseMessage:K,ListNodesRequestMessage:R,ListNodesResponseMessage:x,ListSecretsRequestMessage:j,ListSecretsResponseMessage:I,ListVaultsRequestMessage:A,ListVaultsResponseMessage:N,NewNodeRequestMessage:O,NewNodeResponseMessage:q,NewVaultRequestMessage:D,NewVaultResponseMessage:F,RegisterNodeRequestMessage:B,RegisterNodeResponseMessage:C,SignFileRequestMessage:T,SignFileResponseMessage:V,Type:$,VerifyFileRequestMessage:L,VerifyFileResponseMessage:G}=y.agent;class U{constructor(){this.persistentStore=new f.default("polykey"),this.polykeyMap=new Map,this.socketPath=U.SocketPath,n.default.existsSync(this.socketPath)&&n.default.unlinkSync(this.socketPath),n.default.existsSync(c.default.dirname(this.socketPath))||n.default.promises.mkdir(c.default.dirname(this.socketPath));const e=this.persistentStore.get("nodePaths");if(e)for(const t of e)n.default.existsSync(t)?this.polykeyMap.set(t,new d.default(t,n.default)):this.removeFromNodePaths(t);else this.persistentStore.set("nodePaths",[]);this.server=o.default.createServer().listen(this.socketPath),this.server.on("connection",e=>{this.handleClientCommunication(e)})}get AllNodePaths(){return Array.from(this.polykeyMap.keys()).filter(e=>{try{return this.getPolykey(e),!0}catch(e){return!1}})}get UnlockedNodePaths(){return this.AllNodePaths.filter(e=>{try{return this.getPolykey(e).keyManager.identityLoaded}catch(e){return!1}})}stop(){this.server.close()}addToNodePaths(e,t){this.polykeyMap.set(e,t);const s=new Set(this.persistentStore.get("nodePaths"));s.add(e),this.persistentStore.set("nodePaths",Array.from(s.values()))}removeFromNodePaths(e){this.polykeyMap.delete(e);const t=new Set(this.persistentStore.get("nodePaths"));t.delete(e),this.persistentStore.set("nodePaths",Array.from(t.values()))}handleClientCommunication(e){e.on("data",async t=>{var s;try{const{type:s,nodePath:r,subMessage:a}=m.decode(t);let i=void 0;switch(s){case $.STATUS:i=Buffer.from("online");break;case $.STOP_AGENT:this.stop(),u.default.exit();case $.REGISTER_NODE:i=await this.registerNode(r,a);break;case $.NEW_NODE:i=await this.newNode(r,a);break;case $.LIST_NODES:i=this.listNodes(a);break;case $.DERIVE_KEY:i=await this.deriveKey(r,a);break;case $.SIGN_FILE:i=await this.signFile(r,a);break;case $.VERIFY_FILE:i=await this.verifyFile(r,a);break;case $.LIST_VAULTS:i=await this.listVaults(r);break;case $.NEW_VAULT:i=await this.newVault(r,a);break;case $.DESTROY_VAULT:i=await this.destroyVault(r,a);break;case $.LIST_SECRETS:i=await this.listSecrets(r,a);break;case $.CREATE_SECRET:i=await this.createSecret(r,a);break;case $.DESTROY_SECRET:i=await this.destroySecret(r,a);break;case $.GET_SECRET:i=await this.getSecret(r,a);break;default:throw Error("message type not supported: "+s)}if(!i)throw Error("something went wrong");{const t=m.encode({type:s,isResponse:!0,nodePath:r,subMessage:i}).finish();e.write(t)}}catch(t){const r=m.encode({type:$.ERROR,isResponse:!0,nodePath:void 0,subMessage:_.encode({error:null!==(s=t.message)&&void 0!==s?s:t}).finish()}).finish();e.write(r)}e.end()})}async registerNode(e,t){const{passphrase:s}=B.decode(t);let r=this.polykeyMap.get(e);if(r){if(r.keyManager.identityLoaded)throw Error(`node path is already loaded and unlocked: '${e}'`);await r.keyManager.unlockIdentity(s)}else{const t=new d.KeyManager(e,n.default);await t.unlockIdentity(s),r=new d.default(e,n.default,t)}return this.addToNodePaths(e,r),q.encode({successful:r.keyManager.identityLoaded&&this.polykeyMap.has(e)}).finish()}async newNode(e,t){if(this.polykeyMap.has(e)&&n.default.existsSync(e))throw Error(`node path '${e}' is already loaded`);if(n.default.existsSync(e))throw Error(`node path already exists: '${e}'`);const{name:s,email:r,passphrase:a,nbits:i}=O.decode(t),o=new d.KeyManager(e,n.default);await o.generateKeyPair(s,r,a,0==i?void 0:i,!0,e=>{});const c=new d.default(e,n.default,o);return this.addToNodePaths(e,c),q.encode({successful:o.identityLoaded&&this.polykeyMap.has(e)}).finish()}listNodes(e){const{unlockedOnly:t}=R.decode(e);return t?x.encode({nodes:this.UnlockedNodePaths}).finish():x.encode({nodes:this.AllNodePaths}).finish()}getPolykey(e){var t;if(this.polykeyMap.has(e))return this.polykeyMap.get(e);if(n.default.existsSync(e))throw Error(`polykey node has not been loaded yet: '${e}'`);{const s=new Set(null!==(t=this.persistentStore.get("nodePaths"))&&void 0!==t?t:[]);throw s.delete(e),this.persistentStore.set("nodePaths",s),Error(`node path does not exist: '${e}'`)}}async deriveKey(e,t){const{keyName:s,passphrase:r}=P.decode(t),a=this.getPolykey(e);return await a.keyManager.generateKey(s,r),S.encode({successful:!0}).finish()}async signFile(e,t){const{filePath:s,privateKeyPath:r,passphrase:a}=T.decode(t),i=this.getPolykey(e),n=await i.keyManager.signFile(s,r,a);return V.encode({signaturePath:n}).finish()}async verifyFile(e,t){const{filePath:s,signaturePath:r}=L.decode(t),a=this.getPolykey(e),i=await a.keyManager.verifyFile(s,r);return G.encode({verified:i}).finish()}async listVaults(e){const t=this.getPolykey(e).vaultManager.listVaults();return N.encode({vaultNames:t}).finish()}async newVault(e,t){const{vaultName:s}=D.decode(t),r=this.getPolykey(e);return await r.vaultManager.createVault(s),F.encode({successful:!0}).finish()}async destroyVault(e,t){const{vaultName:s}=b.decode(t);return this.getPolykey(e).vaultManager.destroyVault(s),M.encode({successful:!0}).finish()}async listSecrets(e,t){const{vaultName:s}=j.decode(t),r=this.getPolykey(e).vaultManager.getVault(s).listSecrets();return I.encode({secretNames:r}).finish()}async createSecret(e,t){const{vaultName:s,secretName:r,secretPath:a}=g.decode(t),i=this.getPolykey(e).vaultManager.getVault(s),o=await n.default.promises.readFile(a);return await i.addSecret(r,o),w.encode({successful:!0}).finish()}async destroySecret(e,t){const{vaultName:s,secretName:r}=v.decode(t),a=this.getPolykey(e).vaultManager.getVault(s);return await a.removeSecret(r),k.encode({successful:!0}).finish()}async getSecret(e,t){const{vaultName:s,secretName:r}=E.decode(t),a=this.getPolykey(e).vaultManager.getVault(s),i=Buffer.from(a.getSecret(r));return K.encode({secret:i}).finish()}static connectToAgent(e){return new h.default(null!=e?e:()=>{const e=new p.PassThrough,t=o.default.createConnection(U.SocketPath);return t.pipe(e),e.pipe(t),e})}static get SocketPath(){const e=i.default.platform(),t=i.default.userInfo();return"win32"==e?c.default.join("\\\\?\\pipe",u.default.cwd(),"polykey-agent"):`/run/user/${t.uid}/polykey/S.polykey-agent`}static get LogPath(){const e=i.default.platform(),t=i.default.userInfo();return"win32"==e?c.default.join(i.default.tmpdir(),"polykey","log"):`/run/user/${t.uid}/polykey/log`}static async startAgent(e=!1){return new Promise((t,s)=>{try{let s={uid:u.default.getuid(),detached:e};e&&(n.default.rmdirSync(U.LogPath,{recursive:!0}),n.default.mkdirSync(U.LogPath,{recursive:!0}),s.stdio=["ipc",n.default.openSync(c.default.join(U.LogPath,"output.log"),"a"),n.default.openSync(c.default.join(U.LogPath,"error.log"),"a"),,]);const r=l.fork(U.DAEMON_SCRIPT_PATH,void 0,s),a=r.pid;r.unref(),t(a)}catch(e){s(e)}})}}U.DAEMON_SCRIPT_PATH=c.default.join(__dirname,"internal","daemon-script.js"),t.default=U},function(e,t){e.exports=require("net")},function(e,t){e.exports=require("process")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("configstore")}])}));
//# sourceMappingURL=polykey.js.map