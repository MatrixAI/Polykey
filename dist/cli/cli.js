!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.cli=t():e.cli=t()}(this,(function(){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var a=t[o]={i:o,l:!1,exports:{}};return e[o].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(o,a,function(t){return e[t]}.bind(null,a));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n(4)),r=o(n(3)),s=n(1),i=o(n(5)),d=o(n(7)),l=o(n(8)),c=o(n(9)),u=o(n(10));function p(e){console.error(r.default.red(e.message))}function g(e){return"~"!==e[0]||"/"!==e[1]&&1!==e.length||(e=e.replace("~",a.default.homedir())),e}var f;t.actionRunner=function(e){return(...t)=>e(...t).catch(p)},t.resolveTilde=g,function(e){e[e.SUCCESS=0]="SUCCESS",e[e.INFO=1]="INFO",e[e.WARNING=2]="WARNING",e[e.none=3]="none"}(f||(f={})),t.PKMessageType=f,t.pkLogger=function(e,t){switch(t){case f.SUCCESS:console.log(r.default.green(e));break;case f.INFO:console.log(r.default.blue(e));break;case f.WARNING:console.log(r.default.yellow(e));break;default:console.log(e)}},t.determineNodePath=function(e){var t;const n=null!==(t=e.nodePath)&&void 0!==t?t:process.env.KEYNODE_PATH;if(!n)throw Error("no keynode path given, you can set it as an environment variable with \"export KEYNODE_PATH='<path>'\"");return g(n)};const y=new s.program.Command;y.version(n(11).version,"--version","output the current version").addCommand(u.default()).addCommand(c.default()).addCommand(l.default()).addCommand(d.default()).addCommand(i.default()),e.exports=function(e){y.parse(e)}},function(e,t){e.exports=require("commander")},function(e,t){e.exports=require("../lib/polykey.js")},function(e,t){e.exports=require("chalk")},function(e,t){e.exports=require("os")},function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n(6)),r=o(n(1)),s=n(2),i=n(0);t.default=function(){return new r.default.Command("agent").description("control the polykey agent").addCommand(new r.default.Command("start").description("start the agent").option("-d, --daemon","start the agent as a daemon process").action(i.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent();if("online"==await t.getAgentStatus())i.pkLogger("agent is already running",i.PKMessageType.INFO);else{const t=e.daemon,n=await s.PolykeyAgent.startAgent(t);i.pkLogger("agent has started with pid of "+n,i.PKMessageType.SUCCESS)}process.exit()}))).addCommand(new r.default.Command("restart").description("restart the agent").option("-d, --daemon","start the agent as a daemon process").action(i.actionRunner(async e=>{s.PolykeyAgent.connectToAgent().stopAgent();const t=e.daemon,n=await s.PolykeyAgent.startAgent(t);i.pkLogger("agent has restarted with pid of "+n,i.PKMessageType.SUCCESS),process.exit()}))).addCommand(new r.default.Command("status").description("retrieve the status of the agent").action(i.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=await t.getAgentStatus();i.pkLogger(`agent status is: '${n}'`,i.PKMessageType.INFO),process.exit()}))).addCommand(new r.default.Command("stop").description("stop the agent").option("-f, --force","forcibly stop the agent").action(i.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent();if("stopped"==await t.getAgentStatus())i.pkLogger("agent is already stopped",i.PKMessageType.INFO);else{const n=!!e.force;if(t.stopAgent(),n&&a.default.unlinkSync(s.PolykeyAgent.SocketPath),"online"==await t.getAgentStatus())throw Error("agent failed to stop");i.pkLogger("agent has successfully stopped",i.PKMessageType.SUCCESS)}process.exit()}))).addCommand(new r.default.Command("list").alias("ls").description("list all the nodes controlled by the node").option("-u, --unlocked-only, only list the nodes that are unlocked").action(i.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=!!e.unlockedOnly,o=await t.listNodes(n);if(0==o.length)i.pkLogger("no nodes were listed",i.PKMessageType.INFO);else for(const e of o)i.pkLogger(e,i.PKMessageType.INFO);process.exit()}))).addCommand(new r.default.Command("create").description("create a new polykey node").option("-k, --node-path <nodePath>","provide the polykey path. defaults to ~/.polykey").requiredOption("-n, --full-name <fullName>","provide your full name for key pair generation").requiredOption("-e, --email <email>","provide a valid email address for key pair generation").requiredOption("-p, --private-passphrase <privatePassphrase>","provide the passphrase to the private key").option("-b, --number-of-bits <numberOfBits>","number of bits to use for key pair generation").option("-v, --verbose","increase verbosity by one level").action(i.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=i.determineNodePath(e),o=e.fullName,a=e.email,r=e.privatePassphrase,d=parseInt(e.numberOfBits);if(!await t.newNode(n,o,a,r,d))throw Error("something went wrong with node creation");i.pkLogger(`node was successfully generated at: '${n}'`,i.PKMessageType.SUCCESS),process.exit()}))).addCommand(new r.default.Command("load").description("load an existing polykey node").option("-k, --node-path <nodePath>","provide the polykey path. defaults to ~/.polykey").requiredOption("-p, --private-passphrase <privatePassphrase>","provide the passphrase to the private key").action(i.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=i.determineNodePath(e),o=e.privatePassphrase;if(!await t.registerNode(n,o))throw Error("something went wrong when loading node");i.pkLogger(`node was successfully loaded at: '${n}'`,i.PKMessageType.SUCCESS),process.exit()})))}},function(e,t){e.exports=require("fs")},function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n(1)),r=n(2),s=n(0);t.default=function(){return new a.default.Command("crypto").description("crypto operations").addCommand(new a.default.Command("verify").description("verification operations").option("--node-path <nodePath>","node path").option("-k, --verifying-key <verifyingKey>","path to public key that will be used to verify files, defaults to primary key").option("-s, --detach-sig <detachSig>","path to detached signature for file, defaults to [filename].sig").requiredOption("-f, --signed-file <signedFile>","file to be signed").action(s.actionRunner(async e=>{var t;const n=r.PolykeyAgent.connectToAgent(),o=await n.getAgentStatus();if("online"!=o)throw Error("agent status is: "+o);const a=s.determineNodePath(e),i=(e.verifyingKey,e.signedFile),d=null!==(t=e.detachSig)&&void 0!==t?t:i+".sig";await n.verifyFile(a,i,d)?s.pkLogger(`file '${i}' was successfully verified`,s.PKMessageType.SUCCESS):s.pkLogger(`file '${i}' was not verified`,s.PKMessageType.WARNING)}))).addCommand(new a.default.Command("sign").description("signing operations [files]").option("--node-path <nodePath>","node path").option("-k, --signing-key <signingKey>","path to private key that will be used to sign files").option("-p, --key-passphrase <keyPassphrase>","passphrase to unlock the provided signing key").arguments("file(s) to be signed").action(async e=>{const t=r.PolykeyAgent.connectToAgent(),n=await t.getAgentStatus();if("online"!=n)throw Error("agent status is: "+n);const o=s.determineNodePath(e),a=e.signingKey,i=e.keyPassphrase;if((a||i)&&(!a||!i))throw Error("signing key and passphrase must be specified together");const d=e.args.values();if(0==d.length)throw Error("no files provided");for(const e of d)try{const n=await t.signFile(o,e,a,i);s.pkLogger(`file '${e}' successfully signed at '${n}'`,s.PKMessageType.SUCCESS)}catch(t){throw new Error(`failed to sign '${e}': ${t}`)}}))}},function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n(3)),r=o(n(1)),s=n(0),i=n(2);t.default=function(){return new r.default.Command("vaults").description("manipulate vaults").addCommand(new r.default.Command("list").description("list all available vaults").alias("ls").option("--node-path <nodePath>","node path").option("-v, --verbose","increase verbosity level by one").action(s.actionRunner(async e=>{const t=i.PolykeyAgent.connectToAgent(),n=await t.getAgentStatus();if("online"!=n)throw Error("agent status is: "+n);const o=s.determineNodePath(e),a=await t.listVaults(o);void 0===a||0==a.length?s.pkLogger("no vaults found",s.PKMessageType.INFO):a.forEach(e=>{s.pkLogger(e,s.PKMessageType.INFO)})}))).addCommand(new r.default.Command("new").description("create new vault(s)").option("--node-path <nodePath>","node path").arguments("vault name(s)").action(s.actionRunner(async e=>{const t=i.PolykeyAgent.connectToAgent(),n=s.determineNodePath(e),o=e.args.values();for(const e of o)await t.newVault(n,e),s.pkLogger(`vault created at '${n}/${e}'`,s.PKMessageType.SUCCESS)}))).addCommand(new r.default.Command("remove").description("destroy an existing vault").option("-n, --vault-name <vaultName>","name of vault").option("-a, --all","remove all vaults").option("-v, --verbose","increase verbosity by one level").action(s.actionRunner(async e=>{var t,n;const o=i.PolykeyAgent.connectToAgent(),r=s.determineNodePath(e),d=null!==(t=e.verbose)&&void 0!==t&&t;if(null!==(n=e.all)&&void 0!==n&&n){const e=await o.listVaults(r);if(void 0===e||0==e.length)s.pkLogger("no vaults found",s.PKMessageType.INFO);else{for(const t of e)await o.destroyVault(r,t),d&&s.pkLogger("destroyed "+t,s.PKMessageType.SUCCESS);s.pkLogger("all vaults destroyed successfully",s.PKMessageType.SUCCESS)}return}const l=e.vaultName;if(!l)throw new Error(a.default.red("error: did not receive vault name"));const c=await o.destroyVault(r,l);s.pkLogger(`vault '${l}' destroyed ${c?"un-":""}successfully`,s.PKMessageType.SUCCESS)})))}},function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n(1)),r=n(0),s=n(2);t.default=function(){return new a.default.Command("secrets").description("manipulate secrets for a given vault").addCommand(new a.default.Command("list").description("list all available secrets for a given vault").alias("ls").requiredOption("-n, --vault-name <vaultName>","the vault name").option("--node-path <nodePath>","node path").option("--verbose","increase verbosity level by one").action(r.actionRunner(async e=>{var t;const n=s.PolykeyAgent.connectToAgent(),o=r.determineNodePath(e),a=null!==(t=e.verbose)&&void 0!==t&&t,i=e.vaultName,d=await n.listSecrets(o,i);0==d.length?r.pkLogger(`no secrets found for vault '${i}'`,r.PKMessageType.INFO):(a&&r.pkLogger(`secrets contained within the ${i} vault:`,r.PKMessageType.INFO),d.forEach(e=>{r.pkLogger(e,r.PKMessageType.INFO)}))}))).addCommand(new a.default.Command("create").description("create a secret within a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").requiredOption("-p, --secret-path <secretPath>","path to the secret to be added").option("--node-path <nodePath>","node path").option("--verbose","increase verbosity level by one").action(r.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=r.determineNodePath(e),o=(e.verbose,e.vaultName),a=e.secretName,i=e.secretPath;try{const e=await t.createSecret(n,o,a,i);r.pkLogger(`secret '${a}' was ${e?"":"un-"}sucessfully added to vault '${o}'`,r.PKMessageType.SUCCESS)}catch(e){throw new Error("Error when adding secret: "+e.message)}}))).addCommand(new a.default.Command("remove").description("remove a secret from a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").option("--verbose","increase verbosity level by one").action(r.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=r.determineNodePath(e),o=(e.verbose,e.vaultName),a=e.secretName;try{const e=await t.destroySecret(n,o,a);r.pkLogger(`secret '${a}' was ${e?"":"un-"}sucessfully removed from vault '${o}'`,r.PKMessageType.SUCCESS)}catch(e){throw new Error("Error when removing secret: "+e.message)}}))).addCommand(new a.default.Command("get").description("retrieve a secret from a given vault").requiredOption("-n, --vault-name <vaultName>","the vault name").requiredOption("-s, --secret-name <secretName>","the new secret name").option("--verbose","increase verbosity level by one").action(r.actionRunner(async e=>{const t=s.PolykeyAgent.connectToAgent(),n=r.determineNodePath(e),o=(e.verbose,e.vaultName),a=e.secretName;try{const e=await t.getSecret(n,o,a);r.pkLogger(`secret '${a}' from vault '${o}':`,r.PKMessageType.SUCCESS),r.pkLogger(e.toString(),r.PKMessageType.none)}catch(e){throw new Error("Error when retrieving secret: "+e.message)}})))}},function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n(1)),r=n(2),s=n(0);t.default=function(){return new a.default.Command("keymanager").alias("km").description("manipulate the keymanager").addCommand(new a.default.Command("derive").description("manipulate the keymanager").option("--node-path <nodePath>","node path").requiredOption("-n, --key-name <keyName>","the name of the new key").requiredOption("-p, --key-passphrase <keyPassphrase>","the passphrase for the new key").action(s.actionRunner(async e=>{const t=r.PolykeyAgent.connectToAgent(),n=s.determineNodePath(e),o=e.keyName,a=e.keyPassphrase;await t.deriveKey(n,o,a),s.pkLogger(`'${o}' was added to the Key Manager`,s.PKMessageType.SUCCESS)})))}},function(e,t){e.exports=require("../../package.json")}])}));