{"version":3,"sources":["webpack://polykey/webpack/universalModuleDefinition","webpack://polykey/webpack/bootstrap","webpack://polykey/external \"path\"","webpack://polykey/external \"fs\"","webpack://polykey/external \"crypto\"","webpack://polykey/./src/lib/PeerStore/PeerInfo.ts","webpack://polykey/./src/lib/RPC/RPCMessage.ts","webpack://polykey/./src/lib/index.ts","webpack://polykey/./src/lib/Polykey.ts","webpack://polykey/external \"os\"","webpack://polykey/external \"jsonfile\"","webpack://polykey/./src/lib/Vault.ts","webpack://polykey/external \"futoin-hkdf\"","webpack://polykey/external \"encryptedfs\"","webpack://polykey/external \"virtualfs\"","webpack://polykey/./src/lib/KeyManager.ts","webpack://polykey/external \"kbpgp\"","webpack://polykey/external \"util\"","webpack://polykey/./src/lib/PeerStore/PeerStore.ts","webpack://polykey/external \"protobufjs\"","webpack://polykey/./src/lib/P2P/PeerDiscovery.ts","webpack://polykey/external \"node-fetch\"","webpack://polykey/./src/lib/P2P/MulticastBroadcaster.ts","webpack://polykey/external \"dgram\"","webpack://polykey/external \"events\"","webpack://polykey/./src/lib/utils.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","Address","ip","port","addr","components","split","toString","pubKey","addresses","connectedAddr","publicKey","Set","map","parse","undefined","address","has","add","console","log","__filename","Root","resolvePath","origin","target","join","loadSync","peerInfo","PeerInfoMessage","loadProto","lookupType","push","payload","errMsg","verify","Error","message","encode","finish","buffer","decode","toObject","enums","String","longs","bytes","defaults","arrays","objects","oneofs","targetPubKey","requestingPubKey","messageBuf","responsePeerInfo","HandshakeMessage","encodePeerInfo","Buffer","from","decodePeerInfo","default","keyManager","peerDiscovery","polykeyPath","homedir","metadataPath","fs","peerStore","existsSync","fileContents","readFileSync","metadata","vaults","publicKeyPath","privateKeyPath","getPublicKey","metadataTemplate","writeFileSync","mkdirSync","recursive","Map","vaultName","path","vaultKey","vault","set","validateVault","vaultExists","randomBytes","tags","writeMetadata","getVault","err","destroyVault","rmdirSync","delete","vaultPath","Array","keys","writeFile","symKey","baseDir","keyLen","genSymKey","vfsInstance","VirtualFS","EncryptedFS","process","secrets","loadSecrets","readdirSync","secret","asymKey","secretName","secretPath","secretBuf","writePath","fd","openSync","writeSync","length","polyKeyPath","useWebWorkers","workerPool","primaryKeyPair","private","public","passphrase","storePath","derivedKeys","email","replacePrimary","progressCallback","F","openpgp","options","asp","ASP","progress_hook","userid","primary","nbits","flags","certify_keys","sign_data","auth","encrypt_comm","encrypt_storage","expire_in","subkeys","Promise","resolve","reject","KeyManager","generate","identity","sign","export_pgp_public","export_pgp_private","privKey","keypair","primaryPassphrase","primaryIdentity","privateKey","keyBuffer","promises","readFile","getPrivateKey","import_from_armored_pgp","armored","merge_pgp_private","is_pgp_locked","unlock_pgp","loadPrivateKey","loadPublicKey","loadIdentity","salt","pbkdf2Sync","promisify","pbkdf2","createPath","mkdir","dirname","data","withKey","keyPassphrase","async","resolvedIdentity","getIdentityFromPrivateKey","workerResponse","queue","workerCrypto","signData","params","msg","sign_with","box","result_string","result_buffer","signature","ring","keyring","KeyRing","getIdentityFromPublicKey","verifyData","add_key_manager","keyfetch","unbox","literals","km","ds","get_data_signer","get_key_manager","get_pgp_fingerprint","filePath","signaturePath","fileBuffer","signatureBuffer","privateKeyPassphrase","signedBuffer","signedPath","forPubKey","encryptData","encrypt_for","decryptData","decryptedData","localPeerInfo","peers","update","keybaseDiscovery","findUser","handle","service","url","response","json","them","public_keys","bundle","socialDiscoveryServices","multicastBroadcaster","requestPeerContact","on","timedOutPubKey","tasks","socialDiscovery","error","pubKeyOrFail","firstPromiseFulfilled","pubKeyFound","findPubKey","UDP_MULTICAST_PORT","parseInt","env","UDP_MULTICAST_ADDR","MulticastBroadcaster","EventEmitter","super","peerPubKeyMessages","interval","queryInterval","socket","createSocket","type","reuseAddr","addMembership","pid","handleHandshakeMessages","queryLAN","query","peerMessage","handshakeMessage","encodeHandshakeMessage","encryptedPeerPubKey","encryptedLocalPubKey","encryptedRandomMessage","send","info","setInterval","rinfo","decodedMessage","decodeHandshakeMessage","decryptedMessage","decryptedTargetPubKey","decryptedRequestingPubKey","myPubKey","originalMessage","rawRandomMessage","newPeerInfo","emit","encryptedTargetPubKey","encryptedMessage","encryptedPubKey","pubKeyBuf","randomMessage","invertPromise","res","rej","then","randomString","Math","random","replace","substr","ps","all"],"mappings":"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","file":"polykey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"polykey\"] = factory();\n\telse\n\t\troot[\"polykey\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = require(\"path\");","module.exports = require(\"fs\");","module.exports = require(\"crypto\");","class Address {\n  ip: string\n  port: string\n  constructor(\n    ip: string,\n    port: string\n  ) {\n    this.ip = ip\n    this.port = port\n  }\n\n  static parse(addr: string): Address {\n    const components = addr.split(':')\n    const ip = components[0]\n    const port = components[1]\n\n    return new Address(ip, port)\n  }\n\n}\n\nAddress.prototype.toString = function() {\n  return `${this.ip}:${this.port}`\n}\n\nclass PeerInfo {\n  publicKey: string\n  addresses: Set<Address>\n  connectedAddr?: Address\n  constructor(\n    pubKey: string,\n    addresses: string[] = [],\n    connectedAddr?: string\n  ) {\n    this.publicKey = pubKey\n    this.addresses = new Set(addresses.map((addr) => {\n      return Address.parse(addr)\n    }))\n    this.connectedAddr = (connectedAddr) ? Address.parse(connectedAddr) : undefined\n  }\n\n  connect(address: Address) {\n    if (!this.addresses.has(address)) {\n      this.addresses.add(address)\n    }\n\n    this.connectedAddr = address\n  }\n\n  disconnect() {\n    this.connectedAddr = undefined\n  }\n\n}\n\nexport default PeerInfo\nexport { Address }\n","import Path from 'path'\nimport protobuf, { Root } from 'protobufjs'\nimport PeerInfo from '@polykey/PeerStore/PeerInfo'\n\ntype HandshakeMessage = {\n  targetPubKey: Buffer\n  requestingPubKey: Buffer\n  message: Buffer\n  responsePeerInfo?: PeerInfo\n}\nconsole.log(__filename);\n\nclass RPCMessage {\n  static loadProto(name: string): Root {\n    // Load root\n    const root: Root = new protobuf.Root()\n    root.resolvePath = (origin, target) => {\n      return Path.join(__filename, target)\n    }\n\n    return root.loadSync(name)\n  }\n  static encodePeerInfo(peerInfo: PeerInfo): Uint8Array {\n    const root = this.loadProto(\"PeerInfoMessage.proto\")\n\n    // Obtain a message type\n    const PeerInfoMessage = root!.lookupType(\"peerinfopackage.PeerInfoMessage\");\n\n    // Encode address set to array\n    const addresses: string[] = []\n    for (const addr of peerInfo.addresses) {\n      addresses.push(addr.toString())\n    }\n\n    // Exemplary payload\n    const payload = {\n      pubKey: peerInfo.publicKey,\n      addresses: addresses,\n      connectedAddr: peerInfo.connectedAddr?.toString()\n    };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    const errMsg = PeerInfoMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    const message = PeerInfoMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    const buffer = PeerInfoMessage.encode(message).finish();\n\n    return buffer\n  }\n\n  static decodePeerInfo(buffer: Uint8Array): PeerInfo {\n    const root = this.loadProto(\"PeerInfoMessage.proto\")\n\n    // Obtain a message type\n    const PeerInfoMessage = root!.lookupType(\"peerinfopackage.PeerInfoMessage\");\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    const message = PeerInfoMessage.decode(buffer);\n\n    // Convert the message back to a plain object\n    const object = PeerInfoMessage.toObject(message, {\n      enums: String,  // enums as string names\n      longs: String,  // longs as strings (requires long.js)\n      bytes: String,  // bytes as base64 encoded strings\n      defaults: true, // includes default values\n      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n      objects: true,  // populates empty objects (map fields) even if defaults=false\n      oneofs: true    // includes virtual oneof fields set to the present field's name\n    });\n\n    return new PeerInfo(\n      object.pubKey,\n      object.addresses,\n      object.connectedAddr\n    )\n  }\n\n  static encodeHandshakeMessage(targetPubKey: Buffer, requestingPubKey: Buffer, messageBuf: Buffer, responsePeerInfo?: PeerInfo): Uint8Array {\n    const root = this.loadProto(\"HandshakeMessage.proto\")\n\n    // Obtain a message type\n    const HandshakeMessage = root!.lookupType(\"handshakepackage.HandshakeMessage\");\n\n    // Exemplary payload\n    const payload = {\n      targetPubKey: targetPubKey,\n      requestingPubKey: requestingPubKey,\n      message: messageBuf,\n      responsePeerInfo: (responsePeerInfo) ? this.encodePeerInfo(responsePeerInfo) : undefined\n    };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    const errMsg = HandshakeMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    const message = HandshakeMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    const buffer = HandshakeMessage.encode(message).finish();\n\n    return buffer\n  }\n\n  static decodeHandshakeMessage(buffer: Uint8Array): HandshakeMessage {\n    const root = this.loadProto(\"HandshakeMessage.proto\")\n\n    // Obtain a message type\n    const HandshakeMessage = root!.lookupType(\"handshakepackage.HandshakeMessage\");\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    const message = HandshakeMessage.decode(buffer);\n\n    // Convert the message back to a plain object\n    const object = HandshakeMessage.toObject(message, {\n      enums: String,  // enums as string names\n      longs: String,  // longs as strings (requires long.js)\n      bytes: String,  // bytes as base64 encoded strings\n      defaults: true, // includes default values\n      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n      objects: true,  // populates empty objects (map fields) even if defaults=false\n      oneofs: true    // includes virtual oneof fields set to the present field's name\n    });\n\n    return {\n      targetPubKey: Buffer.from(object.targetPubKey, 'base64'),\n      requestingPubKey: Buffer.from(object.requestingPubKey, 'base64'),\n      message: Buffer.from(object.message, 'base64'),\n      responsePeerInfo: (object.responsePeerInfo) ? this.decodePeerInfo(Buffer.from(object.responsePeerInfo, 'base64')) : undefined\n    }\n  }\n}\n\nexport default RPCMessage\n","export { default } from '@polykey/Polykey'\n","import os from 'os'\nimport fs from 'fs'\nimport Path from 'path'\nimport crypto from 'crypto'\nimport jsonfile from 'jsonfile'\nimport Vault from '@polykey/Vault'\nimport KeyManager from '@polykey/KeyManager'\nimport PeerStore from '@polykey/PeerStore/PeerStore'\nimport PeerInfo from '@polykey/PeerStore/PeerInfo'\nimport RPCMessage from '@polykey/RPC/RPCMessage'\nimport PeerDiscovery from '@polykey/P2P/PeerDiscovery'\n\ntype Metadata = {\n  vaults: {\n    [vaultName: string]: {\n      key: Buffer, tags: Array<string>\n    }\n  }\n  peerInfo: Uint8Array\n  publicKeyPath?: string\n  privateKeyPath?: string\n}\n\nclass Polykey {\n  polykeyPath: string\n  private fs: typeof fs\n  private vaults:Map<string, Vault>\n  private metadata: Metadata\n  private metadataPath: string\n\n  keyManager: KeyManager\n  peerStore: PeerStore\n  peerDiscovery: PeerDiscovery\n\n  constructor(\n    keyManager?: KeyManager,\n    peerDiscovery?: PeerDiscovery,\n    polykeyPath: string = `${os.homedir()}/.polykey`\n  ) {\n    this.polykeyPath = polykeyPath\n    this.metadataPath = Path.join(polykeyPath, 'metadata')\n    // Set file system\n    this.fs = fs\n\n    // Set key manager\n    this.keyManager = keyManager ?? new KeyManager(polykeyPath)\n\n    // Set peer discovery\n    this.peerDiscovery = peerDiscovery ?? new PeerDiscovery(this.peerStore, this.keyManager)\n\n    // Make polykey path if doesn't exist\n    if (!this.fs.existsSync(this.polykeyPath)) {\n      this.fs.mkdirSync(this.polykeyPath, {recursive: true})\n    } else if (this.fs.existsSync(this.metadataPath)) {\n      const fileContents = jsonfile.readFileSync(this.metadataPath)\n      this.metadata = {\n        vaults: fileContents.vaults,\n        peerInfo: fileContents.peerInfo,\n        publicKeyPath: fileContents.publicKeyPath,\n        privateKeyPath: fileContents.privateKeyPath\n      }\n    } else {\n      // Create a new peerInfo\n      const peerInfo = new PeerInfo(this.keyManager.getPublicKey())\n      const metadataTemplate = {\n        vaults: {},\n        peerInfo: RPCMessage.encodePeerInfo(peerInfo)\n      }\n      jsonfile.writeFileSync(this.metadataPath, metadataTemplate)\n      this.metadata = metadataTemplate\n    }\n\n    // Initialize peer store and peer discovery classes\n    this.peerStore = new PeerStore(RPCMessage.decodePeerInfo(this.metadata.peerInfo))\n    this.peerDiscovery = new PeerDiscovery(this.peerStore, this.keyManager)\n\n    // Load all of the vaults into memory\n    this.vaults = new Map()\n    for (const vaultName in this.metadata.vaults) {\n      if (this.metadata.vaults.hasOwnProperty(vaultName)) {\n        const path = Path.join(this.polykeyPath, vaultName)\n        if (this.fs.existsSync(path)) {\n          const vaultKey = Buffer.from(this.metadata.vaults[vaultName].key)\n          const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n          this.vaults.set(vaultName, vault)\n        }\n      }\n    }\n  }\n\n  ////////////\n  // Vaults //\n  ////////////\n  async getVault(vaultName: string): Promise<Vault> {\n    if (this.vaults.has(vaultName)) {\n      const vault = this.vaults.get(vaultName)\n      if (vault) {\n        return vault\n      }\n    }\n    // vault not in map, create new instance\n    await this.validateVault(vaultName)\n\n    const vaultKey = this.metadata.vaults[vaultName].key\n    const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n    this.vaults.set(vaultName, vault)\n    return vault\n  }\n\n  async createVault(vaultName: string, key?: Buffer): Promise<Vault> {\n    const path = Path.join(this.polykeyPath, vaultName)\n    let vaultExists: boolean\n    vaultExists = this.fs.existsSync(path)\n\n    if (vaultExists) {\n      throw Error('Vault already exists!')\n    }\n\n    try {\n      // Directory not present, create one\n      this.fs.mkdirSync(path, {recursive:true})\n      // Create key if not provided\n      let vaultKey: Buffer\n      if (!key) {\n        // Generate new key\n        vaultKey = crypto.randomBytes(16)\n      } else {\n        // Assign key if it is provided\n        vaultKey = key\n      }\n      this.metadata.vaults[vaultName] = { key: vaultKey, tags: []}\n      await this.writeMetadata()\n      const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n      this.vaults.set(vaultName, vault)\n      return await this.getVault(vaultName)\n    } catch (err) {\n      // Delete vault dir and garbage collect\n      await this.destroyVault(vaultName)\n      throw err\n    }\n  }\n\n  async vaultExists(vaultName: string): Promise<boolean> {\n    const path = Path.join(this.polykeyPath, vaultName)\n    const vaultExists = this.fs.existsSync(path)\n\n    return vaultExists\n  }\n\n  async destroyVault(vaultName: string) {\n\n    // this is convenience function for removing all tags\n    // and triggering garbage collection\n    // destruction is a better word as we should ensure all traces is removed\n\n    const path = Path.join(this.polykeyPath, vaultName)\n    // Remove directory on file system\n    if (this.fs.existsSync(path)) {\n      this.fs.rmdirSync(path, {recursive: true})\n    }\n    // Remaining garbage collection:\n    // Remove vault from vaults map\n    if (this.vaults.has(vaultName)) {\n      this.vaults.delete(vaultName)\n    }\n    // Remove from metadata\n    if (this.metadata.vaults.hasOwnProperty(vaultName)) {\n      delete this.metadata.vaults[vaultName]\n      await this.writeMetadata()\n    }\n\n    const vaultPathExists = this.fs.existsSync(path)\n    if (vaultPathExists) {\n      throw new Error('Vault path could not be destroyed!')\n    }\n    const vaultEntryExists = this.vaults.has(vaultName)\n    if (vaultEntryExists) {\n      throw new Error('Vault could not be removed from PolyKey!')\n    }\n    const metaDataHasVault = this.metadata.vaults.hasOwnProperty(vaultName)\n    if (metaDataHasVault) {\n      throw new Error('Vault metadata could not be destroyed!')\n    }\n  }\n\n  /* Validates whether all the artefacts needed to operate\n  * a Vault are present. Namely this the vault directory\n  * and the metadata for the vault containg the key\n  */\n  private async validateVault (vaultName: string): Promise<void> {\n    const existsMeta = this.metadata.vaults.hasOwnProperty(vaultName)\n    if (!existsMeta) {\n      throw Error('Vault metadata does not exist')\n    }\n    const vaultPath = Path.join(this.polykeyPath, vaultName)\n    const existsFS = this.fs.existsSync(vaultPath)\n    if (!existsFS) {\n      throw Error('Vault directory does not exist')\n    }\n  }\n\n  listVaults(): string[] {\n    return Array.from(this.vaults.keys())\n  }\n\n\n  tagVault() {\n\n  }\n\n  untagVault() {\n\n  }\n\n  shareVault() {\n\n  }\n\n  unshareVault() {\n\n  }\n\n  /* ============ HELPERS =============== */\n  private async writeMetadata(): Promise<void> {\n    try {\n      await jsonfile.writeFile(this.metadataPath, this.metadata)\n    } catch (err) {\n      throw Error(\"Error writing vault key to config file\")\n    }\n  }\n}\n\nexport default Polykey\n","module.exports = require(\"os\");","module.exports = require(\"jsonfile\");","import fs from 'fs'\nimport Path from 'path'\nimport hkdf from 'futoin-hkdf'\nimport { EncryptedFS } from 'encryptedfs'\n\nclass Vault {\n\n  private key: Buffer\n  private keyLen: number\n  name: string\n  private fs: EncryptedFS\n  private secrets: Map<string, any>\n  private vaultPath: string\n  constructor(\n    name: string,\n    symKey: Buffer,\n    baseDir: string\n  ) {\n    // how do we create pub/priv key pair?\n    // do we use the same gpg pub/priv keypair\n    this.keyLen = 32\n    this.key = this.genSymKey(symKey, this.keyLen)\n    // Set filesystem\n    const vfsInstance = new (require('virtualfs')).VirtualFS\n\n    this.fs = new EncryptedFS(\n      symKey,\n      vfsInstance,\n      vfsInstance,\n      fs,\n      process\n    )\n\n    this.name = name\n    this.vaultPath = Path.join(baseDir, name)\n    // make the vault directory\n    this.fs.mkdirSync(this.vaultPath, {recursive: true})\n    this.secrets = new Map()\n\n    this.loadSecrets()\n  }\n\n  loadSecrets(): void {\n    const secrets = fs.readdirSync(this.vaultPath, undefined)\n\n    for (const secret of secrets) {\n      this.secrets.set(secret, null)\n    }\n  }\n\n  genSymKey(asymKey: Buffer, keyLen: number): Buffer {\n    return Buffer.from(hkdf(asymKey.toString(), keyLen))\n  }\n\n  secretExists(secretName: string) : boolean {\n    const secretPath = Path.join(this.vaultPath, secretName)\n    return this.secrets.has(secretName) && this.fs.existsSync(secretPath)\n  }\n\n  addSecret (secretName: string, secretBuf: Buffer): void {\n    // TODO: check if secret already exists\n    const writePath = Path.join(this.vaultPath, secretName)\n    // TODO: use aysnc methods\n    const fd = this.fs.openSync(writePath, 'w')\n    this.fs.writeSync(fd, secretBuf, 0, secretBuf.length, 0)\n    this.secrets.set(secretName, secretBuf)\n    // TODO: close file or use write file sync\n  }\n\n  getSecret(secretName: string): Buffer | string {\n    if (this.secrets.has(secretName)) {\n      const secret = this.secrets.get(secretName)\n      if (secret) {\n        return secret\n      } else {\n        const secretPath = Path.join(this.vaultPath, secretName)\n        // TODO: this should be async\n        const secretBuf = this.fs.readFileSync(secretPath, {})\n        this.secrets.set(secretName, secretBuf)\n        return secretBuf\n      }\n    }\n    throw Error('Secret: ' + secretName + ' does not exist')\n  }\n\n  removeSecret (secretName: string): void {\n    if (this.secrets.has(secretName)) {\n      const successful = this.secrets.delete(secretName)\n      if (successful) {\n        return\n      }\n      throw Error('Secret: ' + secretName + ' was not removed')\n    }\n    throw Error('Secret: ' + secretName + ' does not exist')\n  }\n\n  listSecrets(): string[] {\n    let secrets: string[] = Array.from(this.secrets.keys())\n    return secrets\n  }\n\n  tagVault() {\n\n  }\n\n  untagVault() {\n\n  }\n\n  shareVault() {\n  }\n\n  unshareVault() {\n  }\n\n  // ============== Helper methods ============== //\n\n}\n\nexport default Vault\n","module.exports = require(\"futoin-hkdf\");","module.exports = require(\"encryptedfs\");","module.exports = require(\"virtualfs\");","import fs from 'fs'\nimport Path from 'path'\nimport kbpgp from 'kbpgp'\nimport crypto from 'crypto'\nimport { promisify } from 'util'\nimport {Pool, ModuleThread} from 'threads'\nimport { KeyManagerWorker } from '@polykey/KeyManagerWorker'\n\ntype KeyPair = {\n  private: string,\n  public: string,\n  passphrase: string\n}\n\nclass KeyManager {\n  private primaryKeyPair: KeyPair = {private: '', public: '', passphrase: ''}\n  private primaryPassphrase?: string\n  private primaryIdentity?: Object\n  private derivedKeys: Map<string, Buffer>\n  private useWebWorkers: boolean\n  private workerPool?: Pool<ModuleThread<KeyManagerWorker>>\n\n  storePath: string\n\n  constructor(\n    polyKeyPath: string = '~/.polykey/',\n    useWebWorkers: boolean = false,\n    workerPool?: Pool<ModuleThread<KeyManagerWorker>>\n  ) {\n    this.storePath = polyKeyPath\n    this.useWebWorkers = useWebWorkers\n    this.workerPool = workerPool\n    this.derivedKeys = new Map()\n  }\n\n  // return {private: string, public: string}\n  // The replacePrimary parameter will tell KeyManager to replace the\n  // existing identity with one derived from the new keypair\n  async generateKeyPair(name: string, email: string, passphrase: string, replacePrimary: boolean = false, progressCallback?: (info) => void): Promise<KeyPair> {\n\n    // Define options\n    const F = kbpgp[\"const\"].openpgp\n    const options = {\n      asp: (progressCallback) ? new kbpgp.ASP({progress_hook: progressCallback}) : undefined,\n      userid: `${name} <${email}>`,\n      primary: {\n        nbits: 4096,\n        flags: F.certify_keys | F.sign_data | F.auth | F.encrypt_comm | F.encrypt_storage,\n        expire_in: 0  // never expire\n      },\n      subkeys: []\n    }\n\n    return new Promise<KeyPair>((resolve, reject) => {\n      kbpgp.KeyManager.generate(options, (err, identity) => {\n        if (err) {\n          reject(err)\n        }\n        identity.sign({}, (err) => {\n          if (err) {\n            reject(err)\n          }\n          // Export pub key first\n          identity.export_pgp_public({}, (err, pubKey) => {\n            if (err) {\n              reject(err)\n            }\n            // Finally export priv key\n            identity.export_pgp_private({passphrase: passphrase}, (err, privKey) => {\n              if (err) {\n                reject(err)\n              }\n              // Resolve to parent promise\n              const keypair = { private: privKey, public: pubKey, passphrase: passphrase }\n              if (replacePrimary) {\n                // Set the new passphrase\n                this.primaryPassphrase = passphrase\n                // Set the new keypair\n                this.primaryKeyPair = keypair\n                // Set the new identity\n                this.primaryIdentity = identity\n              }\n\n              resolve(keypair)\n            })\n          })\n        })\n      })\n    })\n  }\n\n  getKeyPair(): KeyPair {\n    return this.primaryKeyPair\n  }\n\n  getPublicKey(): string {\n    return this.primaryKeyPair.public\n  }\n\n  getPrivateKey(): string {\n    return this.primaryKeyPair.private\n  }\n\n  async loadPrivateKey(privateKey: string | Buffer, passphrase: string = ''): Promise<void> {\n    try {\n      let keyBuffer: Buffer\n      if (typeof privateKey === 'string') {\n        keyBuffer = Buffer.from(await fs.promises.readFile(privateKey))\n      } else {\n        keyBuffer = privateKey\n      }\n      this.primaryKeyPair.private = keyBuffer.toString()\n\n      if (passphrase) {\n        this.primaryPassphrase = passphrase\n      }\n    } catch (err) {\n      throw(err)\n    }\n  }\n\n  async loadPublicKey(publicKey: string | Buffer): Promise<void> {\n    try {\n      let keyBuffer: Buffer\n      if (typeof publicKey === 'string') {\n        keyBuffer = Buffer.from(await fs.promises.readFile(publicKey))\n      } else {\n        keyBuffer = publicKey\n      }\n      this.primaryKeyPair.public = keyBuffer.toString()\n    } catch (err) {\n      throw(err)\n    }\n  }\n\n  async loadIdentity(passphrase: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const pubKey: string = this.getPublicKey()\n      const privKey: string = this.getPrivateKey()\n\n      kbpgp.KeyManager.import_from_armored_pgp({armored: pubKey}, (err, identity) => {\n        if (err) {\n          reject(err)\n        }\n\n        identity.merge_pgp_private({\n          armored: privKey\n        }, (err) => {\n          if (err) {\n            reject(err)\n          }\n\n          if (identity.is_pgp_locked()) {\n            identity.unlock_pgp({\n              passphrase: passphrase\n            }, (err) => {\n              if (err) {\n                reject(err)\n              }\n\n              this.primaryIdentity = identity\n              resolve()\n            })\n          } else {\n            this.primaryIdentity = identity\n            resolve()\n          }\n        })\n      })\n    })\n  }\n\n  async loadKeyPair(publicKey: string | Buffer, privateKey: string | Buffer, passphrase: string = ''): Promise<void> {\n    await this.loadPrivateKey(privateKey)\n    await this.loadPublicKey(publicKey)\n    await this.loadIdentity(passphrase)\n\n    if (passphrase) {\n      this.primaryPassphrase\n    }\n  }\n\n  async exportPrivateKey(path: string): Promise<void> {\n    await fs.promises.writeFile(path, this.primaryKeyPair.private)\n  }\n\n  async exportPublicKey(path: string): Promise<void> {\n    await fs.promises.writeFile(path, this.primaryKeyPair.public)\n  }\n\n  // symmetric key generation\n  generateKeySync(name: string, passphrase: string): Buffer {\n    const salt = crypto.randomBytes(32)\n    this.derivedKeys[name] = crypto.pbkdf2Sync(passphrase , salt, 10000, 256/8, 'sha256')\n\n    return this.derivedKeys[name]\n  }\n\n  async generateKey(name: string, passphrase: string): Promise<Buffer> {\n    const salt = crypto.randomBytes(32)\n    this.derivedKeys[name] = await promisify(crypto.pbkdf2)(passphrase , salt, 10000, 256/8, 'sha256')\n\n    return this.derivedKeys[name]\n  }\n\n  importKeySync(name: string, key: string | Buffer): void {\n    if (typeof key === 'string') {\n      this.derivedKeys[name] = fs.readFileSync(key)\n    } else {\n      this.derivedKeys[name] = key\n    }\n  }\n\n  async importKey(name: string, key: string | Buffer): Promise<void> {\n    if (typeof key === 'string') {\n      this.derivedKeys[name] = await fs.promises.readFile(key)\n    } else {\n      this.derivedKeys[name] = key\n    }\n  }\n\n  async exportKey(name: string, path: string, createPath?: boolean): Promise<void> {\n    if (!this.derivedKeys.has(name)) {\n      throw Error(`There is no key loaded for name: ${name}`)\n    }\n    if (createPath) {\n      await fs.promises.mkdir(Path.dirname(path), {recursive: true})\n    }\n    await fs.promises.writeFile(path, this.derivedKeys[name])\n  }\n\n  exportKeySync(path: string, createPath?: boolean): void {\n    if (!this.derivedKeys.has(name)) {\n      throw Error(`There is no key loaded for name: ${name}`)\n    }\n    if (createPath) {\n      fs.mkdirSync(Path.dirname(path), {recursive: true})\n    }\n    fs.writeFileSync(path, this.derivedKeys[name])\n  }\n\n  async getIdentityFromPublicKey(pubKey: Buffer): Promise<Object> {\n    return new Promise<Object>((resolve, reject) => {\n      kbpgp.KeyManager.import_from_armored_pgp({armored: pubKey}, (err, identity) => {\n        if (err) {\n          reject(err)\n        }\n        resolve(identity)\n      })\n    })\n  }\n\n  async getIdentityFromPrivateKey(privKey: Buffer, passphrase: string): Promise<Object> {\n    return new Promise<Object>((resolve, reject) => {\n      kbpgp.KeyManager.import_from_armored_pgp({armored: privKey}, (err, identity) => {\n        if (err) {\n          reject(err)\n        }\n        if (identity.is_pgp_locked()) {\n          identity.unlock_pgp({\n            passphrase: passphrase\n          }, (err) => {\n            if (err) {\n              reject(err)\n            }\n            resolve(identity)\n          });\n        } else {\n          resolve(identity)\n        }\n      })\n    })\n  }\n\n  // Sign data\n  signData(data: Buffer | string, withKey?: Buffer, keyPassphrase?: string): Promise<Buffer> {\n    return new Promise<Buffer>(async (resolve, reject) => {\n      let resolvedIdentity: Object\n      if (withKey) {\n        if (!keyPassphrase) {\n          reject(Error('passphrase for private key was not provided'))\n        }\n        resolvedIdentity = await this.getIdentityFromPrivateKey(withKey, keyPassphrase!)\n      } else if (this.primaryIdentity) {\n        resolvedIdentity = this.primaryIdentity\n      } else {\n        throw(Error('no identity available for signing'))\n      }\n\n      if (this.useWebWorkers && this.workerPool) {\n        const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n          return await workerCrypto.signData(data, resolvedIdentity);\n        });\n        resolve(workerResponse)\n      } else {\n        const params = {\n          msg: data,\n          sign_with: resolvedIdentity\n        }\n        kbpgp.box(params, (err: Error, result_string: string, result_buffer: Buffer) => {\n          if (err) {\n            reject(err)\n          }\n          resolve(Buffer.from(result_string))\n        })\n      }\n    })\n  }\n\n  // Verify data\n  verifyData(data: Buffer | string, signature: Buffer, withKey?: Buffer): Promise<string> {\n    return new Promise<string>(async (resolve, reject) => {\n      const ring = new kbpgp.keyring.KeyRing;\n      let resolvedIdentity: Object\n      if (withKey) {\n        resolvedIdentity = await this.getIdentityFromPublicKey(withKey)\n      } else if (this.primaryIdentity) {\n        resolvedIdentity = this.primaryIdentity\n      } else {\n        throw new Error('no identity available for verifying')\n      }\n\n      if (this.useWebWorkers && this.workerPool) {\n        const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n          return await workerCrypto.verifyData(data, signature, resolvedIdentity);\n        });\n        resolve(workerResponse)\n      } else {\n        ring.add_key_manager(this.primaryIdentity)\n        const params = {\n          armored: signature,\n          data: data,\n          keyfetch: ring\n        }\n        kbpgp.unbox(params, (err, literals) => {\n          if (err) {\n            reject(err)\n          }\n          let ds = literals[0].get_data_signer()\n          let km: any\n          if (ds) {\n            km = ds.get_key_manager()\n          }\n          if (km) {\n            resolve(km.get_pgp_fingerprint().toString('hex'));\n          } else {\n            reject(Error('could not verify file'))\n          }\n        })\n      }\n    })\n  }\n\n  async verifyFile(filePath: string, signaturePath: string, publicKey?: string | Buffer): Promise<string> {\n    // Get key if provided\n    let keyBuffer: Buffer\n    if (publicKey) {\n      if (typeof publicKey === 'string') {  // Path\n        // Read in from fs\n        keyBuffer = fs.readFileSync(publicKey)\n      } else {  // Buffer\n        keyBuffer = publicKey\n      }\n    }\n    // Read in file buffer and signature\n    const fileBuffer = fs.readFileSync(filePath)\n    const signatureBuffer = fs.readFileSync(signaturePath)\n    const verified = await this.verifyData(fileBuffer, signatureBuffer, keyBuffer!)\n    return verified\n  }\n\n  async signFile(path: string, privateKey?: string | Buffer, privateKeyPassphrase?: string): Promise<string> {\n    // Get key if provided\n    let keyBuffer: Buffer\n    if (privateKey) {\n      if (typeof privateKey === 'string') {  // Path\n        // Read in from fs\n        keyBuffer = Buffer.from(fs.readFileSync(privateKey))\n      } else {  // Buffer\n        keyBuffer = privateKey\n      }\n    }\n    // Read file into buffer\n    const buffer = Buffer.from(fs.readFileSync(path))\n    // Sign the buffer\n    const signedBuffer = await this.signData(buffer, keyBuffer!, privateKeyPassphrase)\n    // Write buffer to signed file\n    const signedPath = `${path}.sig`\n    fs.writeFileSync(signedPath, signedBuffer)\n    return signedPath\n  }\n\n  // Encrypt data\n  async encryptData(data: Buffer, forPubKey: Buffer): Promise<string> {\n    return new Promise<string>(async (resolve, reject) => {\n      let resolvedIdentity: Object\n      try {\n        resolvedIdentity = await this.getIdentityFromPublicKey(forPubKey)\n      } catch (err) {\n        throw(Error(`Identity could not be resolved for encrypting: ${err}`))\n      }\n\n      if (this.useWebWorkers && this.workerPool) {\n        const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n          return await workerCrypto.encryptData(data, resolvedIdentity);\n        });\n        resolve(workerResponse)\n      } else {\n        const params = {\n          msg: data,\n          encrypt_for: resolvedIdentity\n        }\n        kbpgp.box(params, (err: Error, result_string: string, result_buffer: Buffer) => {\n          if (err) {\n            reject(err)\n          }\n          resolve(result_string)\n        })\n      }\n    })\n  }\n\n  // Decrypt data\n  async decryptData(data: string, withKey?: Buffer): Promise<Buffer> {\n    return new Promise<Buffer>(async (resolve, reject) => {\n      var ring = new kbpgp.keyring.KeyRing;\n      let resolvedIdentity: Object\n      if (withKey) {\n        resolvedIdentity = await this.getIdentityFromPublicKey(withKey)\n      } else if (this.primaryIdentity) {\n        resolvedIdentity = this.primaryIdentity\n      } else {\n        throw(Error('no identity available for signing'))\n      }\n\n      if (this.useWebWorkers && this.workerPool) {\n        const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n          return await workerCrypto.decryptData(data, resolvedIdentity);\n        });\n        resolve(workerResponse)\n      } else {\n        ring.add_key_manager(resolvedIdentity)\n        const params = {\n          armored: data,\n          keyfetch: ring\n        }\n        kbpgp.unbox(params, (err, literals) => {\n          if (err) {\n            reject(err)\n          }\n          try {\n            const decryptedData = Buffer.from(literals[0].toString())\n            resolve(decryptedData)\n          } catch (err) {\n            reject(err)\n          }\n        })\n      }\n    })\n  }\n\n  getKey(name: string): Buffer {\n    return this.derivedKeys[name]\n  }\n\n  isLoaded(): boolean {\n    if (this.derivedKeys[name]) {\n      return true\n    }\n    return false\n  }\n}\n\nexport default KeyManager\nexport { KeyPair}\n","module.exports = require(\"kbpgp\");","module.exports = require(\"util\");","import PeerInfo from \"@polykey/PeerStore/PeerInfo\"\n\n/**\n * Responsible for managing known peers, as well as their addresses and metadata\n */\nclass PeerStore {\n  localPeerInfo: PeerInfo\n  peers: Map<string, PeerInfo>\n  constructor(peerInfo: PeerInfo) {\n    this.localPeerInfo = peerInfo\n    this.peers = new Map()\n  }\n\n  /**\n   * Stores the peerInfo of a new peer.\n   * If already exist, its info is updated.\n   */\n  put(peerInfo: PeerInfo): void {\n    // Already know the peer?\n    if (this.has(peerInfo.publicKey)) {\n      this.update(peerInfo)\n    } else {\n      this.add(peerInfo)\n    }\n  }\n\n  /**\n   * Add a new peer to the store.\n   */\n  add(peerInfo: PeerInfo): void {\n    this.peers.set(peerInfo.publicKey, peerInfo)\n  }\n\n  /**\n   * Updates an already known peer.\n   */\n  update(peerInfo: PeerInfo): void {\n    this.peers.set(peerInfo.publicKey, peerInfo)\n  }\n\n  /**\n   * Get the info to the given id.\n   */\n  get(pubKey: string): PeerInfo | null {\n    return this.peers.get(pubKey) ?? null\n  }\n\n  /**\n   * Has the info to the given id.\n   */\n  has(pubKey: string): boolean {\n    return this.peers.has(pubKey)\n  }\n}\n\nexport default PeerStore\n","module.exports = require(\"protobufjs\");","import fetch from 'node-fetch'\nimport KeyManager from \"@polykey/KeyManager\";\nimport PeerInfo from \"@polykey/PeerStore/PeerInfo\";\nimport PeerStore from \"@polykey/PeerStore/PeerStore\";\nimport MulticastBroadcaster from \"@polykey/P2P/MulticastBroadcaster\";\nimport { firstPromiseFulfilled } from '@polykey/utils';\n\ninterface SocialDiscovery {\n  // Must return a public pgp key\n  name: string\n  findUser(handle: string, service: string): Promise<string>\n}\n\nconst keybaseLookup = async (handle: string, service: string): Promise<string> => {\n  const url = `https://keybase.io/_/api/1.0/user/lookup.json?${service}=${handle}`\n\n  try {\n    const response = await fetch(url)\n    const data = await response.json()\n\n    const pubKey = data.them[0].public_keys.primary.bundle\n    return pubKey\n  } catch (err) {\n    throw new Error(`User was not found: ${err.message}`)\n  }\n}\nconst keybaseDiscovery: SocialDiscovery = {\n  name: 'Keybase',\n  findUser: keybaseLookup\n}\n\nclass PeerDiscovery {\n  peerStore: PeerStore\n  keyManager: KeyManager\n  multicastBroadcaster: MulticastBroadcaster\n  private socialDiscoveryServices: SocialDiscovery[]\n\n  constructor(\n    peerStore: PeerStore,\n    keyManager: KeyManager,\n    socialDiscoveryServices: SocialDiscovery[] = []\n  ) {\n    this.peerStore = peerStore\n    this.keyManager = keyManager\n    this.socialDiscoveryServices = socialDiscoveryServices\n\n    this.socialDiscoveryServices = []\n    this.socialDiscoveryServices.push(keybaseDiscovery)\n    for (const service of socialDiscoveryServices) {\n      this.socialDiscoveryServices.push(service)\n    }\n\n    this.multicastBroadcaster = new MulticastBroadcaster(this.peerStore, this.keyManager)\n  }\n\n  async findPubKey(pubKey: string): Promise<PeerInfo> {\n    return new Promise<PeerInfo>((resolve, reject) => {\n      this.multicastBroadcaster.requestPeerContact(pubKey)\n      this.multicastBroadcaster.on('found', (peerInfo: PeerInfo) => {\n        if (peerInfo.publicKey == pubKey) {\n          resolve(peerInfo)\n        }\n      })\n\n      this.multicastBroadcaster.on('timeout', (timedOutPubKey: string) => {\n        if (timedOutPubKey == pubKey) {\n          reject('The broadcaster stopped looking')\n        }\n      })\n    })\n  }\n\n  async findSocialUser(handle: string, service: string): Promise<PeerInfo> {\n    const tasks: Promise<string>[] = []\n    for (const socialDiscovery of this.socialDiscoveryServices) {\n\n      try {\n        tasks.push(socialDiscovery.findUser(handle, service))\n      } catch (error) {\n        console.log(`Could not find user on this discovery service: ${socialDiscovery.name}`);\n      }\n    }\n\n    const pubKeyOrFail = await firstPromiseFulfilled(tasks)\n    if (pubKeyOrFail.length > 1) {\n      throw new Error('Could not find public key from services')\n    }\n\n    const pubKeyFound = pubKeyOrFail[0]\n    const peerInfo = await this.findPubKey(pubKeyFound)\n    return peerInfo\n  }\n}\n\nexport default PeerDiscovery\nexport { SocialDiscovery }\n","module.exports = require(\"node-fetch\");","import dgram from 'dgram'\nimport crypto from 'crypto'\nimport { EventEmitter } from 'events'\nimport KeyManager from '@polykey/KeyManager'\nimport RPCMessage from '@polykey/RPC/RPCMessage'\nimport PeerStore from '@polykey/PeerStore/PeerStore'\n\n// This module is based heavily on libp2p's mDNS module:\n// https://github.com/libp2p/js-libp2p-mdns\n// It is supposed to discover peers on the local network\n// This module was also generated with the help of:\n// https://nrempel.com/using-udp-multicast-with-node-js/\n//\n// \"\"\"\n// In computer networking, the multicast DNS (mDNS) protocol\n// resolves hostnames to IP addresses within small networks\n// that do not include a local name server\n// \"\"\"\n\nconst UDP_MULTICAST_PORT = parseInt(process.env.UDP_MULTICAST_PORT ?? '5353');\nconst UDP_MULTICAST_ADDR = process.env.UDP_MULTICAST_ADDR ?? \"224.0.0.251\";\n\ntype PeerMessage = {\n  encryptedLocalPubKey: Buffer\n  encryptedPeerPubKey: Buffer\n  rawRandomMessage: Buffer\n  encryptedRandomMessage: Buffer\n}\n\nclass MulticastBroadcaster extends EventEmitter {\n  peerStore: PeerStore\n  keyManager: KeyManager\n\n  socket: dgram.Socket\n\n  interval: number\n  queryInterval: NodeJS.Timeout | null\n  peerPubKeyMessages: Map<string, PeerMessage> = new Map()\n  constructor(\n    peerStore: PeerStore,\n    keyManager: KeyManager\n  ) {\n    super()\n\n    this.peerStore = peerStore\n    this.keyManager = keyManager\n\n    this.interval = (1e3)\n    this.queryInterval = null\n\n    // Create socket\n    this.socket = dgram.createSocket({ type: \"udp4\", reuseAddr: true })\n    this.socket.bind(<number>UDP_MULTICAST_PORT)\n\n    // Set up listener\n    this.socket.on(\"listening\", (() => {\n      this.socket.addMembership(UDP_MULTICAST_ADDR);\n      const address = this.socket.address();\n      console.log(\n        `UDP socket listening on ${address.address}:${address.port} pid: ${\n          process.pid\n        }`\n      );\n    }).bind(this));\n\n    // Handle messages\n    this.socket.on(\"message\", this.handleHandshakeMessages.bind(this));\n\n    // Start the query process\n    this.queryInterval = this.queryLAN()\n  }\n\n\n  queryLAN() {\n    const query = () => {\n      for (const pubKey of this.peerPubKeyMessages.keys()) {\n        const peerMessage = this.peerPubKeyMessages.get(pubKey)\n        if (peerMessage) {\n          const handshakeMessage = RPCMessage.encodeHandshakeMessage(\n            peerMessage.encryptedPeerPubKey,\n            peerMessage.encryptedLocalPubKey,\n            peerMessage.encryptedRandomMessage\n          )\n\n          this.socket.send(handshakeMessage, 0, handshakeMessage.length, UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR, () => {\n            console.info(`Sending message to peer`);\n          });\n        }\n\n      }\n    }\n\n    // Immediately start a query, then do it every interval.\n    query()\n    return setInterval(query, this.interval)\n  }\n\n  private async handleHandshakeMessages(message: any, rinfo: any) {\n    try {\n      const decodedMessage = RPCMessage.decodeHandshakeMessage(message)\n      console.info(`Message from: ${rinfo.address}:${rinfo.port}`);\n\n\n      // Try to decrypt message and pubKey\n      const decryptedMessage = await this.keyManager.decryptData(decodedMessage.message.toString())\n      const decryptedTargetPubKey = await this.keyManager.decryptData(decodedMessage.targetPubKey.toString())\n      const decryptedRequestingPubKey = await this.keyManager.decryptData(decodedMessage.requestingPubKey.toString())\n\n      const myPubKey = this.keyManager.getPublicKey()\n\n      if (decryptedRequestingPubKey.toString() == myPubKey) { // Response\n        // Make sure decrypted bytes equal raw bytes in memory\n        const originalMessage = this.peerPubKeyMessages.get(decryptedTargetPubKey.toString())?.rawRandomMessage\n\n        if (decryptedMessage.toString() == originalMessage?.toString()) {  // Validated!\n          // Add peer info to peerStore\n          const newPeerInfo = decodedMessage.responsePeerInfo\n          if (newPeerInfo) {\n            this.peerStore.add(newPeerInfo)\n            // Remove peerId from requested messages\n            const pubKey = newPeerInfo.publicKey\n            this.peerPubKeyMessages.delete(pubKey)\n            console.log(`New peer added to the store`);\n            this.emit('found', newPeerInfo)\n          } else {\n            this.emit('error', \"I got a validated response. But no peerInfo\");\n          }\n        }\n      } else {  // Requests on target node\n        // Try decrypting message\n        // Re-encrypt the data and send it on its way\n\n        const encryptedTargetPubKey = await this.keyManager.encryptData(Buffer.from(myPubKey), decryptedRequestingPubKey)\n        const encryptedMessage = await this.keyManager.encryptData(decryptedMessage, decryptedRequestingPubKey)\n        const encryptedPubKey = await this.keyManager.encryptData(decryptedRequestingPubKey, decryptedRequestingPubKey)\n        const handshakeMessage = RPCMessage.encodeHandshakeMessage(\n          Buffer.from(encryptedTargetPubKey),\n          Buffer.from(encryptedPubKey),\n          Buffer.from(encryptedMessage),\n          this.peerStore.localPeerInfo\n        )\n        this.socket.send(handshakeMessage, 0, handshakeMessage.length, <number>UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR);\n      }\n    } catch (err) { // Couldn't decode message\n      // We don't want the multicast discovery to error on every message it coudln't decode!\n    }\n  }\n\n  async requestPeerContact(pubKey: string) {\n    const pubKeyBuf = Buffer.from(pubKey)\n    const randomMessage = crypto.randomBytes(16)\n    // Encrypt message\n    const encryptedPeerPubKey = await this.keyManager.encryptData(pubKeyBuf, pubKeyBuf)\n    const encryptedRandomMessage = await this.keyManager.encryptData(randomMessage, pubKeyBuf)\n    const encryptedLocalPubKey = await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()), pubKeyBuf)\n\n    // Add to peer messages to be sent over multicast\n    this.peerPubKeyMessages.set(pubKey, {\n      encryptedLocalPubKey: Buffer.from(encryptedLocalPubKey),\n      encryptedPeerPubKey: Buffer.from(encryptedPeerPubKey),\n      rawRandomMessage: randomMessage,\n      encryptedRandomMessage: Buffer.from(encryptedRandomMessage)\n    })\n  }\n}\n\nexport default MulticastBroadcaster\n","module.exports = require(\"dgram\");","module.exports = require(\"events\");","function randomString(): string {\n\treturn Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5)\n}\n\nfunction invertPromise<T>(p: Promise<T>): Promise<T> {\n  return new Promise((res, rej) => p.then(rej, res));\n}\n\nfunction firstPromiseFulfilled<T>(ps: Promise<T>[]) {\n  return invertPromise(Promise.all(ps.map(invertPromise)))\n}\n\nexport { randomString, firstPromiseFulfilled }\n"],"sourceRoot":""}