{"version":3,"sources":["webpack://polykey/webpack/universalModuleDefinition","webpack://polykey/webpack/bootstrap","webpack://polykey/external \"path\"","webpack://polykey/external \"os\"","webpack://polykey/./src/lib/peers/PeerInfo.ts","webpack://polykey/external \"readable-stream\"","webpack://polykey/external \"http\"","webpack://polykey/./src/lib/git/upload-pack/GitPktLine.ts","webpack://polykey/./src/lib/git/upload-pack/GitRefManager.ts","webpack://polykey/external \"pako\"","webpack://polykey/./src/lib/git/pack-objects/GitCommit.ts","webpack://polykey/./src/lib/git/pack-objects/GitObjectManager.ts","webpack://polykey/external \"fs\"","webpack://polykey/./src/lib/keys/KeyManager.ts","webpack://polykey/external \"crypto\"","webpack://polykey/./src/lib/peers/PeerManager.ts","webpack://polykey/./src/lib/rpc/RPCMessage.ts","webpack://polykey/./src/lib/vaults/VaultManager.ts","webpack://polykey/external \"isomorphic-git\"","webpack://polykey/external \"encryptedfs\"","webpack://polykey/./src/lib/HttpRequest.ts","webpack://polykey/external \"virtualfs\"","webpack://polykey/./src/lib/index.ts","webpack://polykey/./src/lib/Polykey.ts","webpack://polykey/./src/lib/git/GitServer.ts","webpack://polykey/external \"querystring\"","webpack://polykey/./src/lib/git/upload-pack/uploadPack.ts","webpack://polykey/./src/lib/git/upload-pack/GitPackedRefs.ts","webpack://polykey/./src/lib/git/side-band/GitSideBand.ts","webpack://polykey/external \"buffer\"","webpack://polykey/./src/lib/git/pack-objects/packObjects.ts","webpack://polykey/./src/lib/git/pack-objects/log.ts","webpack://polykey/./src/lib/git/pack-objects/GitObject.ts","webpack://polykey/./src/lib/git/pack-objects/shasum.ts","webpack://polykey/external \"sha.js/sha1\"","webpack://polykey/./src/lib/git/pack-objects/GitTree.ts","webpack://polykey/external \"sha.js\"","webpack://polykey/external \"kbpgp\"","webpack://polykey/external \"util\"","webpack://polykey/external \"net\"","webpack://polykey/external \"tls\"","webpack://polykey/external \"protobufjs\"","webpack://polykey/./src/lib/utils.ts","webpack://polykey/./src/lib/peers/MulticastBroadcaster.ts","webpack://polykey/external \"dgram\"","webpack://polykey/external \"events\"","webpack://polykey/./src/lib/pki/PublicKeyInfrastructure.ts","webpack://polykey/external \"node-forge\"","webpack://polykey/./src/lib/vaults/Vault.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","Address","ip","port","addressString","components","split","addressInfo","address","toString","pubKey","addresses","connectedAddr","publicKey","Set","map","addr","parse","undefined","has","add","Buffer","from","line","hexlength","b","repeat","length","padHex","concat","stream","async","slice","parseInt","buffer","err","console","log","compareRefNames","a","_a","replace","_b","tmp","endsWith","GIT_FILES","GitRefManager","fileSystem","gitdir","text","readFileSync","encoding","refs","filepath","packedMap","packedRefs","files","recursiveDirectoryWalk","dir","Promise","resolve","reject","results","promises","readdir","then","list","pending","forEach","file","stat","isDirectory","res","push","catch","x","keys","startsWith","includes","sort","ref","depth","test","allpaths","refpaths","filter","sha","trim","Error","negateExceptForZero","formatTimezoneOffset","minutes","sign","Math","is","abs","hours","floor","strHours","String","strMinutes","parseTimezoneOffset","offset","match","Number","parseAuthor","author","email","timestamp","timezoneOffset","normalize","str","indent","join","GitCommit","commit","_commit","isBuffer","render","payload","signature","headers","justHeaders","message","justMessage","parseHeaders","assign","indexOf","hs","h","obj","parent","Array","isArray","committer","tree","gpgsig","renderHeaders","PackfileCache","Map","GitObjectManager","oid","format","source","getExternalRefDelta","read","readdirSync","filename","offsets","pack","load","result","inflate","type","unwrap","polyKeyPath","homedir","passphrase","useWebWorkers","workerPool","primaryKeyPair","private","public","metadata","privateKeyPath","publicKeyPath","derivedKeys","polykeyPath","keypairPath","existsSync","mkdirSync","metadataPath","loadMetadata","privateKey","loadKeyPair","nbits","replacePrimary","progressCallback","flags","openpgp","params","asp","ASP","progress_hook","userid","primary","certify_keys","sign_data","auth","encrypt_comm","encrypt_storage","expire_in","subkeys","identity","promisify","KeyManager","generate","export_pgp_public","keypair","export_pgp_private","primaryIdentity","loadPrivateKey","loadPublicKey","loadIdentity","keyBuffer","readFile","writeMetadata","getPublicKey","getPrivateKey","import_from_armored_pgp","armored","merge_pgp_private","is_pgp_locked","unlock_pgp","path","writeFile","salt","randomBytes","pbkdf2Sync","pbkdf2","createPath","dirname","recursive","writeFileSync","mkdir","data","keyPassphrase","resolvedIdentity","getIdentityFromPrivateKey","queue","workerCrypto","signData","msg","sign_with","result_string","box","filePath","signedBuffer","signedPath","ring","keyring","KeyRing","getIdentityFromPublicKey","add_key_manager","verifyData","keyfetch","keyManager","dataSigner","unbox","get_data_signer","get_key_manager","get_pgp_fingerprint","signaturePath","fileBuffer","signatureBuffer","encryptData","encrypt_for","decryptData","literals","JSON","stringify","keybaseDiscovery","findUser","handle","service","url","response","fetch","json","them","public_keys","bundle","peerInfo","socialDiscoveryServices","localPeerInfo","hasPublicKey","peerStore","multicastBroadcaster","addPeer","keyPem","certPem","createX509Certificate","options","cert","requestCert","rejectUnauthorized","server","createServer","socket","authorized","listen","connect","set","requestPeerContact","on","timedOutPubKey","tasks","socialDiscovery","error","pubKeyOrFail","firstPromiseFulfilled","pubKeyFound","findPubKey","peer","host","existingSocket","peerConnections","getPeer","encodePeerInfo","decodePeerInfo","PeerInfoMessage","loadProto","lookupType","errMsg","verify","encode","finish","decode","toObject","enums","longs","bytes","defaults","arrays","objects","oneofs","targetPubKey","requestingPubKey","responsePeerInfo","HandshakeMessage","encodedMmessage","Root","resolvePath","origin","target","__filename","loadSync","vaults","vaultKeys","vaultName","vaultKey","entries","vault","validateVault","vaultExists","generateKey","initRepository","getVault","destroyVault","getSocket","vaultUrl","httpRequest","getRemoteInfo","http","vfsInstance","VirtualFS","newEfs","EncryptedFS","process","clone","fs","singleBranch","rmdirSync","delete","vaultPath","encryptedMetadata","method","body","onProgress","pathname","search","URL","createConnection","req","request","iter","httpMessageToIter","statusCode","statusMessage","write","end","ended","defer","chunk","shift","done","next","default","vaultManager","peerManager","gitServer","connectLocalPeerInfo","services","fromAddressInfo","peerCanAccess","setHeader","handleInfoRequest","handlePackRequest","splitUrl","notFoundResponse","query","repo","infoResponse","noCache","repoDir","exists","wantedObjectId","packResult","readable","PassThrough","progressStream","mux","packstream","pipe","uploadPackRespond","hexPrefix","createGitPacketLine","buffers","buffersToWrite","Readable","advertiseRefs","capabilities","listRefs","unshift","symrefs","syms","caps","flush","writeRefsAdResponse","caller","GitPackedRefs","parsedConfig","comment","peeled","splitBuffer","maxBytes","index","buf","input","streamReader","packetlines","packfile","progress","nextBit","destroy","protocol","MAX_PACKET_LENGTH","output","packfileWasEmpty","packfileEnded","progressEnded","goodbye","types","blob","tag","ofs_delta","ref_delta","listObjects","oids","commits","trees","blobs","walk","entry","outputStream","hash","enc","update","writeObject","stype","lastFour","multibyte","byte","unpaddedChunk","deflate","digest","haves","shallows","unshallows","acks","oldshallows","logCommit","signing","withoutSignature","compareAge","since","sinceTimestamp","valueOf","tips","pop","byteLength","actualLength","nudgeIntoShape","limitModeToAllowed","GitTree","_entries","cursor","space","nullchar","parseBuffer","iterator","invertPromise","rej","randomString","random","substr","ps","all","UDP_MULTICAST_PORT","env","UDP_MULTICAST_ADDR","MulticastBroadcaster","EventEmitter","super","peerPubKeyMessages","interval","queryInterval","createSocket","reuseAddr","addMembership","handleHandshakeMessages","queryLAN","pubKeyBuf","randomMessage","encryptedPeerPubKey","encryptedRandomMessage","encryptedLocalPubKey","rawRandomMessage","peerMessage","handshakeMessage","encodeHandshakeMessage","send","info","setInterval","rinfo","decodedMessage","decodeHandshakeMessage","decryptedMessage","decryptedTargetPubKey","decryptedRequestingPubKey","myPubKey","originalMessage","newPeerInfo","emit","encryptedTargetPubKey","encryptedMessage","encryptedPubKey","PublicKeyInfrastructure","N_BITS","commonName","COMMON_NAME","organizationName","ORGANIZATION_NAME","pki","rsa","generateKeyPair","createCertificate","serialNumber","validity","notBefore","Date","notAfter","setFullYear","getFullYear","attrs","setSubject","setIssuer","setExtensions","cA","keyCertSign","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","serverAuth","clientAuth","codeSigning","emailProtection","timeStamping","client","objsign","sslCA","emailCA","objCA","altNames","privateKeyToPem","certificateToPem","symKey","baseDir","keyLen","efs","secrets","loadSecrets","secretName","secretPath","secret","writePath","commitChanges","secretBuf","successful","unlink","sharedPubKeys","remoteUrl","currentBranch","fullname","pull","init","fileContents","action","remove"],"mappings":"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","file":"polykey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"polykey\"] = factory();\n\telse\n\t\troot[\"polykey\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n","module.exports = require(\"path\");","module.exports = require(\"os\");","import { AddressInfo } from 'net'\n\nclass Address {\n  ip: string\n  port: string\n  constructor(\n    ip: string,\n    port: string\n  ) {\n    this.ip = ip\n    this.port = port\n  }\n\n  /**\n   * Create an address object from a address string\n   * @param addressString Address string in the format of `${this.ip}:${this.port}`\n   */\n  static parse(addressString: string): Address {\n    const components = addressString.split(':')\n    const ip = components[0]\n    const port = components[1]\n\n    return new Address(ip, port)\n  }\n\n  /**\n   * Create an address object from a net.AddressInfo\n   * @param addressInfo AddressInfo of desired address\n   */\n  static fromAddressInfo(addressInfo: AddressInfo) {\n    const ip = (addressInfo.address == '::') ? '127.0.0.1' : addressInfo.address\n    return new Address(ip, addressInfo.port.toString())\n  }\n\n  /**\n   * Convert address into string of format `${this.ip}:${this.port}`\n   */\n  toString() {\n    return `${this.ip}:${this.port}`\n  }\n}\n\nAddress.prototype.toString = function() {\n  return `${this.ip}:${this.port}`\n}\n\nclass PeerInfo {\n  publicKey: string\n  addresses: Set<Address>\n  connectedAddr?: Address\n  constructor(\n    pubKey: string,\n    addresses: string[] = [],\n    connectedAddr?: string\n  ) {\n    this.publicKey = pubKey\n    this.addresses = new Set(addresses.map((addr) => {\n      return Address.parse(addr)\n    }))\n    this.connectedAddr = (connectedAddr) ? Address.parse(connectedAddr) : undefined\n  }\n\n  /**\n   * Sets the main server address for the peer\n   * @param address Main server address for peer\n   */\n  connect(address: Address) {\n    if (!this.addresses.has(address)) {\n      this.addresses.add(address)\n    }\n\n    this.connectedAddr = address\n  }\n\n  /**\n   * Clears the main server address for the peer\n   */\n  disconnect() {\n    this.connectedAddr = undefined\n  }\n}\n\nexport default PeerInfo\nexport { Address }\n","module.exports = require(\"readable-stream\");","module.exports = require(\"http\");","/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementors MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\n\n\nfunction padHex(b, n) {\n  const s = n.toString(16)\n  return '0'.repeat(b - s.length) + s\n}\n\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\n\nclass GitPktLine {\n  static flush() {\n    return Buffer.from('0000', 'utf8')\n  }\n\n  static encode(line) {\n    if (typeof line === 'string') {\n      line = Buffer.from(line)\n    }\n    const length = line.length + 4\n    const hexlength = padHex(4, length)\n    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])\n  }\n\n  static streamReader (stream) {\n    return async function read () {\n      try {\n        let length = await stream.slice(4)\n        if (length === null) return true\n        length = parseInt(length.toString('utf8'), 16)\n        if (length === 0) return null\n        let buffer = await stream.slice(length - 4)\n        if (buffer === null) return true\n        return buffer\n      } catch (err) {\n        console.log('error', err)\n        return true\n      }\n    }\n  }\n}\n\nexport default GitPktLine\n","// This is a convenience wrapper for reading and writing files in the 'refs' directory.\nimport path from 'path'\nimport { EncryptedFS } from 'encryptedfs'\nimport GitPackedRefs from './GitPackedRefs'\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst refpaths = ref => [\n  `${ref}`,\n  `refs/${ref}`,\n  `refs/tags/${ref}`,\n  `refs/heads/${ref}`,\n  `refs/remotes/${ref}`,\n  `refs/remotes/${ref}/HEAD`,\n]\n\nfunction compareRefNames(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  const _a = a.replace(/\\^\\{\\}$/, '')\n  const _b = b.replace(/\\^\\{\\}$/, '')\n  const tmp = -(_a < _b) || +(_a > _b)\n  if (tmp === 0) {\n    return a.endsWith('^{}') ? 1 : -1\n  }\n  return tmp\n}\n\n\n// @see https://git-scm.com/docs/gitrepository-layout\nconst GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir']\n\n\n// This function is used to get all the files in the refs folder for listRefs function\nasync function recursiveDirectoryWalk(dir: string, fileSystem: EncryptedFS): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n    let results: string[] = [];\n    fileSystem.promises.readdir(dir).then(async (list) => {\n      var pending = list.length;\n      if (!pending) return resolve(results);\n      list.forEach(async function(file) {\n        file = path.resolve(dir, file);\n        fileSystem.promises.stat(file).then(async (stat) => {\n          if (stat && stat.isDirectory()) {\n            const res = await recursiveDirectoryWalk(file, fileSystem)\n            results = results.concat(res);\n            if (!--pending) resolve(results);\n          } else {\n            results.push(file);\n            if (!--pending) resolve(results);\n          }\n        });\n      });\n    }).catch((err) => {\n      if (err) return reject(err);\n    })\n  })\n};\n\nclass GitRefManager {\n  static async packedRefs(fileSystem: EncryptedFS, gitdir: string) {\n    const text = fileSystem.readFileSync(`${gitdir}/packed-refs`, { encoding: 'utf8' })\n    const packed = GitPackedRefs.from(text)\n    return packed.refs\n  }\n\n  // List all the refs that match the `filepath` prefix\n  static async listRefs(fileSystem: EncryptedFS, gitdir: string, filepath: string): Promise<string[]> {\n    const packedMap = GitRefManager.packedRefs(fileSystem, gitdir)\n    let files: string[] = []\n    try {\n      files = await recursiveDirectoryWalk(`${gitdir}/${filepath}`, fileSystem)\n\n      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''))\n    } catch (err) {\n      files = []\n    }\n\n    for (let key of (await packedMap).keys()) {\n      // filter by prefix\n      if (key.startsWith(filepath)) {\n        // remove prefix\n        key = key.replace(filepath + '/', '')\n        // Don't include duplicates; the loose files have precedence anyway\n        if (!files.includes(key)) {\n          files.push(key)\n        }\n      }\n    }\n    // since we just appended things onto an array, we need to sort them now\n    files.sort(compareRefNames)\n\n    return files\n  }\n  static async resolve(fileSystem: EncryptedFS, gitdir: string, ref: string, depth?: number) {\n    if (depth !== undefined) {\n      depth--\n      if (depth === -1) {\n        return ref\n      }\n    }\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length)\n      return GitRefManager.resolve(fileSystem, gitdir, ref, depth)\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs(fileSystem, gitdir)\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)) // exclude git system files (#709)\n\n    for (const ref of allpaths) {\n      const sha = (fileSystem.readFileSync(`${gitdir}/${ref}`, { encoding: 'utf8' }).toString()) || packedMap.get(ref)\n      if (sha) {\n        return GitRefManager.resolve(fileSystem, gitdir, sha.trim(), depth)\n      }\n    }\n    // Do we give up?\n    throw(Error('RefNotFound'))\n  }\n\n}\n\nexport default GitRefManager\n","module.exports = require(\"pako\");","// The amount of work that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction simpleSign (n) {\n  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)\n}\n\nfunction negateExceptForZero (n) {\n  return n === 0 ? n : -n\n}\n\nfunction formatTimezoneOffset (minutes) {\n  let sign = simpleSign(negateExceptForZero(minutes))\n  minutes = Math.abs(minutes)\n  let hours = Math.floor(minutes / 60)\n  minutes -= hours * 60\n  let strHours = String(hours)\n  let strMinutes = String(minutes)\n  if (strHours.length < 2) strHours = '0' + strHours\n  if (strMinutes.length < 2) strMinutes = '0' + strMinutes\n  return (sign === -1 ? '-' : '+') + strHours + strMinutes\n}\n\nfunction parseTimezoneOffset (offset) {\n  let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/)\n  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes))\n  return negateExceptForZero(minutes)\n}\n\nfunction parseAuthor (author) {\n  let [, name, email, timestamp, offset] = author.match(\n    /^(.*) <(.*)> (.*) (.*)$/\n  )\n  return {\n    name: name,\n    email: email,\n    timestamp: Number(timestamp),\n    timezoneOffset: parseTimezoneOffset(offset)\n  }\n}\n\nfunction normalize (str) {\n  // remove all <CR>\n  str = str.replace(/\\r/g, '')\n  // no extra newlines up front\n  str = str.replace(/^\\n+/, '')\n  // and a single newline at the end\n  str = str.replace(/\\n+$/, '') + '\\n'\n  return str\n}\n\nfunction indent (str) {\n  return (\n    str\n      .trim()\n      .split('\\n')\n      .map(x => ' ' + x)\n      .join('\\n') + '\\n'\n  )\n}\n\nfunction outdent (str) {\n  return str\n    .split('\\n')\n    .map(x => x.replace(/^ /, ''))\n    .join('\\n')\n}\n\n// TODO: Make all functions have static async signature?\n\nclass GitCommit {\n  _commit: string\n  constructor (commit) {\n    if (typeof commit === 'string') {\n      this._commit = commit\n    } else if (Buffer.isBuffer(commit)) {\n      this._commit = commit.toString('utf8')\n    } else if (typeof commit === 'object') {\n      this._commit = GitCommit.render(commit)\n    } else {\n      throw(new Error('invalid type passed to GitCommit constructor'))\n    }\n  }\n\n  static fromPayloadSignature ({ payload, signature }) {\n    let headers = GitCommit.justHeaders(payload)\n    let message = GitCommit.justMessage(payload)\n    let commit = normalize(\n      headers + '\\ngpgsig' + indent(signature) + '\\n' + message\n    )\n    return new GitCommit(commit)\n  }\n\n  static from (commit) {\n    return new GitCommit(commit)\n  }\n\n  toObject () {\n    return Buffer.from(this._commit, 'utf8')\n  }\n\n  // Todo: allow setting the headers and message\n  headers () {\n    return this.parseHeaders()\n  }\n\n  // Todo: allow setting the headers and message\n  message () {\n    return GitCommit.justMessage(this._commit)\n  }\n\n  parse () {\n    return Object.assign({ message: this.message() }, this.headers())\n  }\n\n  static justMessage (commit) {\n    return normalize(commit.slice(commit.indexOf('\\n\\n') + 2))\n  }\n\n  static justHeaders (commit) {\n    return commit.slice(0, commit.indexOf('\\n\\n'))\n  }\n\n  parseHeaders () {\n    let headers = GitCommit.justHeaders(this._commit).split('\\n')\n    let hs: string[] = []\n    for (let h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1)\n      } else {\n        hs.push(h)\n      }\n    }\n    let obj: any = {\n      parent: []\n    }\n    for (let h of hs) {\n      let key = h.slice(0, h.indexOf(' '))\n      let value = h.slice(h.indexOf(' ') + 1)\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value)\n      } else {\n        obj[key] = value\n      }\n    }\n    if (obj.author) {\n      obj.author = parseAuthor(obj.author)\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer)\n    }\n    return obj\n  }\n\n  static renderHeaders (obj) {\n    let headers = ''\n    if (obj.tree) {\n      headers += `tree ${obj.tree}\\n`\n    } else {\n      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n` // the null tree\n    }\n    if (obj.parent) {\n      if (obj.parent.length === undefined) {\n        throw(new Error(`commit 'parent' property should be an array`))\n      }\n      for (let p of obj.parent) {\n        headers += `parent ${p}\\n`\n      }\n    }\n    let author = obj.author\n    headers += `author ${author.name} <${author.email}> ${\n      author.timestamp\n    } ${formatTimezoneOffset(author.timezoneOffset)}\\n`\n    let committer = obj.committer || obj.author\n    headers += `committer ${committer.name} <${committer.email}> ${\n      committer.timestamp\n    } ${formatTimezoneOffset(committer.timezoneOffset)}\\n`\n    if (obj.gpgsig) {\n      headers += 'gpgsig' + indent(obj.gpgsig)\n    }\n    return headers\n  }\n\n  static render (obj) {\n    return GitCommit.renderHeaders(obj) + '\\n' + normalize(obj.message)\n  }\n\n  render () {\n    return this._commit\n  }\n\n  withoutSignature () {\n    let commit = normalize(this._commit)\n    if (commit.indexOf('\\ngpgsig') === -1) return commit\n    let headers = commit.slice(0, commit.indexOf('\\ngpgsig'))\n    let message = commit.slice(\n      commit.indexOf('-----END PGP SIGNATURE-----\\n') +\n        '-----END PGP SIGNATURE-----\\n'.length\n    )\n    return normalize(headers + '\\n' + message)\n  }\n\n  isolateSignature () {\n    let signature = this._commit.slice(\n      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._commit.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    )\n    return outdent(signature)\n  }\n}\n\nexport default GitCommit\n","import fs from 'fs'\nimport pako from 'pako'\nimport path from 'path'\nimport GitObject from './GitObject'\nimport { EncryptedFS } from 'encryptedfs'\n\nconst PackfileCache = new Map()\n\nclass GitObjectManager {\n  static async read(fileSystem: EncryptedFS, gitdir: string, oid: string, format = 'content') {\n    // Look for it in the loose object directory.\n    let file = fileSystem.readFileSync(`${gitdir}/objects/${oid.slice(0, 2)}/${oid.slice(2)}`)\n    let source = `./objects/${oid.slice(0, 2)}/${oid.slice(2)}`\n    // Check to see if it's in a packfile.\n    if (!file) {\n      // Curry the current read method so that the packfile un-deltification\n      // process can acquire external ref-deltas.\n      const getExternalRefDelta = oid =>\n        GitObjectManager.read(fileSystem, gitdir, oid)\n      // Iterate through all the .pack files\n      let list = fs.readdirSync(path.join(gitdir, '/objects/pack'))\n      list = list.filter(x => x.endsWith('.pack'))\n      for (let filename of list) {\n        // Try to get the packfile from the in-memory cache\n        let p = PackfileCache.get(filename)\n        // If the packfile DOES have the oid we're looking for...\n        if (p.offsets.has(oid)) {\n          // Make sure the packfile is loaded in memory\n          if (!p.pack) {\n            const pack = fileSystem.readFileSync(`${gitdir}/objects/pack/${filename}`)\n            await p.load({ pack })\n          }\n          // Get the resolved git object from the packfile\n          let result = await p.read({ oid, getExternalRefDelta })\n          result.source = `./objects/pack/${filename}`\n          return result\n        }\n      }\n    }\n    // Check to see if it's in shallow commits.\n    if (!file) {\n      let text = fileSystem.readFileSync(`${gitdir}/shallow`, { encoding: 'utf8' })\n      if (text !== null && text.includes(oid)) {\n        throw(new Error(`ReadShallowObjectFail: ${oid}`))\n      }\n    }\n    // Finally\n    if (!file) {\n      throw(new Error(`ReadObjectFail: ${oid}`))\n    }\n    if (format === 'deflated') {\n      return { format: 'deflated', object: file, source }\n    }\n    let buffer = Buffer.from(pako.inflate(file))\n    if (format === 'wrapped') {\n      return { format: 'wrapped', object: buffer, source }\n    }\n    let { type, object } = GitObject.unwrap({ oid, buffer })\n    if (format === 'content') return { type, format: 'content', object, source }\n  }\n}\n\nexport default GitObjectManager\n","module.exports = require(\"fs\");","import os from 'os'\nimport fs from 'fs'\nimport Path from 'path'\nimport kbpgp from 'kbpgp'\nimport crypto from 'crypto'\nimport { promisify } from 'util'\nimport { Pool, ModuleThread } from 'threads'\nimport { KeyManagerWorker } from '../keys/KeyManagerWorker'\n\ntype KeyManagerMetadata = {\n  privateKeyPath: string | null,\n  publicKeyPath: string | null\n}\n\ntype KeyPair = {\n  private: string | null,\n  public: string | null\n}\n\nclass KeyManager {\n  private primaryKeyPair: KeyPair = { private: null, public: null }\n  private primaryIdentity?: Object\n  private derivedKeys: Map<string, Buffer>\n  private useWebWorkers: boolean\n  private workerPool?: Pool<ModuleThread<KeyManagerWorker>>\n\n  polykeyPath: string\n  private fileSystem: typeof fs\n\n  private metadataPath: string\n  private metadata: KeyManagerMetadata = { privateKeyPath: null, publicKeyPath: null }\n\n  constructor(\n    polyKeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    passphrase?: string,\n    useWebWorkers: boolean = false,\n    workerPool?: Pool<ModuleThread<KeyManagerWorker>>\n  ) {\n    this.useWebWorkers = useWebWorkers\n    this.workerPool = workerPool\n    this.derivedKeys = new Map()\n    this.fileSystem = fileSystem\n\n    // Load key manager metadata\n    this.polykeyPath = polyKeyPath\n    const keypairPath = Path.join(polyKeyPath, '.keypair')\n    if (!this.fileSystem.existsSync(keypairPath)) {\n      this.fileSystem.mkdirSync(keypairPath)\n    }\n    this.metadataPath = Path.join(keypairPath, 'metadata')\n    this.loadMetadata()\n\n    // Load keys if they were provided\n    if (this.metadata.privateKeyPath && this.metadata.publicKeyPath && passphrase) {\n      // Load files into memory\n      const publicKey = this.fileSystem.readFileSync(this.metadata.publicKeyPath)\n      const privateKey = this.fileSystem.readFileSync(this.metadata.privateKeyPath)\n\n      // Load private and public keys\n      this.loadKeyPair(publicKey, privateKey, passphrase)\n    }\n\n  }\n\n  /**\n   * Generates a new assymetric key pair (publicKey and privateKey).\n   * @param name Name of keypair owner\n   * @param email Email of keypair owner\n   * @param passphrase Passphrase to lock the keypair\n   * @param nbits Size of the new keypair\n   * @param replacePrimary If true, the generated keypair becomes the new primary identity of the key manager\n   * @param progressCallback A progress hook for keypair generation\n   */\n  async generateKeyPair(\n    name: string,\n    email: string,\n    passphrase: string,\n    nbits: number = 4096,\n    replacePrimary: boolean = false,\n    progressCallback?: (info) => void\n  ): Promise<KeyPair> {\n    // Define options\n    const flags = kbpgp[\"const\"].openpgp\n    const params = {\n      asp: (progressCallback) ? new kbpgp.ASP({ progress_hook: progressCallback }) : undefined,\n      userid: `${name} <${email}>`,\n      primary: {\n        nbits: nbits,\n        flags: flags.certify_keys | flags.sign_data | flags.auth | flags.encrypt_comm | flags.encrypt_storage,\n        expire_in: 0  // never expire\n      },\n      subkeys: []\n    }\n\n    const identity = await promisify(kbpgp.KeyManager.generate)(params)\n\n    await promisify(identity.sign.bind(identity))({})\n\n    // Export pub key first\n    const publicKey = await promisify(identity.export_pgp_public.bind(identity))({})\n\n    // Finally export priv key\n    const privateKey = await promisify(identity.export_pgp_private.bind(identity))({ passphrase: passphrase })\n\n    // Resolve to parent promise\n    const keypair = { private: privateKey, public: publicKey }\n    if (replacePrimary) {\n      // Set the new keypair\n      this.primaryKeyPair = keypair\n      // Set the new identity\n      this.primaryIdentity = identity\n    }\n\n    return keypair\n  }\n\n  /**\n   * Get the primary keypair\n   */\n  getKeyPair(): KeyPair {\n    return this.primaryKeyPair\n  }\n\n  /**\n   * Determines whether public key is loaded or not\n   */\n  hasPublicKey(): boolean {\n    return (this.primaryKeyPair.public) ? true : false\n  }\n\n  /**\n   * Get the public key of the primary keypair\n   */\n  getPublicKey(): string {\n    if (!this.primaryKeyPair.public) {\n      throw new Error('Public key does not exist in memory')\n    }\n    return this.primaryKeyPair.public\n  }\n\n  /**\n   * Get the private key of the primary keypair\n   */\n  getPrivateKey(): string {\n    if (!this.primaryKeyPair.private) {\n      throw new Error('Private key does not exist in memory')\n    }\n    return this.primaryKeyPair.private\n  }\n\n  /**\n   * Loads the keypair into the key manager as the primary identity\n   * @param publicKey Public Key\n   * @param privateKey Private Key\n   * @param passphrase Passphrase to unlock the private key\n   */\n  async loadKeyPair(publicKey: string | Buffer, privateKey: string | Buffer, passphrase: string): Promise<void> {\n    await this.loadPrivateKey(privateKey)\n    await this.loadPublicKey(publicKey)\n    await this.loadIdentity(passphrase)\n  }\n\n  /**\n   * Loads the private key into the primary keypair\n   * @param privateKey Private Key\n   */\n  async loadPrivateKey(privateKey: string | Buffer): Promise<void> {\n    let keyBuffer: Buffer\n    if (typeof privateKey === 'string') {\n      keyBuffer = Buffer.from(await this.fileSystem.promises.readFile(privateKey))\n      this.metadata.privateKeyPath = privateKey\n      this.writeMetadata()\n    } else {\n      keyBuffer = privateKey\n    }\n    this.primaryKeyPair.private = keyBuffer.toString()\n  }\n\n  /**\n   * Loads the public key into the primary keypair\n   * @param publicKey Public Key\n   */\n  async loadPublicKey(publicKey: string | Buffer): Promise<void> {\n    let keyBuffer: Buffer\n    if (typeof publicKey === 'string') {\n      keyBuffer = Buffer.from(await this.fileSystem.promises.readFile(publicKey))\n      this.metadata.publicKeyPath = publicKey\n      this.writeMetadata()\n    } else {\n      keyBuffer = publicKey\n    }\n    this.primaryKeyPair.public = keyBuffer.toString()\n  }\n\n  /**\n   * Loads the primary identity into the key manager from the existing keypair\n   * @param passphrase Passphrase to unlock the private key\n   */\n  async loadIdentity(passphrase: string): Promise<void> {\n    const publicKey: string = this.getPublicKey()\n    const privateKey: string = this.getPrivateKey()\n\n    const identity = await promisify(kbpgp.KeyManager.import_from_armored_pgp)({ armored: publicKey })\n\n    await promisify(identity.merge_pgp_private.bind(identity))({ armored: privateKey })\n\n    if (identity.is_pgp_locked.bind(identity)()) {\n      await promisify(identity.unlock_pgp.bind(identity))({ passphrase: passphrase })\n    }\n\n    this.primaryIdentity = identity\n  }\n\n  /**\n   * Export the primary private key to a specified location\n   * @param path Destination path\n   */\n  async exportPrivateKey(path: string): Promise<void> {\n    await this.fileSystem.promises.writeFile(path, this.primaryKeyPair.private)\n    this.metadata.privateKeyPath = path\n    this.writeMetadata()\n  }\n\n  /**\n   * Export the primary public key to a specified location\n   * @param path Destination path\n   */\n  async exportPublicKey(path: string): Promise<void> {\n    await this.fileSystem.promises.writeFile(path, this.primaryKeyPair.public)\n    this.metadata.publicKeyPath = path\n    this.writeMetadata()\n  }\n\n  /**\n   * Synchronously generates a new symmetric key and stores it in the key manager\n   * @param name Unique name of the generated key\n   * @param passphrase Passphrase to derive the key from\n   */\n  generateKeySync(name: string, passphrase: string): Buffer {\n    const salt = crypto.randomBytes(32)\n    this.derivedKeys[name] = crypto.pbkdf2Sync(passphrase, salt, 10000, 256 / 8, 'sha256')\n\n    return this.derivedKeys[name]\n  }\n\n  /**\n   * Asynchronously Generates a new symmetric key and stores it in the key manager\n   * @param name Unique name of the generated key\n   * @param passphrase Passphrase to derive the key from\n   */\n  async generateKey(name: string, passphrase: string): Promise<Buffer> {\n    const salt = crypto.randomBytes(32)\n    this.derivedKeys[name] = await promisify(crypto.pbkdf2)(passphrase, salt, 10000, 256 / 8, 'sha256')\n\n    return this.derivedKeys[name]\n  }\n\n  /**\n   * Synchronously imports an existing key from file or Buffer\n   * @param name Unique name of the imported key\n   * @param key Key to be imported\n   */\n  importKeySync(name: string, key: string | Buffer): void {\n    if (typeof key === 'string') {\n      this.derivedKeys[name] = this.fileSystem.readFileSync(key)\n    } else {\n      this.derivedKeys[name] = key\n    }\n  }\n\n  /**\n   * Asynchronously imports an existing key from file or Buffer\n   * @param name Unique name of the imported key\n   * @param key Key to be imported\n   */\n  async importKey(name: string, key: string | Buffer): Promise<void> {\n    if (typeof key === 'string') {\n      this.derivedKeys[name] = await this.fileSystem.promises.readFile(key)\n    } else {\n      this.derivedKeys[name] = key\n    }\n  }\n\n  /**\n   * Synchronously exports an existing key from file or Buffer\n   * @param name Name of the key to be exported\n   * @param path Destination path\n   * @param createPath If set to true, the path is recursively created\n   */\n  exportKeySync(name: string, path: string, createPath?: boolean): void {\n    if (!this.derivedKeys.has(name)) {\n      throw Error(`There is no key loaded for name: ${name}`)\n    }\n    if (createPath) {\n      this.fileSystem.mkdirSync(Path.dirname(path), { recursive: true })\n    }\n    this.fileSystem.writeFileSync(path, this.derivedKeys[name])\n  }\n\n  /**\n   * Asynchronously exports an existing key from file or Buffer\n   * @param name Name of the key to be exported\n   * @param path Destination path\n   * @param createPath If set to true, the path is recursively created\n   */\n  async exportKey(name: string, path: string, createPath?: boolean): Promise<void> {\n    if (!this.derivedKeys.has(name)) {\n      throw Error(`There is no key loaded for name: ${name}`)\n    }\n    if (createPath) {\n      await this.fileSystem.promises.mkdir(Path.dirname(path), { recursive: true })\n    }\n    await this.fileSystem.promises.writeFile(path, this.derivedKeys[name])\n  }\n\n  /**\n   * Loads an identity from the given public key\n   * @param publicKey Buffer containing the public key\n   */\n  async getIdentityFromPublicKey(publicKey: Buffer): Promise<Object> {\n    const identity = await promisify(kbpgp.KeyManager.import_from_armored_pgp)({ armored: publicKey })\n    return identity\n  }\n\n  /**\n   * Loads an identity from the given private key\n   * @param publicKey Buffer containing the public key\n   */\n  async getIdentityFromPrivateKey(privateKey: Buffer, passphrase: string): Promise<Object> {\n    const identity = await promisify(kbpgp.KeyManager.import_from_armored_pgp)({ armored: privateKey })\n    if (identity.is_pgp_locked()) {\n      await promisify(identity.unlock_pgp)({ passphrase: passphrase })\n    }\n    return identity\n  }\n\n  /**\n   * Signs the given data with the provided key or the primary key if none is specified\n   * @param data Buffer or file containing the data to be signed\n   * @param privateKey Buffer containing the key to sign with. Defaults to primary private key if no key is given.\n   * @param keyPassphrase Required if privateKey is provided.\n   */\n  async signData(data: Buffer | string, privateKey?: Buffer, keyPassphrase?: string): Promise<Buffer> {\n    let resolvedIdentity: Object\n    if (privateKey) {\n      if (!keyPassphrase) {\n        throw new Error('passphrase for private key was not provided')\n      }\n      resolvedIdentity = await this.getIdentityFromPrivateKey(privateKey, keyPassphrase!)\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw new Error('no identity available for signing')\n    }\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.signData(data, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      const params = {\n        msg: data.toString(),\n        sign_with: resolvedIdentity\n      }\n      const result_string = await promisify(kbpgp.box)(params)\n\n      return Buffer.from(result_string)\n    }\n  }\n\n  /**\n   * Signs the given file with the provided key or the primary key if none is specified\n   * @param filePath Path to file containing the data to be signed\n   * @param privateKey The key to sign with. Defaults to primary public key if no key is given.\n   * @param keyPassphrase Required if privateKey is provided.\n   */\n  async signFile(filePath: string, privateKey?: string | Buffer, keyPassphrase?: string): Promise<string> {\n    // Get key if provided\n    let keyBuffer: Buffer\n    if (privateKey) {\n      if (typeof privateKey === 'string') {  // Path\n        // Read in from fs\n        keyBuffer = Buffer.from(this.fileSystem.readFileSync(privateKey))\n      } else {  // Buffer\n        keyBuffer = privateKey\n      }\n    }\n    // Read file into buffer\n    const buffer = Buffer.from(this.fileSystem.readFileSync(filePath))\n    // Sign the buffer\n    const signedBuffer = await this.signData(buffer, keyBuffer!, keyPassphrase)\n    // Write buffer to signed file\n    const signedPath = `${filePath}.sig`\n    this.fileSystem.writeFileSync(signedPath, signedBuffer)\n    return signedPath\n  }\n\n  /**\n   * Verifies the given data with the provided key or the primary key if none is specified\n   * @param data Buffer or file containing the data to be verified\n   * @param signature The PGP signature\n   * @param publicKey Buffer containing the key to verify with. Defaults to primary public key if no key is given.\n   */\n  async verifyData(data: Buffer | string, signature: Buffer, publicKey?: Buffer): Promise<boolean> {\n    const ring = new kbpgp.keyring.KeyRing;\n    let resolvedIdentity: Object\n    if (publicKey) {\n      resolvedIdentity = await this.getIdentityFromPublicKey(publicKey)\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw new Error('no identity available for verifying')\n    }\n    ring.add_key_manager(resolvedIdentity)\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.verifyData(data, signature, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      const params = {\n        armored: signature,\n        data: data,\n        keyfetch: ring\n      }\n      const literals = await promisify(kbpgp.unbox)(params)\n      // Get the identity that signed the data if any\n      let dataSigner = literals[0].get_data_signer()\n      // Retrieve the key manager associated with that data signer\n      let keyManager: any\n      if (dataSigner) {\n        keyManager = dataSigner.get_key_manager()\n      }\n      // If we know the pgp finger print then we say the data is verified.\n      // Otherwise it is unverified.\n      if (keyManager) {\n        if (keyManager.get_pgp_fingerprint()) {\n          return true\n        } else {\n          return false\n        }\n      } else {\n        return false\n      }\n    }\n  }\n\n  /**\n   * Verifies the given file with the provided key or the primary key if none is specified\n   * @param filePath Path to file containing the data to be verified\n   * @param signaturePath The path to the file containing the PGP signature\n   * @param publicKey Buffer containing the key to verify with. Defaults to primary public key if no key is given.\n   */\n  async verifyFile(filePath: string, signaturePath: string, publicKey?: string | Buffer): Promise<boolean> {\n    // Get key if provided\n    let keyBuffer: Buffer\n    if (publicKey) {\n      if (typeof publicKey === 'string') {  // Path\n        // Read in from fs\n        keyBuffer = this.fileSystem.readFileSync(publicKey)\n      } else {  // Buffer\n        keyBuffer = publicKey\n      }\n    }\n    // Read in file buffer and signature\n    const fileBuffer = this.fileSystem.readFileSync(filePath)\n    const signatureBuffer = this.fileSystem.readFileSync(signaturePath)\n    const isVerified = await this.verifyData(fileBuffer, signatureBuffer, keyBuffer!)\n    return isVerified\n  }\n\n  /**\n   * Encrypts the given data for a specific public key\n   * @param data The data to be encrypted\n   * @param publicKey The key to encrypt for\n   */\n  async encryptData(data: Buffer, publicKey?: Buffer): Promise<string> {\n    let resolvedIdentity: Object\n    if (publicKey) {\n      resolvedIdentity = await this.getIdentityFromPublicKey(publicKey)\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw new Error(`Identity could not be resolved for encrypting`)\n    }\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.encryptData(data, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      const params = {\n        msg: data,\n        encrypt_for: resolvedIdentity\n      }\n      const result_string = await promisify(kbpgp.box)(params)\n      return result_string\n    }\n  }\n\n  /**\n   * Decrypts the given data with the provided key or the primary key if none is given\n   * @param data The data to be decrypted\n   * @param privateKey The key to decrypt with. Defaults to primary private key if no key is given.\n   * @param keyPassphrase Required if privateKey is provided.\n   */\n  async decryptData(data: Buffer, privateKey?: Buffer, keyPassphrase?: string): Promise<Buffer> {\n    var ring = new kbpgp.keyring.KeyRing;\n    let resolvedIdentity: Object\n    if (privateKey) {\n      if (keyPassphrase) {\n        resolvedIdentity = await this.getIdentityFromPrivateKey(privateKey, keyPassphrase)\n      } else {\n        throw new Error('A key passphrase must be supplied if a privateKey is specified')\n      }\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw (Error('no identity available for signing'))\n    }\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.decryptData(data, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      ring.add_key_manager(resolvedIdentity)\n      const params = {\n        armored: data.toString(),\n        keyfetch: ring\n      }\n      const literals = await promisify(kbpgp.unbox)(params)\n      const decryptedData = Buffer.from(literals[0].toString())\n      return decryptedData\n    }\n  }\n\n  /* ============ HELPERS =============== */\n  /**\n   * Get the key for a given name\n   * @param name The unique name of the desired key\n   */\n  getKey(name: string): Buffer {\n    return this.derivedKeys[name]\n  }\n\n  /**\n   * Determines if the Key Manager has a certain key\n   * @param name The unique name of the desired key\n   */\n  hasKey(name: string): boolean {\n    if (this.derivedKeys[name]) {\n      return true\n    }\n    return false\n  }\n\n  private writeMetadata(): void {\n    const metadata = JSON.stringify(this.metadata)\n    this.fileSystem.writeFileSync(this.metadataPath, metadata)\n  }\n  private loadMetadata(): void {\n    // Check if file exists\n    if (this.fileSystem.existsSync(this.metadataPath)) {\n      const metadata = this.fileSystem.readFileSync(this.metadataPath).toString()\n      this.metadata = JSON.parse(metadata)\n    }\n  }\n}\n\nexport default KeyManager\nexport { KeyPair }\n","module.exports = require(\"crypto\");","import os from 'os'\nimport fs from 'fs'\nimport net from 'net'\nimport tls from 'tls'\nimport Path from 'path'\nimport RPCMessage from '../rpc/RPCMessage';\nimport KeyManager from '../keys/KeyManager';\nimport { firstPromiseFulfilled } from '../utils';\nimport PeerInfo, { Address } from '../peers/PeerInfo';\nimport MulticastBroadcaster from '../peers/MulticastBroadcaster';\nimport PublicKeyInfrastructure from '../pki/PublicKeyInfrastructure'\n\ninterface SocialDiscovery {\n  // Must return a public pgp key\n  name: string\n  findUser(handle: string, service: string): Promise<string>\n}\n\nconst keybaseDiscovery: SocialDiscovery = {\n  name: 'Keybase',\n  findUser: async (handle: string, service: string): Promise<string> => {\n    const url = `https://keybase.io/_/api/1.0/user/lookup.json?${service}=${handle}`\n\n    try {\n      const response = await fetch(url)\n      const data = await response.json()\n\n      const pubKey = data.them[0].public_keys.primary.bundle\n      return pubKey\n    } catch (err) {\n      throw new Error(`User was not found: ${err.message}`)\n    }\n  }\n}\n\ntype PeerManagerMetadata = {\n  localPeerInfo: PeerInfo | null\n}\n\nclass PeerManager {\n  private fileSystem: typeof fs\n\n  private metadataPath: string\n  private metadata: PeerManagerMetadata = { localPeerInfo: null }\n\n  private localPeerInfo: PeerInfo\n  private peerStore: Map<string, PeerInfo>\n  private keyManager: KeyManager\n  multicastBroadcaster: MulticastBroadcaster\n  private socialDiscoveryServices: SocialDiscovery[]\n\n  // Peer connections\n  keyPem: string\n  certPem: string\n  server: tls.Server\n  peerConnections: Map<string, tls.TLSSocket>\n\n  constructor(\n    polykeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    keyManager: KeyManager,\n    peerInfo?: PeerInfo,\n    socialDiscoveryServices: SocialDiscovery[] = []\n  ) {\n    this.fileSystem = fileSystem\n\n    this.fileSystem.mkdirSync(polykeyPath, {recursive: true})\n    this.metadataPath = Path.join(polykeyPath, '.peerMetadata')\n\n    // Set given variables\n    this.keyManager = keyManager\n    this.socialDiscoveryServices = socialDiscoveryServices\n\n    // Load metadata with peer info\n    this.loadMetadata()\n\n    // Load peer store and local peer info\n    if (peerInfo) {\n      this.localPeerInfo = peerInfo\n      this.writeMetadata()\n    } else if (this.metadata.localPeerInfo) {\n      this.localPeerInfo = this.metadata.localPeerInfo\n    } else if (this.keyManager.hasPublicKey()) {\n      this.localPeerInfo = new PeerInfo(this.keyManager.getPublicKey())\n    }\n    this.peerStore = new Map()\n\n    this.socialDiscoveryServices = []\n    this.socialDiscoveryServices.push(keybaseDiscovery)\n    for (const service of socialDiscoveryServices) {\n      this.socialDiscoveryServices.push(service)\n    }\n\n    this.multicastBroadcaster = new MulticastBroadcaster(this.addPeer, this.localPeerInfo, this.keyManager)\n\n    // Setup secure server\n    const {keyPem, certPem} = PublicKeyInfrastructure.createX509Certificate()\n    this.keyPem = keyPem\n    this.certPem = certPem\n    const options: tls.TlsOptions = {\n      key: keyPem,\n      cert: certPem,\n      requestCert: true,\n      rejectUnauthorized: false\n    }\n    this.server = tls.createServer(options, (socket) => {\n      console.log('server connected', socket.authorized ? 'authorized' : 'unauthorized');\n    }).listen()\n\n\n    // This part is for adding the address of the custom tcp server to the localPeerInfo\n    // Currently this is replaced by the connection within the git server (NodeJS.http module)\n    // const addressInfo = <net.AddressInfo>this.server.address()\n    // const address = Address.fromAddressInfo(addressInfo)\n    // this.localPeerInfo.connect(address)\n  }\n\n  ////////////////\n  // Peer store //\n  ////////////////\n  /**\n   * Get the peer info of the current keynode\n   */\n  getLocalPeerInfo(): PeerInfo {\n    return this.localPeerInfo\n  }\n\n  /**\n   * Set the address of the active server\n   * @param adress Address of active server\n   */\n  connectLocalPeerInfo(address: Address) {\n    this.localPeerInfo.connect(address)\n  }\n\n  /**\n   * Add a peer's info to the peerStore\n   * @param peerInfo Info of the peer to be added\n   */\n  addPeer(peerInfo: PeerInfo): void {\n    this.peerStore.set(peerInfo.publicKey, peerInfo)\n  }\n\n  /**\n   * Retrieves a peer for the given public key\n   * @param publicKey Public key of the desired peer\n   */\n  getPeer(publicKey: string): PeerInfo | null {\n    return this.peerStore.get(publicKey) ?? null\n  }\n\n  /**\n   * Determines if the peerStore contains the desired peer\n   * @param publicKey Public key of the desired peer\n   */\n  hasPeer(pubKey: string): boolean {\n    return this.peerStore.has(pubKey)\n  }\n\n  //////////////////////\n  // Social discovery //\n  //////////////////////\n  /**\n   * Finds an existing peer using multicast peer discovery\n   * @param publicKey Public key of the desired peer\n   */\n  async findPubKey(publicKey: string): Promise<PeerInfo> {\n    return new Promise<PeerInfo>((resolve, reject) => {\n      this.multicastBroadcaster.requestPeerContact(publicKey)\n      this.multicastBroadcaster.on('found', (peerInfo: PeerInfo) => {\n        if (peerInfo.publicKey == publicKey) {\n          resolve(peerInfo)\n        }\n      })\n\n      this.multicastBroadcaster.on('timeout', (timedOutPubKey: string) => {\n        if (timedOutPubKey == publicKey) {\n          reject('The broadcaster stopped looking')\n        }\n      })\n    })\n  }\n\n  /**\n   * Finds an existing peer given a social service and handle\n   * @param handle Username or handle of the user (e.g. @john-smith)\n   * @param service Service on which to search for the user (e.g. github)\n   */\n  async findSocialUser(handle: string, service: string): Promise<PeerInfo> {\n    const tasks: Promise<string>[] = []\n    for (const socialDiscovery of this.socialDiscoveryServices) {\n\n      try {\n        tasks.push(socialDiscovery.findUser(handle, service))\n      } catch (error) {\n        console.log(`Could not find user on this discovery service: ${socialDiscovery.name}`);\n      }\n    }\n\n    const pubKeyOrFail = await firstPromiseFulfilled(tasks)\n    if (pubKeyOrFail.length > 1) {\n      throw new Error('Could not find public key from services')\n    }\n\n    const pubKeyFound = pubKeyOrFail[0]\n    const peerInfo = await this.findPubKey(pubKeyFound)\n    return peerInfo\n  }\n\n  ///////////////////////\n  // Peers Connections //\n  ///////////////////////\n  /**\n   * Get a secure connection to the peer\n   * @param peer Public key of an existing peer or address of new peer\n   */\n  connectToPeer(peer: string | Address): net.Socket {\n    if (typeof peer == 'string') {\n      const existingSocket = this.peerConnections.get(peer)\n      if (existingSocket) {\n        return existingSocket\n      } else {\n        const address = this.getPeer(peer)?.connectedAddr\n        if (address) {\n          // const options: tls.ConnectionOptions = {\n          //   port: parseInt(address.port),\n          //   host: address.ip,\n          //   key: this.keyPem,\n          //   cert: this.certPem\n          // }\n          const options: net.NetConnectOpts = {\n            port: parseInt(address.port),\n            host: address.ip\n          }\n          const socket =  net.connect(options)\n\n          // this.connections.set(peer, socket)\n          return socket\n        }\n      }\n    } else {\n      const address = peer\n      // const options: tls.ConnectionOptions = {\n      //   port: parseInt(address.port),\n      //   host: address.ip,\n      //   key: this.keyPem,\n      //   cert: this.certPem\n      // }\n      const options: net.NetConnectOpts = {\n        port: parseInt(address.port),\n        host: address.ip\n      }\n      return net.connect(options)\n    }\n\n    throw new Error('Peer does not have an address connected')\n  }\n\n  /* ============ HELPERS =============== */\n  private writeMetadata(): void {\n    const metadata = JSON.stringify(RPCMessage.encodePeerInfo(this.localPeerInfo))\n    this.fileSystem.writeFileSync(this.metadataPath, metadata)\n  }\n  private loadMetadata(): void {\n    // Check if file exists\n    if (this.fileSystem.existsSync(this.metadataPath)) {\n      const metadata = this.fileSystem.readFileSync(this.metadataPath).toString()\n      this.localPeerInfo = RPCMessage.decodePeerInfo(Buffer.from(metadata))\n    }\n  }\n}\n\nexport default PeerManager\nexport { SocialDiscovery }\n","import Path from 'path'\nimport protobuf, { Root } from 'protobufjs'\nimport PeerInfo from '../peers/PeerInfo'\n\ntype HandshakeMessage = {\n  targetPubKey: Buffer\n  requestingPubKey: Buffer\n  message: Buffer\n  responsePeerInfo?: PeerInfo\n}\n\nclass RPCMessage {\n  /**\n   * Encode peer info into a protocol buffer\n   * @param peerInfo The peerInfo to be encoded\n   */\n  static encodePeerInfo(peerInfo: PeerInfo): Uint8Array {\n    const root = this.loadProto(\"PeerInfoMessage.proto\")\n\n    // Obtain a message type\n    const PeerInfoMessage = root!.lookupType(\"peerinfopackage.PeerInfoMessage\");\n\n    // Encode address set to array\n    const addresses: string[] = []\n    for (const addr of peerInfo.addresses) {\n      addresses.push(addr.toString())\n    }\n\n    // Exemplary payload\n    const payload = {\n      pubKey: peerInfo.publicKey,\n      addresses: addresses,\n      connectedAddr: peerInfo.connectedAddr?.toString()\n    };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    const errMsg = PeerInfoMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    const message = PeerInfoMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    const buffer = PeerInfoMessage.encode(message).finish();\n\n    return buffer\n  }\n  /**\n   * Deccode a protocol buffer into peer info\n   * @param buffer\n   */\n  static decodePeerInfo(buffer: Uint8Array): PeerInfo {\n    const root = this.loadProto(\"PeerInfoMessage.proto\")\n\n    // Obtain a message type\n    const PeerInfoMessage = root!.lookupType(\"peerinfopackage.PeerInfoMessage\");\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    const message = PeerInfoMessage.decode(buffer);\n\n    // Convert the message back to a plain object\n    const object = PeerInfoMessage.toObject(message, {\n      enums: String,  // enums as string names\n      longs: String,  // longs as strings (requires long.js)\n      bytes: String,  // bytes as base64 encoded strings\n      defaults: true, // includes default values\n      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n      objects: true,  // populates empty objects (map fields) even if defaults=false\n      oneofs: true    // includes virtual oneof fields set to the present field's name\n    });\n\n    return new PeerInfo(\n      object.pubKey,\n      object.addresses,\n      object.connectedAddr\n    )\n  }\n\n  /**\n   * Encode a handshake message into a protocol buffer\n   * @param targetPubKey\n   * @param requestingPubKey\n   * @param message\n   * @param responsePeerInfo\n   */\n  static encodeHandshakeMessage(targetPubKey: Buffer, requestingPubKey: Buffer, message: Buffer, responsePeerInfo?: PeerInfo): Uint8Array {\n    const root = this.loadProto(\"HandshakeMessage.proto\")\n\n    // Obtain a message type\n    const HandshakeMessage = root!.lookupType(\"handshakepackage.HandshakeMessage\");\n\n    // Exemplary payload\n    const payload = {\n      targetPubKey: targetPubKey,\n      requestingPubKey: requestingPubKey,\n      message: message,\n      responsePeerInfo: (responsePeerInfo) ? this.encodePeerInfo(responsePeerInfo) : undefined\n    };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    const errMsg = HandshakeMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    const encodedMmessage = HandshakeMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    const buffer = HandshakeMessage.encode(encodedMmessage).finish();\n\n    return buffer\n  }\n  /**\n   * Deccode a protocol buffer into a handshake message\n   * @param buffer\n   */\n  static decodeHandshakeMessage(buffer: Uint8Array): HandshakeMessage {\n    const root = this.loadProto(\"HandshakeMessage.proto\")\n\n    // Obtain a message type\n    const HandshakeMessage = root!.lookupType(\"handshakepackage.HandshakeMessage\");\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    const message = HandshakeMessage.decode(buffer);\n\n    // Convert the message back to a plain object\n    const object = HandshakeMessage.toObject(message, {\n      enums: String,  // enums as string names\n      longs: String,  // longs as strings (requires long.js)\n      bytes: String,  // bytes as base64 encoded strings\n      defaults: true, // includes default values\n      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n      objects: true,  // populates empty objects (map fields) even if defaults=false\n      oneofs: true    // includes virtual oneof fields set to the present field's name\n    });\n\n    return {\n      targetPubKey: Buffer.from(object.targetPubKey, 'base64'),\n      requestingPubKey: Buffer.from(object.requestingPubKey, 'base64'),\n      message: Buffer.from(object.message, 'base64'),\n      responsePeerInfo: (object.responsePeerInfo) ? this.decodePeerInfo(Buffer.from(object.responsePeerInfo, 'base64')) : undefined\n    }\n  }\n\n  // ==== Helper methods ==== //\n  private static loadProto(name: string): Root {\n    // Load root\n    const root: Root = new protobuf.Root()\n    root.resolvePath = (origin, target) => {\n      return Path.join(Path.dirname(__filename), target)\n    }\n\n    return root.loadSync(name)\n  }\n}\n\nexport default RPCMessage\n","\nimport fs from 'fs'\nimport os from 'os'\nimport net from 'net'\nimport Path from 'path'\nimport git from 'isomorphic-git'\nimport { EncryptedFS } from 'encryptedfs'\nimport Vault from '../vaults/Vault'\nimport HttpRequest from '../HttpRequest'\nimport KeyManager from '../keys/KeyManager'\nimport { Address } from '../peers/PeerInfo'\n\nclass VaultManager {\n  polykeyPath: string\n  fileSystem: typeof fs\n  keyManager: KeyManager\n\n  metadataPath: string\n  vaults: Map<string, Vault>\n  vaultKeys: Map<string, Buffer>\n  constructor(\n    polykeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    keyManager: KeyManager\n  ) {\n    this.polykeyPath = polykeyPath\n    this.fileSystem = fileSystem\n    this.keyManager = keyManager\n    this.metadataPath = Path.join(polykeyPath, '.vaultKeys')\n\n    // Make polykeyPath if it doesn't exist\n    this.fileSystem.mkdirSync(this.polykeyPath, { recursive: true })\n\n    // Initialize stateful variables\n    this.vaults = new Map()\n    this.vaultKeys = new Map()\n\n    // Read in vault keys\n    this.loadMetadata()\n\n    // Initialize vaults in memory\n    for (const [vaultName, vaultKey] of this.vaultKeys.entries()) {\n      const path = Path.join(this.polykeyPath, vaultName)\n      if (this.fileSystem.existsSync(path)) {\n        const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n        this.vaults.set(vaultName, vault)\n      }\n    }\n  }\n\n  /**\n   * Get a vault from the vault manager\n   * @param vaultName Name of desired vault\n   */\n  getVault(vaultName: string): Vault {\n    if (this.vaults.has(vaultName)) {\n      const vault = this.vaults.get(vaultName)\n      return vault!\n    } else if (this.vaultKeys.has(vaultName)) {\n      // vault not in map, create new instance\n      this.validateVault(vaultName)\n\n      const vaultKey = this.vaultKeys.get(vaultName)\n\n      const vault = new Vault(vaultName, vaultKey!, this.polykeyPath)\n      this.vaults.set(vaultName, vault)\n      return vault\n    } else {\n      throw new Error('Vault does not exist in memory')\n    }\n  }\n\n  /**\n   * Get a vault from the vault manager\n   * @param vaultName Unique name of new vault\n   * @param key Optional key to use for the vault encryption, otherwise it is generated\n   */\n  async createVault(vaultName: string, key?: Buffer): Promise<Vault> {\n\n    if (this.vaultExists(vaultName)) {\n      throw Error('Vault already exists!')\n    }\n\n    try {\n      const path = Path.join(this.polykeyPath, vaultName)\n      // Directory not present, create one\n      this.fileSystem.mkdirSync(path, { recursive: true })\n      // Create key if not provided\n      let vaultKey: Buffer\n      if (!key) {\n        // Generate new key\n        vaultKey = await this.keyManager.generateKey(`${vaultName}-Key`, this.keyManager.getPrivateKey())\n      } else {\n        // Assign key if it is provided\n        vaultKey = key\n      }\n      this.vaultKeys.set(vaultName, vaultKey)\n      this.writeMetadata()\n      const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n      await vault.initRepository()\n      this.vaults.set(vaultName, vault)\n      return this.getVault(vaultName)\n    } catch (err) {\n      // Delete vault dir and garbage collect\n      this.destroyVault(vaultName)\n      throw err\n    }\n  }\n\n  /**\n   * Get a vault from the vault manager\n   * @param vaultName Name of vault to be cloned\n   * @param address Address of polykey node that owns vault to be cloned\n   * @param getSocket Function to get an active connection to provided address\n   */\n  async cloneVault(vaultName: string, address: Address, getSocket: (address: Address) => net.Socket): Promise<Vault> {\n    // Confirm it doesn't exist locally already\n    if (this.vaultExists(vaultName)) {\n      throw new Error('Vault name already exists locally, try pulling instead')\n    }\n\n    const vaultUrl = `http://${address.toString()}/${vaultName}`\n\n    const httpRequest = new HttpRequest(address, getSocket)\n    // First check if it exists on remote\n    const info = await git.getRemoteInfo({\n      http: httpRequest,\n      url: vaultUrl\n    })\n\n    if (!info.refs) {\n      throw new Error(`Peer does not have vault: '${vaultName}'`)\n    }\n\n    // Create new efs first\n    // Generate new key\n    const vaultKey = await this.keyManager.generateKey(`${vaultName}-Key`, this.keyManager.getPrivateKey())\n\n    // Set filesystem\n    const vfsInstance = new (require('virtualfs')).VirtualFS\n\n    const newEfs = new EncryptedFS(\n      vaultKey,\n      vfsInstance,\n      vfsInstance,\n      this.fileSystem,\n      process\n    )\n\n    // Clone vault from address\n    await git.clone({\n      fs: { promises: newEfs.promises },\n      http: httpRequest,\n      dir: Path.join(this.polykeyPath, vaultName),\n      url: vaultUrl,\n      ref: 'master',\n      singleBranch: true\n    })\n\n    // Finally return the vault\n    const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n    this.vaults.set(vaultName, vault)\n    return vault\n  }\n\n  /**\n   * Determines whether the vault exists\n   * @param vaultName Name of desired vault\n   */\n  vaultExists(vaultName: string): boolean {\n    const path = Path.join(this.polykeyPath, vaultName)\n    const vaultExists = this.fileSystem.existsSync(path)\n\n    return vaultExists\n  }\n\n  /**\n   * [WARNING] Destroys a certain vault and all its secrets\n   * @param vaultName Name of vault to be destroyed\n   */\n  destroyVault(vaultName: string) {\n\n    // this is convenience function for removing all tags\n    // and triggering garbage collection\n    // destruction is a better word as we should ensure all traces is removed\n\n    const path = Path.join(this.polykeyPath, vaultName)\n    // Remove directory on file system\n    if (this.fileSystem.existsSync(path)) {\n      this.fileSystem.rmdirSync(path, { recursive: true })\n    }\n\n    // Remove from maps\n    this.vaults.delete(vaultName)\n    this.vaultKeys.delete(vaultName)\n\n    // Write to metadata file\n    this.writeMetadata()\n\n    const vaultPathExists = this.fileSystem.existsSync(path)\n    if (vaultPathExists) {\n      throw new Error('Vault folder could not be destroyed!')\n    }\n  }\n\n  /**\n   * List the names of all vaults in memory\n   */\n  listVaults(): string[] {\n    return Array.from(this.vaults.keys())\n  }\n\n  /* ============ HELPERS =============== */\n  private validateVault(vaultName: string): void {\n    if (!this.vaults.has(vaultName)) {\n      throw Error('Vault does not exist in memory')\n    }\n    if (!this.vaultKeys.has(vaultName)) {\n      throw Error('Vault key does not exist in memory')\n    }\n    const vaultPath = Path.join(this.polykeyPath, vaultName)\n    if (!this.fileSystem.existsSync(vaultPath)) {\n      throw Error('Vault directory does not exist')\n    }\n  }\n  private async writeMetadata(): Promise<void> {\n    const metadata = JSON.stringify([...this.vaultKeys])\n    const encryptedMetadata = await this.keyManager.encryptData(Buffer.from(metadata))\n    await this.fileSystem.promises.writeFile(this.metadataPath, encryptedMetadata)\n  }\n  private async loadMetadata(): Promise<void> {\n    // Check if file exists\n    if (this.fileSystem.existsSync(this.metadataPath)) {\n      const encryptedMetadata = this.fileSystem.readFileSync(this.metadataPath)\n      const metadata = (await this.keyManager.decryptData(encryptedMetadata)).toString()\n\n      for (const [key, value] of new Map<string, any>(JSON.parse(metadata))) {\n        this.vaultKeys[key] = Buffer.from(value)\n      }\n    }\n  }\n}\n\nexport default VaultManager\n","module.exports = require(\"isomorphic-git\");","module.exports = require(\"encryptedfs\");","import net from 'net'\nimport http from 'http'\nimport { Address } from './peers/PeerInfo'\n\nclass HttpRequest {\n  address: Address\n  getSocket: (address: Address) => net.Socket\n  constructor(\n    address: Address,\n    getSocket: (address: Address) => net.Socket\n  ) {\n    this.address = address\n    this.getSocket = getSocket\n  }\n\n  /**\n   * The custom http request method to feed into isomorphic-git's [custom http object](https://isomorphic-git.org/docs/en/http)\n   */\n  request({\n    url,\n    method,\n    headers,\n    body,\n    onProgress\n  }) {\n    return new Promise<any>((resolve, reject) => {\n\n      const { pathname, search } = new URL(url)\n      const options: http.RequestOptions = {\n        path: pathname + search,\n        headers: headers,\n        method: method,\n        createConnection: () => {\n          return this.getSocket(this.address)\n        }\n      };\n      const req = http.request(options, (res) => {\n        const iter = this.httpMessageToIter(res)\n        resolve({\n          url: res.url,\n          method: res.method,\n          statusCode: res.statusCode,\n          statusMessage: res.statusMessage,\n          body: iter,\n          headers: res.headers\n        })\n      })\n      if (body) {\n        for (const buffer of body) {\n          req.write(buffer)\n        }\n      }\n      req.end()\n    })\n  }\n\n  /**\n   * Converts http incoming message into a iterator that can be used by [isomorphic-git](https://isomorphic-git.org)\n   * @param message Http IncomingMessage\n   */\n  private httpMessageToIter(message: http.IncomingMessage) {\n    let ended = false\n    const queue: Buffer[] = []\n    let defer: any = {}\n    message.on('data', (chunk: Buffer) => {\n      queue.push(chunk)\n      if (defer.resolve) {\n        defer.resolve({ value: queue.shift(), done: false })\n        defer = {}\n      }\n    })\n    message.on('error', err => {\n      if (defer.reject) {\n        defer.reject(err)\n        defer = {}\n      }\n    })\n    message.on('end', () => {\n      ended = true\n      if (defer.resolve) {\n        defer.resolve({ done: true })\n        defer = {}\n      }\n    })\n    return {\n      next(): Promise<any> {\n        return new Promise((resolve, reject) => {\n          if (queue.length === 0 && ended) {\n            return resolve({ done: true })\n          } else if (queue.length > 0) {\n            return resolve({ value: queue.shift(), done: false })\n          } else if (queue.length === 0 && !ended) {\n            defer = { resolve, reject }\n          }\n        })\n      },\n    }\n  }\n}\n\nexport default HttpRequest\n","module.exports = require(\"virtualfs\");","export { default } from './Polykey'\nexport { default as KeyManager } from './keys/KeyManager'\nexport { default as PeerManager } from './peers/PeerManager'\nexport { default as VaultManager } from './vaults/VaultManager'\n","import os from 'os'\nimport fs from 'fs'\nimport GitServer from './git/GitServer'\nimport KeyManager from './keys/KeyManager'\nimport PeerManager from './peers/PeerManager'\nimport VaultManager from './vaults/VaultManager'\n\nclass Polykey {\n  polykeyPath: string\n\n  vaultManager: VaultManager\n  keyManager: KeyManager\n  peerManager: PeerManager\n  private gitServer: GitServer\n\n  constructor(\n    polykeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    keyManager?: KeyManager,\n    vaultManager?: VaultManager,\n    peerManager?: PeerManager\n  ) {\n    this.polykeyPath = polykeyPath\n\n    // Set key manager\n    this.keyManager = keyManager ?? new KeyManager(this.polykeyPath, fileSystem)\n\n    // Set or Initialize vaultManager\n    this.vaultManager = vaultManager ?? new VaultManager(this.polykeyPath, fileSystem, this.keyManager)\n\n    // Initialize peer store and peer discovery classes\n    this.peerManager = peerManager ?? new PeerManager(this.polykeyPath, fileSystem, this.keyManager)\n\n    // Start git server\n    this.gitServer = new GitServer(this.polykeyPath, this.vaultManager)\n    this.peerManager.connectLocalPeerInfo(this.gitServer.address)\n  }\n}\n\nexport default Polykey\n","import Path from 'path'\nimport http from 'http'\nimport { AddressInfo } from \"net\";\nimport { parse } from 'querystring'\nimport { Address } from '../peers/PeerInfo';\nimport VaultManager from '../vaults/VaultManager';\nimport uploadPack from '../git/upload-pack/uploadPack';\nimport GitSideBand from '../git/side-band/GitSideBand';\nimport { Readable, PassThrough } from 'readable-stream';\nimport packObjects from '../git/pack-objects/packObjects';\n\n// Here is the protocol git outlines for sending pack files over http:\n// https://git-scm.com/docs/pack-protocol/2.17.0\n// https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt\n// This should be consulted in developing our upload pack implementation\n\n// This git backend (as well as HttpDuplex class) is heavily inspired by node-git-server:\n// https://github.com/gabrielcsapo/node-git-server\n\n// We need someway to notify other agents about what vaults we have based on some type of authorisation because they don't explicitly know about them\n\nconst services = ['upload-pack', 'receive-pack']\n\nclass GitServer {\n  private polykeyPath: string;\n  private vaultManager: VaultManager;\n  private server: http.Server;\n\n  address: Address\n  constructor(\n    polykeyPath: string,\n    vaultManager: VaultManager,\n    port: number = 0\n  ) {\n    this.polykeyPath = polykeyPath\n    this.vaultManager = vaultManager\n\n    this.server = http.createServer((req, res) => {\n      this.handle(req, res)\n    }).listen(port)\n\n    this.address = Address.fromAddressInfo(<AddressInfo>this.server.address())\n  }\n\n  /**\n   * Find out whether vault exists.\n   * @param vaultName Name of vault to check\n   * @param publicKey Public key of peer trying to access vault\n   */\n  private exists(vaultName: string, publicKey: string) {\n    const vault = this.vaultManager.getVault(vaultName)\n    if (vault) {\n      return vault.peerCanAccess(publicKey)\n    }\n    return false\n  }\n\n  /**\n   * Handle incoming info or pack requests and delegates to respective functions\n   * @param req Incoming http message\n   * @param res Outgoing server response\n   */\n  private handle(req: http.IncomingMessage, res: http.ServerResponse) {\n    res.setHeader('connection', 'close')\n\n    if (req.method == 'GET') {\n      this.handleInfoRequest(req, res)\n    } else if (req.method == 'POST') {\n      this.handlePackRequest(req, res)\n    } else {\n      res.statusCode = 405\n      res.end('method not supported')\n    }\n  }\n\n  /**\n   * Returns a not found response\n   * @param res Outgoing server response\n   */\n  private notFoundResponse(res: http.ServerResponse) {\n    res.statusCode = 404\n    res.end('not found')\n  }\n\n  /**\n   * Handles a request for remote info\n   * @param req Incoming http message\n   * @param res Outgoing server response\n   */\n  private handleInfoRequest(req: http.IncomingMessage, res: http.ServerResponse) {\n    const splitUrl = req.url?.split('?') ?? []\n    if (splitUrl.length != 2) {\n      return this.notFoundResponse(res)\n    }\n\n    const pathname = splitUrl[0]\n    const query = splitUrl[1]\n\n    const m = pathname.match(/\\/(.+)\\/info\\/refs$/)\n    if (!m || /\\.\\./.test(m[1])) {\n      return this.notFoundResponse(res)\n    }\n\n    const repo = m[1]\n    const params = parse(query)\n    if (!params.service) {\n      res.statusCode = 400\n      res.end('service parameter required')\n      return\n    }\n\n    const service = (<string>params.service).replace(/^git-/, '')\n    if (services.indexOf(service) < 0) {\n      res.statusCode = 405\n      res.end('service not available')\n      return\n    }\n\n    this.infoResponse(repo, service, res)\n  }\n\n  /**\n   * Handles a requests for packfiles\n   * @param req Incoming http message\n   * @param res Outgoing server response\n   */\n  private handlePackRequest(req: http.IncomingMessage, res: http.ServerResponse) {\n    const m = req.url!.match(/\\/(.+)\\/git-(.+)/)\n    if (!m || /\\.\\./.test(m[1])) {\n      return this.notFoundResponse(res)\n    }\n\n    const repo = m[1]\n    const service = m[2]\n\n    if (services.indexOf(service) < 0) {\n      res.statusCode = 405\n      res.end('service not available')\n      return\n    }\n\n    res.setHeader('content-type', 'application/x-git-' + service + '-result')\n    this.noCache(res)\n\n    const repoDir = Path.join(this.polykeyPath, repo)\n\n    // Check if vault exists\n    const connectingPublicKey = ''\n    if (!this.exists(repo, connectingPublicKey)) {\n      res.statusCode = 404\n      res.end('not found')\n      return\n    }\n\n    const fileSystem = this.vaultManager.getVault(repo)?.EncryptedFS\n\n    if (fileSystem) {\n      req.on('data', async (data) => {\n        if (data.toString().slice(4, 8) == 'want') {\n          const wantedObjectId = data.toString().slice(9, 49)\n          const packResult = await packObjects(\n            fileSystem,\n            repoDir,\n            [wantedObjectId],\n            undefined\n          )\n\n          // This the 'wait for more data' line as I understand it\n          res.write(Buffer.from('0008NAK\\n'))\n\n          // This is to get the side band stuff working\n          const readable = new PassThrough()\n          const progressStream = new PassThrough()\n          const sideBand = GitSideBand.mux(\n            'side-band-64',\n            readable,\n            packResult.packstream,\n            progressStream,\n            []\n          )\n          sideBand.pipe(res)\n\n          // Write progress to the client\n          progressStream.write(Buffer.from('0014progress is at 50%\\n'))\n          progressStream.end()\n        }\n      })\n    }\n  }\n\n  // ============ Helper functions ============ //\n  /**\n   * Sends http response containing git info about the particular vault\n   * @param vaultName Name of the requested vault\n   * @param service The type of service requested, either upload-pack or recieve-pack\n   * @param res Outgoing server response\n   */\n  private infoResponse(vaultName: string, service: string, res: http.ServerResponse) {\n\n    const connectingPublicKey = ''\n    const exists = this.exists(vaultName, connectingPublicKey)\n\n    if (!exists) {\n      res.statusCode = 404\n      res.setHeader('content-type', 'text/plain')\n      res.end('repository not found')\n    } else {\n      res.setHeader(\n        'content-type',\n        'application/x-git-' + service + '-advertisement'\n      )\n      this.noCache(res)\n\n      this.uploadPackRespond(\n        vaultName,\n        service,\n        res\n      )\n    }\n  }\n\n  /**\n   * Adds headers to the response object to add cache control\n   * @param res Outgoing server response\n   */\n  private noCache(res: http.ServerResponse) {\n    res.setHeader('expires', 'Fri, 01 Jan 1980 00:00:00 GMT')\n    res.setHeader('pragma', 'no-cache')\n    res.setHeader('cache-control', 'no-cache, max-age=0, must-revalidate')\n  }\n\n  /**\n   * Encodes a string into a git packet line by prefixing the hexadecimal length of the line\n   * @param line The line to be encoded\n   */\n  private createGitPacketLine(line: string) {\n    const hexPrefix = (4 + line.length).toString(16)\n    return Array(4 - hexPrefix.length + 1).join('0') + hexPrefix + line\n  }\n\n\n  /**\n   * Handles the response to a git packfile request\n   * @param vaultName Name of the requested vault\n   * @param vaultPath Path to the target vault\n   * @param service The type of service requested, either upload-pack or recieve-pack\n   * @param res Outgoing server response\n   */\n  private async uploadPackRespond(vaultName: string, service: string, res: http.ServerResponse) {\n    res.write(this.createGitPacketLine('# service=git-' + service + '\\n'))\n    res.write('0000')\n\n    const fileSystem = this.vaultManager.getVault(vaultName)?.EncryptedFS\n\n    const buffers = await uploadPack(\n      fileSystem,\n      Path.join(this.polykeyPath, vaultName),\n      undefined,\n      true\n    )\n    const buffersToWrite = buffers ?? []\n\n    // Pipe the data back into response stream\n    const readable = Readable.from(buffersToWrite);\n    readable.pipe(res)\n  }\n}\n\nexport default GitServer\n","module.exports = require(\"querystring\");","import path from 'path'\nimport GitPktLine from './GitPktLine'\nimport { EncryptedFS } from 'encryptedfs'\nimport GitRefManager from './GitRefManager'\n\nasync function writeRefsAdResponse({ capabilities, refs, symrefs }) {\n  const stream: Buffer[] = []\n  // Compose capabilities string\n  let syms = ''\n  for (const [key, value] of Object.entries(symrefs)) {\n    syms += `symref=${key}:${value} `\n  }\n  let caps = `\\x00${[...capabilities].join(' ')} ${syms}agent=git/isomorphic-git@1.4.0`\n  // stream.write(GitPktLine.encode(`# service=${service}\\n`))\n  // stream.write(GitPktLine.flush())\n  // Note: In the edge case of a brand new repo, zero refs (and zero capabilities)\n  // are returned.\n  for (const [key, value] of Object.entries(refs)) {\n    stream.push(GitPktLine.encode(`${value} ${key}${caps}\\n`))\n    caps = ''\n  }\n  stream.push(GitPktLine.flush())\n  return stream\n}\n\nasync function uploadPack(\n  fileSystem: EncryptedFS,\n  dir: string,\n  gitdir: string = path.join(dir, '.git'),\n  advertiseRefs: boolean = false,\n) {\n  try {\n    if (advertiseRefs) {\n      // Send a refs advertisement\n      const capabilities = [\n        'side-band-64k',\n      ]\n      let keys = await GitRefManager.listRefs(\n        fileSystem,\n        gitdir,\n        'refs'\n      )\n      keys = keys.map(ref => `refs/${ref}`)\n      const refs = {}\n      keys.unshift('HEAD') // HEAD must be the first in the list\n      for (const key of keys) {\n        refs[key] = await GitRefManager.resolve(fileSystem, gitdir, key)\n      }\n\n      const symrefs = {}\n\n      symrefs['HEAD'] = await GitRefManager.resolve(\n        fileSystem,\n        gitdir,\n        'HEAD',\n        2,\n      )\n\n      return writeRefsAdResponse({\n        capabilities,\n        refs,\n        symrefs,\n      })\n    }\n  } catch (err) {\n    err.caller = 'git.uploadPack'\n    throw err\n  }\n}\n\nexport default uploadPack\n","type Config = {\n  line: string\n  ref?: string\n  peeled?: string\n  oid?: string\n  comment?: boolean\n}\n\nclass GitPackedRefs {\n  refs: Map<string, string>\n  parsedConfig: Config[]\n  constructor(text: string) {\n    this.refs = new Map()\n    this.parsedConfig = []\n    if (text) {\n      let key: string\n      this.parsedConfig = text\n        .trim()\n        .split('\\n')\n        .map(line => {\n          if (/^\\s*#/.test(line)) {\n            return { line: line, comment: true }\n          }\n          const i = line.indexOf(' ')\n          if (line.startsWith('^')) {\n            // This is a oid for the commit associated with the annotated tag immediately preceding this line.\n            // Trim off the '^'\n            const value = line.slice(1)\n            // The tagname^{} syntax is based on the output of `git show-ref --tags -d`\n            this.refs.set(key + '^{}', value)\n            return { line: line, ref: key, peeled: value }\n          } else {\n            // This is an oid followed by the ref name\n            const value = line.slice(0, i)\n            key = line.slice(i + 1)\n            this.refs.set(key, value)\n            return { line: line, ref: key, oid: value }\n          }\n        })\n    }\n    return this\n  }\n\n  static from(text) {\n    return new GitPackedRefs(text)\n  }\n}\n\nexport default GitPackedRefs\n","/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\nimport { Buffer } from 'buffer'\nimport { PassThrough } from 'readable-stream'\n\nimport GitPktLine from '../upload-pack/GitPktLine'\n\nfunction splitBuffer(buffer: Buffer, maxBytes: number) {\n  const result: Buffer[] = [];\n  let index = 0\n  while (index < buffer.length) {\n    const buf = buffer.slice(index, index+maxBytes)\n    result.push(buf)\n    index += buf.length\n  }\n  result.push(buffer.slice(index))\n  return result;\n}\n\nclass GitSideBand {\n  static demux (input) {\n    let read = GitPktLine.streamReader(input)\n    // And now for the ridiculous side-band or side-band-64k protocol\n    let packetlines = new PassThrough()\n    let packfile = new PassThrough()\n    let progress = new PassThrough()\n    // TODO: Use a proper through stream?\n    const nextBit = async function () {\n      let line = await read()\n      // Skip over flush packets\n      if (line === null) return nextBit()\n      // A made up convention to signal there's no more to read.\n      if (line === true) {\n        packetlines.end()\n        progress.end()\n        packfile.end()\n        return\n      }\n      // Examine first byte to determine which output \"stream\" to use\n      switch (line[0]) {\n        case 1: // pack data\n          packfile.write(line.slice(1))\n          break\n        case 2: // progress message\n          progress.write(line.slice(1))\n          break\n        case 3: // fatal error message just before stream aborts\n          let error = line.slice(1)\n          progress.write(error)\n          packfile.destroy(new Error(error.toString('utf8')))\n          return\n        default:\n          // Not part of the side-band-64k protocol\n          packetlines.write(line.slice(0))\n      }\n      // Careful not to blow up the stack.\n      // I think Promises in a tail-call position should be OK.\n      nextBit()\n    }\n    nextBit()\n    return {\n      packetlines,\n      packfile,\n      progress\n    }\n  }\n  static mux (\n    protocol, // 'side-band' or 'side-band-64k'\n    packetlines,\n    packfile,\n    progress,\n    error\n  ) {\n    const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519\n    let output = new PassThrough()\n    packetlines.on('data', data => {\n      if (data === null) {\n        output.write(GitPktLine.flush())\n      } else {\n        output.write(GitPktLine.encode(data))\n      }\n    })\n    let packfileWasEmpty = true\n    let packfileEnded = false\n    let progressEnded = false\n    let errorEnded = true\n    let goodbye = Buffer.concat([\n      GitPktLine.encode(Buffer.from('010A', 'hex')),\n      GitPktLine.flush()\n    ])\n    packfile\n      .on('data', data => {\n        packfileWasEmpty = false\n        const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n        for (const buffer of buffers) {\n          output.write(\n            GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))\n          )\n        }\n      })\n      .on('end', () => {\n        packfileEnded = true\n        if (!packfileWasEmpty) output.write(goodbye)\n        if (progressEnded && errorEnded) output.end()\n      })\n    progress\n      .on('data', data => {\n        const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n        for (const buffer of buffers) {\n          output.write(\n            GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))\n          )\n        }\n      })\n      .on('end', () => {\n        progressEnded = true\n        if (packfileEnded && errorEnded) output.end()\n      })\n    // error\n    //   .on('data', data => {\n    //     const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n    //     for (const buffer of buffers) {\n    //       output.write(\n    //         GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n    //       )\n    //     }\n    //   })\n    //   .on('end', () => {\n    //     errorEnded = true\n    //     if (progressEnded && packfileEnded) output.end()\n    //   })\n    return output\n  }\n}\n\nexport default GitSideBand\n","module.exports = require(\"buffer\");","import pako from 'pako'\nimport path from 'path'\nimport log from './log'\nimport GitTree from './GitTree'\nimport createHash from 'sha.js'\nimport GitCommit from './GitCommit'\nimport { EncryptedFS } from 'encryptedfs'\nimport { PassThrough } from 'readable-stream'\nimport GitObjectManager from './GitObjectManager'\n\nconst types = {\n  commit: 0b0010000,\n  tree: 0b0100000,\n  blob: 0b0110000,\n  tag: 0b1000000,\n  ofs_delta: 0b1100000,\n  ref_delta: 0b1110000\n}\n\ntype Ack = {\n  oid: string\n}\n/**\n * Create a packfile stream\n *\n * @link https://isomorphic-git.github.io/docs/packObjects.html\n */\nasync function packObjects (\n  fileSystem: EncryptedFS,\n  dir: string,\n  refs: string[],\n  depth?: number,\n  haves?: string[],\n) {\n  const gitdir = path.join(dir, '.git')\n  let oids = new Set<string>()\n  let shallows = new Set<string>()\n  let unshallows = new Set()\n  let acks: Ack[] = []\n\n  haves = (haves) ? haves : []\n\n  const emitter = undefined\n  const since = undefined\n  for (const ref of refs) {\n    try {\n      let commits = await log(\n        fileSystem,\n        dir,\n        gitdir,\n        emitter,\n        ref,\n        depth,\n        since\n      )\n\n      let oldshallows: string[] = []\n\n      for (let i = 0; i < commits.length; i++) {\n        let commit = commits[i]\n        if (haves.includes(commit.oid)) {\n          acks.push({\n            oid: ref\n          })\n          break\n        }\n        oids.add(commit.oid)\n        if (i === commits.length - 1) {\n          if (\n            !oldshallows.includes(commit.oid) &&\n            (depth !== undefined || since !== undefined)\n          ) {\n            console.log('make it shallow', commit.oid)\n            shallows.add(commit.oid)\n          }\n        } else if (oldshallows.includes(commit.oid)) {\n          console.log('make it unshallow', commit.oid)\n          unshallows.add(commit.oid)\n        }\n      }\n    } catch (err) {\n      console.log(err);\n      // oh well.\n    }\n  }\n  let objects = await listObjects(fileSystem, dir, gitdir, Array.from(oids))\n\n  let packstream = new PassThrough()\n  pack(\n    fileSystem,\n    dir,\n    undefined,\n    [...objects],\n    packstream\n  )\n  return { packstream, shallows, unshallows, acks }\n}\n\nasync function listObjects (\n  fileSystem: EncryptedFS,\n  dir: string,\n  gitdir: string = path.join(dir, '.git'),\n  oids: string[]\n) {\n  let commits = new Set<string>()\n  let trees = new Set<string>()\n  let blobs = new Set<string>()\n\n  // We don't do the purest simplest recursion, because we can\n  // avoid reading Blob objects entirely since the Tree objects\n  // tell us which oids are Blobs and which are Trees. And we\n  // do not need to recurse through commit parents.\n  async function walk (oid) {\n    let { type, object } = await GitObjectManager.read(fileSystem, gitdir, oid)\n    if (type === 'commit') {\n      commits.add(oid)\n      let commit = GitCommit.from(object)\n      let tree = commit.headers().tree\n      await walk(tree)\n    } else if (type === 'tree') {\n      trees.add(oid)\n      let tree = GitTree.from(object)\n      for (let entry of tree) {\n        if (entry.type === 'blob') {\n          blobs.add(entry.oid)\n        }\n        // only recurse for trees\n        if (entry.type === 'tree') {\n          await walk(entry.oid)\n        }\n      }\n    }\n  }\n\n  // Let's go walking!\n  for (let oid of oids) {\n    await walk(oid)\n  }\n  return [...commits, ...trees, ...blobs]\n}\n\nasync function pack (\n  fileSystem: EncryptedFS,\n  dir: string,\n  gitdir: string = path.join(dir, '.git'),\n  oids: string[],\n  outputStream: PassThrough\n) {\n  let hash = createHash('sha1')\n  function write(chunk: any, enc: string | undefined = undefined) {\n    if(enc) {\n      outputStream.write(chunk, enc)\n    } else {\n      outputStream.write(chunk)\n    }\n    hash.update(chunk, enc)\n  }\n  function writeObject (object, stype) {\n    let lastFour\n    let multibyte\n    let length\n    // Object type is encoded in bits 654\n    let type = types[stype]\n    if (type === undefined) throw new Error('Unrecognized type: ' + stype)\n    // The length encoding get complicated.\n    length = object.length\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    multibyte = length > 0b1111 ? 0b10000000 : 0b0\n    // Last four bits of length is encoded in bits 3210\n    lastFour = length & 0b1111\n    // Discard those bits\n    length = length >>> 4\n    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)\n    let byte: any = (multibyte | type | lastFour).toString(16)\n    write(byte, 'hex')\n    // Now we keep chopping away at length 7-bits at a time until its zero,\n    // writing out the bytes in what amounts to little-endian order.\n    while (multibyte) {\n      multibyte = length > 0b01111111 ? 0b10000000 : 0b0\n      byte = multibyte | (length & 0b01111111)\n      const unpaddedChunk = byte.toString(16)\n      const paddedChunk = '0'.repeat(2-unpaddedChunk.length) + unpaddedChunk\n      write(paddedChunk, 'hex')\n      length = length >>> 7\n    }\n    // Lastly, we can compress and write the object.\n    write(Buffer.from(pako.deflate(object)))\n  }\n\n  write('PACK')\n  write('00000002', 'hex')\n  // Write a 4 byte (32-bit) int\n  const unpaddedChunk = oids.length.toString(16)\n  const paddedChunk = '0'.repeat(8-unpaddedChunk.length) + unpaddedChunk\n  write(paddedChunk, 'hex')\n  for (let oid of oids) {\n    let { type, object } = await GitObjectManager.read(fileSystem, gitdir, oid)\n    writeObject(object, type)\n  }\n  // Write SHA1 checksum\n  let digest = hash.digest()\n  outputStream.end(digest)\n  return outputStream\n}\n\nexport default packObjects\nexport {listObjects, pack}\n","import path = require(\"path\")\nimport GitCommit from './GitCommit'\nimport { EncryptedFS } from 'encryptedfs'\nimport GitObjectManager from './GitObjectManager'\nimport GitRefManager from '../upload-pack/GitRefManager'\n\n\n\nasync function logCommit (fileSystem: EncryptedFS, gitdir: string, oid: string, signing: boolean) {\n  try {\n    let { type, object } = await GitObjectManager.read(fileSystem, gitdir, oid)\n    if (type !== 'commit') {\n      throw(new Error('expected type to be commit'))\n    }\n    const commit = GitCommit.from(object)\n    const result = Object.assign({ oid }, commit.parse())\n    if (signing) {\n      result.payload = commit.withoutSignature()\n    }\n    return result\n  } catch (err) {\n    return {\n      oid,\n      error: err\n    }\n  }\n}\n\n\nfunction compareAge (a, b) {\n  return a.committer.timestamp - b.committer.timestamp\n}\n\n/**\n * Get commit descriptions from the git history\n *\n * @link https://isomorphic-git.github.io/docs/log.html\n */\nasync function log (\n  fileSystem: EncryptedFS,\n  dir,\n  gitdir = path.join(dir, '.git'),\n  ref = 'HEAD',\n  depth,\n  since, // Date\n  signing = false\n) {\n  try {\n    let sinceTimestamp =\n      since === undefined ? undefined : Math.floor(since.valueOf() / 1000)\n    // TODO: In the future, we may want to have an API where we return a\n    // async iterator that emits commits.\n    let commits: any[] = []\n    let oid = await GitRefManager.resolve(fileSystem, gitdir, ref)\n    let tips /* : Array */ = [await logCommit(fileSystem, gitdir, oid, signing)]\n\n    while (true) {\n      let commit = tips.pop()\n\n      // Stop the loop if we encounter an error\n      if (commit.error) {\n        commits.push(commit)\n        break\n      }\n\n      // Stop the log if we've hit the age limit\n      if (\n        sinceTimestamp !== undefined &&\n        commit.committer.timestamp <= sinceTimestamp\n      ) {\n        break\n      }\n\n      commits.push(commit)\n\n      // Stop the loop if we have enough commits now.\n      if (depth !== undefined && commits.length === depth) break\n\n      // Add the parents of this commit to the queue\n      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.\n      for (const oid of commit.parent) {\n        let commit = await logCommit(fileSystem, gitdir, oid, signing)\n        if (!tips.map(commit => commit.oid).includes(commit.oid)) {\n          tips.push(commit)\n        }\n      }\n\n      // Stop the loop if there are no more commit parents\n      if (tips.length === 0) break\n\n      // Process tips in order by age\n      tips.sort(compareAge)\n    }\n    return commits\n  } catch (err) {\n    err.caller = 'git.log'\n    throw err\n  }\n}\n\nexport default log\nexport {logCommit}\n","import shasum from './shasum'\n\nclass GitObject {\n  static hash ({ type, object }) {\n    let buffer = Buffer.concat([\n      Buffer.from(`${type} ${object.byteLength.toString()}\\0`),\n      Buffer.from(object)\n    ])\n    let oid = shasum(buffer)\n    return oid\n  }\n  static wrap ({ type, object }) {\n    let buffer = Buffer.concat([\n      Buffer.from(`${type} ${object.byteLength.toString()}\\0`),\n      object\n    ])\n    let oid = shasum(buffer)\n    return {\n      oid,\n      buffer\n    }\n  }\n  static unwrap ({ oid, buffer }) {\n    if (oid) {\n      let sha = shasum(buffer)\n      if (sha !== oid) {\n        throw(new Error(`SHA check failed! Expected ${oid}, computed ${sha}`))\n      }\n    }\n    let s = buffer.indexOf(32) // first space\n    let i = buffer.indexOf(0) // first null value\n    let type = buffer.slice(0, s).toString('utf8') // get type of object\n    let length = buffer.slice(s + 1, i).toString('utf8') // get type of object\n    let actualLength = buffer.length - (i + 1)\n    // verify length\n    if (parseInt(length) !== actualLength) {\n      throw(new Error(`Length mismatch: expected ${length} bytes but got ${actualLength} instead.`))\n    }\n    return {\n      type,\n      object: Buffer.from(buffer.slice(i + 1))\n    }\n  }\n}\n\nexport default GitObject\n","import Hash from 'sha.js/sha1'\n\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasum (buffer: Buffer) {\n  return new Hash().update(buffer).digest('hex')\n}\n\nexport default shasum\n","module.exports = require(\"sha.js/sha1\");","/*::\ntype TreeEntry = {\n  mode: string,\n  path: string,\n  oid: string,\n  type?: string\n}\n*/\n\nfunction parseBuffer (buffer) {\n  let _entries: any[] = []\n  let cursor = 0\n  while (cursor < buffer.length) {\n    let space = buffer.indexOf(32, cursor)\n    if (space === -1) {\n      throw(new Error(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`))\n    }\n    let nullchar = buffer.indexOf(0, cursor)\n    if (nullchar === -1) {\n      throw(new Error(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`))\n    }\n    let mode = buffer.slice(cursor, space).toString('utf8')\n    if (mode === '40000') mode = '040000' // makes it line up neater in printed output\n    let type = mode === '040000' ? 'tree' : 'blob'\n    let path = buffer.slice(space + 1, nullchar).toString('utf8')\n    let oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex')\n    cursor = nullchar + 21\n    _entries.push({ mode, path, oid, type })\n  }\n  return _entries\n}\n\nfunction limitModeToAllowed (mode) {\n  if (typeof mode === 'number') {\n    mode = mode.toString(8)\n  }\n  // tree\n  if (mode.match(/^0?4.*/)) return '40000' // Directory\n  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file\n  if (mode.match(/^1007.*/)) return '100755' // Regular executable file\n  if (mode.match(/^120.*/)) return '120000' // Symbolic link\n  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)\n  throw(new Error(`Could not understand file mode: ${mode}`))\n}\n\nfunction nudgeIntoShape (entry) {\n  if (!entry.oid && entry.sha) {\n    entry.oid = entry.sha // Github\n  }\n  entry.mode = limitModeToAllowed(entry.mode) // index\n  if (!entry.type) {\n    entry.type = 'blob' // index\n  }\n  return entry\n}\n\nclass GitTree {\n  /* ::\n  _entries: Array<TreeEntry>\n  */\n _entries: any[]\n  constructor (entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries)\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(nudgeIntoShape)\n    } else {\n      throw(new Error('invalid type passed to GitTree constructor'))\n    }\n  }\n  static from (tree) {\n    return new GitTree(tree)\n  }\n  render () {\n    return this._entries\n      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n  toObject () {\n    return Buffer.concat(\n      this._entries.map((entry) => {\n        let mode = Buffer.from(entry.mode.replace(/^0/, ''))\n        let space = Buffer.from(' ')\n        let path = Buffer.from(entry.path)\n        // let path = Buffer.from(entry.path, { encoding: 'utf8' })\n        let nullchar = Buffer.from([0])\n        let oid = Buffer.from(entry.oid.match(/../g).map(n => parseInt(n, 16)))\n        return Buffer.concat([mode, space, path, nullchar, oid])\n      })\n    )\n  }\n  entries () {\n    return this._entries\n  }\n  * [Symbol.iterator] () {\n    for (let entry of this._entries) {\n      yield entry\n    }\n  }\n}\n\nexport default GitTree\n","module.exports = require(\"sha.js\");","module.exports = require(\"kbpgp\");","module.exports = require(\"util\");","module.exports = require(\"net\");","module.exports = require(\"tls\");","module.exports = require(\"protobufjs\");","/**\n * Returns a 5 character long random string of lower case letters\n */\nfunction randomString(): string {\n\treturn Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5)\n}\n\n/**\n * Inverts the provided promise\n * @param p Promise to invert\n */\nfunction invertPromise<T>(p: Promise<T>): Promise<T> {\n  return new Promise((res, rej) => p.then(rej, res));\n}\n\n/**\n * Gets the first promise fulfiled\n * @param ps List of promises\n */\nfunction firstPromiseFulfilled<T>(ps: Promise<T>[]) {\n  return invertPromise(Promise.all(ps.map(invertPromise)))\n}\n\nexport { randomString, firstPromiseFulfilled }\n","import dgram from 'dgram'\nimport crypto from 'crypto'\nimport PeerInfo from './PeerInfo'\nimport { EventEmitter } from 'events'\nimport RPCMessage from '../rpc/RPCMessage'\nimport KeyManager from '../keys/KeyManager'\n\n// This module is based heavily on libp2p's mDNS module:\n// https://github.com/libp2p/js-libp2p-mdns\n// It is supposed to discover peers on the local network\n// This module was also generated with the help of:\n// https://nrempel.com/using-udp-multicast-with-node-js/\n//\n// \"\"\"\n// In computer networking, the multicast DNS (mDNS) protocol\n// resolves hostnames to IP addresses within small networks\n// that do not include a local name server\n// \"\"\"\n\nconst UDP_MULTICAST_PORT = parseInt(process.env.UDP_MULTICAST_PORT ?? '5353');\nconst UDP_MULTICAST_ADDR = process.env.UDP_MULTICAST_ADDR ?? \"224.0.0.251\";\n\ntype PeerMessage = {\n  encryptedLocalPubKey: Buffer\n  encryptedPeerPubKey: Buffer\n  rawRandomMessage: Buffer\n  encryptedRandomMessage: Buffer\n}\n\nclass MulticastBroadcaster extends EventEmitter {\n  addPeer: (peerInfo: PeerInfo) => void\n  localPeerInfo: PeerInfo\n  keyManager: KeyManager\n\n  socket: dgram.Socket\n\n  interval: number\n  queryInterval: NodeJS.Timeout | null\n  peerPubKeyMessages: Map<string, PeerMessage> = new Map()\n  constructor(\n    addPeer: (peerInfo: PeerInfo) => void,\n    localPeerInfo: PeerInfo,\n    keyManager: KeyManager\n  ) {\n    super()\n\n    this.addPeer = addPeer\n    this.localPeerInfo = localPeerInfo\n    this.keyManager = keyManager\n\n    this.interval = (1e3)\n    this.queryInterval = null\n\n    // Create socket\n    this.socket = dgram.createSocket({ type: \"udp4\", reuseAddr: true })\n    this.socket.bind(<number>UDP_MULTICAST_PORT)\n\n    // Set up listener\n    this.socket.on(\"listening\", (() => {\n      this.socket.addMembership(UDP_MULTICAST_ADDR);\n      const address = this.socket.address();\n    }).bind(this));\n\n    // Handle messages\n    this.socket.on(\"message\", this.handleHandshakeMessages.bind(this));\n\n    // Start the query process\n    this.queryInterval = this.queryLAN()\n  }\n\n  /**\n   * Request a peer contact for the multicast peer discovery to check for\n   * @param publicKey Public key of the desired peer\n   */\n  async requestPeerContact(publicKey: string) {\n    const pubKeyBuf = Buffer.from(publicKey)\n    const randomMessage = crypto.randomBytes(16)\n    // Encrypt message\n    const encryptedPeerPubKey = await this.keyManager.encryptData(pubKeyBuf, pubKeyBuf)\n    const encryptedRandomMessage = await this.keyManager.encryptData(randomMessage, pubKeyBuf)\n    const encryptedLocalPubKey = await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()), pubKeyBuf)\n\n    // Add to peer messages to be sent over multicast\n    this.peerPubKeyMessages.set(publicKey, {\n      encryptedLocalPubKey: Buffer.from(encryptedLocalPubKey),\n      encryptedPeerPubKey: Buffer.from(encryptedPeerPubKey),\n      rawRandomMessage: randomMessage,\n      encryptedRandomMessage: Buffer.from(encryptedRandomMessage)\n    })\n  }\n\n  // ==== Helper methods ==== //\n  private queryLAN() {\n    const query = () => {\n      for (const pubKey of this.peerPubKeyMessages.keys()) {\n        const peerMessage = this.peerPubKeyMessages.get(pubKey)\n        if (peerMessage) {\n          const handshakeMessage = RPCMessage.encodeHandshakeMessage(\n            peerMessage.encryptedPeerPubKey,\n            peerMessage.encryptedLocalPubKey,\n            peerMessage.encryptedRandomMessage\n          )\n\n          this.socket.send(handshakeMessage, 0, handshakeMessage.length, UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR, () => {\n            console.info(`Sending message to peer`);\n          });\n        }\n\n      }\n    }\n\n    // Immediately start a query, then do it every interval.\n    query()\n    return setInterval(query, this.interval)\n  }\n\n  private async handleHandshakeMessages(message: any, rinfo: any) {\n    try {\n      const decodedMessage = RPCMessage.decodeHandshakeMessage(message)\n      console.info(`Message from: ${rinfo.address}:${rinfo.port}`);\n\n\n      // Try to decrypt message and pubKey\n      const decryptedMessage = await this.keyManager.decryptData(decodedMessage.message)\n      const decryptedTargetPubKey = await this.keyManager.decryptData(decodedMessage.targetPubKey)\n      const decryptedRequestingPubKey = await this.keyManager.decryptData(decodedMessage.requestingPubKey)\n\n      const myPubKey = this.keyManager.getPublicKey()\n\n      if (decryptedRequestingPubKey.toString() == myPubKey) { // Response\n        // Make sure decrypted bytes equal raw bytes in memory\n        const originalMessage = this.peerPubKeyMessages.get(decryptedTargetPubKey.toString())?.rawRandomMessage\n\n        if (decryptedMessage.toString() == originalMessage?.toString()) {  // Validated!\n          // Add peer info to peerStore\n          const newPeerInfo = decodedMessage.responsePeerInfo\n          if (newPeerInfo) {\n            this.addPeer(newPeerInfo)\n            // Remove peerId from requested messages\n            const pubKey = newPeerInfo.publicKey\n            this.peerPubKeyMessages.delete(pubKey)\n            console.log(`New peer added to the store`);\n            this.emit('found', newPeerInfo)\n          } else {\n            this.emit('error', \"I got a validated response. But no peerInfo\");\n          }\n        }\n      } else {  // Requests on target node\n        // Try decrypting message\n        // Re-encrypt the data and send it on its way\n\n        const encryptedTargetPubKey = await this.keyManager.encryptData(Buffer.from(myPubKey), decryptedRequestingPubKey)\n        const encryptedMessage = await this.keyManager.encryptData(decryptedMessage, decryptedRequestingPubKey)\n        const encryptedPubKey = await this.keyManager.encryptData(decryptedRequestingPubKey, decryptedRequestingPubKey)\n        const handshakeMessage = RPCMessage.encodeHandshakeMessage(\n          Buffer.from(encryptedTargetPubKey),\n          Buffer.from(encryptedPubKey),\n          Buffer.from(encryptedMessage),\n          this.localPeerInfo\n        )\n        this.socket.send(handshakeMessage, 0, handshakeMessage.length, <number>UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR);\n      }\n    } catch (err) { // Couldn't decode message\n      // We don't want the multicast discovery to error on every message it coudln't decode!\n    }\n  }\n}\n\nexport default MulticastBroadcaster\n","module.exports = require(\"dgram\");","module.exports = require(\"events\");","import forge from 'node-forge'\n\nclass PublicKeyInfrastructure {\n  static N_BITS: number = 2048\n  static COMMON_NAME: string = 'polykey'\n  static ORGANIZATION_NAME: string = 'MatrixAI'\n\n  /**\n   * Creates an X.509 certificate for transport layer security\n   * @param nbits The number of bits for keypair generation\n   * @param organizationName The name of the organization\n   */\n  static createX509Certificate(nbits: number = this.N_BITS, commonName: string = this.COMMON_NAME, organizationName: string = this.ORGANIZATION_NAME) {\n    const pki = forge.pki;\n\n    // generate a keypair and create an X.509v3 certificate\n    const keys = pki.rsa.generateKeyPair(nbits);\n    const cert = pki.createCertificate();\n    cert.publicKey = keys.publicKey;\n    // alternatively set public key from a csr\n    //cert.publicKey = csr.publicKey;\n    cert.serialNumber = '01';\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);\n\n    const attrs = [{\n      name: 'commonName',\n      value: commonName\n    }, {\n      name: 'organizationName',\n      value: organizationName\n    }];\n    cert.setSubject(attrs);\n    // alternatively set subject from a csr\n    //cert.setSubject(csr.subject.attributes);\n    cert.setIssuer(attrs);\n    cert.setExtensions([{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'extKeyUsage',\n      serverAuth: true,\n      clientAuth: true,\n      codeSigning: true,\n      emailProtection: true,\n      timeStamping: true\n    }, {\n      name: 'nsCertType',\n      client: true,\n      server: true,\n      email: true,\n      objsign: true,\n      sslCA: true,\n      emailCA: true,\n      objCA: true\n    }, {\n      name: 'subjectAltName',\n      altNames: {\n        type: 7, // IP\n        ip: '127.0.0.1'\n      }\n    }, {\n      name: 'subjectKeyIdentifier'\n    }]);\n    // self-sign certificate\n    cert.sign(keys.privateKey);\n\n    // convert a Forge certificate to PEM\n    const keyPem = pki.privateKeyToPem(keys.privateKey)\n    const certPem = pki.certificateToPem(cert);\n    return {\n      keyPem,\n      certPem\n    }\n  }\n}\n\nexport default PublicKeyInfrastructure\n","module.exports = require(\"node-forge\");","import fs from 'fs'\nimport net from 'net'\nimport Path from 'path'\nimport git from 'isomorphic-git'\nimport { EncryptedFS } from 'encryptedfs'\nimport { Address } from '../peers/PeerInfo'\nimport HttpRequest from '../HttpRequest'\n\n\ntype VaultMetadata = {\n  sharedPubKeys: string[]\n}\n\nclass Vault {\n\n  private key: Buffer\n  private keyLen: number\n  name: string\n  private efs: EncryptedFS\n  vaultPath: string\n  private secrets: Map<string, any>\n  private sharedPubKeys: Set<string>\n  private metadataPath: string\n  constructor(\n    name: string,\n    symKey: Buffer,\n    baseDir: string\n  ) {\n    // how do we create pub/priv key pair?\n    // do we use the same gpg pub/priv keypair\n    this.key = symKey\n    this.keyLen = symKey.length\n    // Set filesystem\n    const vfsInstance = new (require('virtualfs')).VirtualFS\n\n    this.efs = new EncryptedFS(\n      this.key,\n      vfsInstance,\n      vfsInstance,\n      fs,\n      process\n    )\n\n    this.name = name\n    this.vaultPath = Path.join(baseDir, name)\n    // make the vault directory\n    this.efs.mkdirSync(this.vaultPath, { recursive: true })\n    this.secrets = new Map()\n\n    this.loadSecrets()\n\n    // Load metadata\n    this.metadataPath = Path.join(this.vaultPath, '.vault', 'metadata')\n    this.loadMetadata()\n  }\n\n  /**\n   * Returns the Encrypted File System used for vault operations\n   */\n  public get EncryptedFS(): EncryptedFS {\n    return this.efs\n  }\n\n  /**\n   * Determines whether a secret exists in the vault\n   * @param secretName Name of desired secret\n   */\n  secretExists(secretName: string): boolean {\n    const secretPath = Path.join(this.vaultPath, secretName)\n    return this.secrets.has(secretName) && this.efs.existsSync(secretPath)\n  }\n\n  /**\n   * Adds a secret to the vault\n   * @param secretName Name of new secret\n   * @param secret Content of new secret\n   */\n  async addSecret(secretName: string, secret: Buffer): Promise<void> {\n    // Check if secret already exists\n    if (this.secrets.has(secretName)) {\n      throw new Error('Secret already exists, try updating it instead.')\n    }\n    const writePath = Path.join(this.vaultPath, secretName)\n    // Write secret\n    await this.efs.promises.writeFile(writePath, secret, {})\n    // Update secrets map\n    this.secrets.set(secretName, secret)\n    // Auto commit message\n    await this.commitChanges(`Add secret: ${secretName}`, secretName, 'added')\n  }\n\n  /**\n   * Updates a secret in the vault\n   * @param secretName Name of secret to be updated\n   * @param secret Content of updated secret\n   */\n  async updateSecret(secretName: string, secret: Buffer): Promise<void> {\n    // Check if secret already exists\n    if (!this.secrets.has(secretName)) {\n      throw new Error('Secret does not exist, try adding it instead.')\n    }\n    const writePath = Path.join(this.vaultPath, secretName)\n    // Write secret\n    await this.efs.promises.writeFile(writePath, secret, {})\n    // Update secrets map\n    this.secrets.set(secretName, secret)\n    // Auto commit message\n    await this.commitChanges(`Update secret: ${secretName}`, secretName, 'modified')\n  }\n\n  /**\n   * Get a secret from the vault\n   * @param secretName Name of secret to be retrieved\n   */\n  getSecret(secretName: string): Buffer | string {\n    if (this.secrets.has(secretName)) {\n      const secret = this.secrets.get(secretName)\n      if (secret) {\n        return secret\n      } else {\n        const secretPath = Path.join(this.vaultPath, secretName)\n        // TODO: this should be async\n        const secretBuf = this.efs.readFileSync(secretPath, {})\n        this.secrets.set(secretName, secretBuf)\n        return secretBuf\n      }\n    }\n    throw Error('Secret: ' + secretName + ' does not exist')\n  }\n\n  /**\n   * [WARNING] Removes a secret from the vault\n   * @param secretName Name of secret to be removed\n   */\n  async removeSecret(secretName: string): Promise<void> {\n    if (this.secrets.has(secretName)) {\n      const successful = this.secrets.delete(secretName)\n      // Remove from fs\n      await this.efs.promises.unlink(Path.join(this.vaultPath, secretName))\n      // Auto commit message\n      await this.commitChanges(`Remove secret: ${secretName}`, secretName, 'removed')\n\n      if (successful) {\n        return\n      }\n      throw Error('Secret: ' + secretName + ' was not removed')\n    }\n    throw Error('Secret: ' + secretName + ' does not exist')\n  }\n\n  /**\n   * Lists all the secrets currently in the vault\n   */\n  listSecrets(): string[] {\n    let secrets: string[] = Array.from(this.secrets.keys())\n    return secrets\n  }\n\n  tagVault() {\n\n  }\n\n  untagVault() {\n\n  }\n\n  /////////////\n  // Sharing //\n  /////////////\n  /**\n   * Allows a particular public key to access the vault\n   * @param publicKey Public key to share with\n   */\n  shareVault(publicKey: string) {\n    if (this.sharedPubKeys.has(name)) {\n      throw new Error('Vault is already shared with given public key')\n    }\n\n    this.sharedPubKeys.add(publicKey)\n\n    // Write metadata\n    this.writeMetadata()\n  }\n\n  /**\n   * Removes access to the vault for a particular public key\n   * @param publicKey Public key to unshare with\n   */\n  unshareVault(publicKey: string) {\n    if (!this.sharedPubKeys.has(publicKey)) {\n      throw new Error('Vault is not shared with given public key')\n    }\n\n    this.sharedPubKeys.delete(publicKey)\n\n    // Write metadata\n    this.writeMetadata()\n  }\n\n  /**\n   * Determines if a particular public key can access the vault\n   * @param publicKey Public key to check\n   */\n  peerCanAccess(publicKey: string): boolean {\n    // return this.sharedPubKeys.has(publicKey)\n    return true\n  }\n\n  /**\n   * Pulls the vault from a specific address\n   * @param address Address of polykey node that owns vault to be pulled\n   * @param getSocket Function to get an active connection to provided address\n   */\n  async pullVault(address: Address, getSocket: (address: Address) => net.Socket) {\n    const remoteUrl = \"http://\" + address.toString() + '/' + this.name\n\n    // Strangely enough this is needed for pulls along with ref set to 'HEAD'\n    // In isogit's documentation, this is just to get the currentBranch name\n    // But it solves a bug whereby if not used, git.pull complains that it can't\n    // find the master branch or HEAD\n    await git.currentBranch({\n      fs: { promises: this.efs.promises },\n      dir: this.vaultPath,\n      fullname: true\n    })\n\n    const httpRequest = new HttpRequest(address, getSocket)\n    // First pull\n    await git.pull({\n      fs: { promises: this.efs.promises },\n      http: httpRequest,\n      dir: this.vaultPath,\n      url: remoteUrl,\n      ref: 'HEAD',\n      singleBranch: true,\n      author: {\n        name: this.name\n      }\n    })\n\n    // Load any new secrets\n    this.loadSecrets()\n  }\n\n  /**\n   * Initializes the git repository for new vaults\n   */\n  async initRepository() {\n    const fileSystem = this.efs\n    await git.init({\n      fs: fileSystem,\n      dir: this.vaultPath\n    })\n\n    // Initial commit\n    await git.commit({\n      fs: fileSystem,\n      dir: this.vaultPath,\n      author: {\n        name: this.name\n      },\n      message: \"init commit\"\n    })\n\n    // Write packed-refs file because isomorphic git goes searching for it\n    // and apparently its not autogenerated\n    this.efs.writeFileSync(Path.join(this.vaultPath, '.git', 'packed-refs'), '# pack-refs with: peeled fully-peeled sorted')\n  }\n\n  // ============== Helper methods ============== //\n  private writeMetadata(): void {\n    // mkdir first\n    this.efs.mkdirSync(Path.dirname(this.metadataPath), { recursive: true })\n\n    // Create and write metadata\n    const metadata: VaultMetadata = {\n      sharedPubKeys: Array.from(this.sharedPubKeys.keys())\n    }\n    this.efs.writeFileSync(this.metadataPath, JSON.stringify(metadata))\n  }\n\n  private loadMetadata(): void {\n    if (this.efs.existsSync(this.metadataPath)) {\n      const fileContents = this.efs.readFileSync(this.metadataPath).toString()\n      const metadata: VaultMetadata = JSON.parse(fileContents)\n      this.sharedPubKeys = new Set(metadata.sharedPubKeys)\n    } else {\n      // Need to create it\n      this.sharedPubKeys = new Set()\n      this.writeMetadata()\n    }\n  }\n\n  private async commitChanges(message: string, secretName: string, action: 'added' | 'modified' | 'removed'): Promise<string> {\n    if (action == 'removed') {\n      await git.remove({\n        fs: this.efs,\n        dir: this.vaultPath,\n        filepath: secretName\n      })\n    } else {\n      await git.add({\n        fs: this.efs,\n        dir: this.vaultPath,\n        filepath: secretName\n      })\n    }\n\n    return await git.commit({\n      fs: this.efs,\n      dir: this.vaultPath,\n      author: {\n        name: this.name\n      },\n      message: message\n    })\n  }\n\n  private loadSecrets(): void {\n    const secrets = fs.readdirSync(this.vaultPath, undefined)\n\n    for (const secret of secrets.filter((s) => s[0] != '.')) {\n      this.secrets.set(secret, null)\n    }\n  }\n}\n\nexport default Vault\n"],"sourceRoot":""}