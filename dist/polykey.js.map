{"version":3,"sources":["webpack://polykey/webpack/universalModuleDefinition","webpack://polykey/webpack/bootstrap","webpack://polykey/external \"path\"","webpack://polykey/external \"os\"","webpack://polykey/external \"fs\"","webpack://polykey/external \"readable-stream\"","webpack://polykey/./src/lib/keys/KeyManager.ts","webpack://polykey/external \"crypto\"","webpack://polykey/./src/lib/peers/PeerManager.ts","webpack://polykey/external \"grpc\"","webpack://polykey/external \"@grpc/proto-loader\"","webpack://polykey/./src/lib/git/upload-pack/GitPktLine.ts","webpack://polykey/./src/lib/git/upload-pack/GitRefManager.ts","webpack://polykey/external \"pako\"","webpack://polykey/./src/lib/git/pack-objects/GitCommit.ts","webpack://polykey/./src/lib/git/pack-objects/GitObjectManager.ts","webpack://polykey/./src/lib/rpc/RPCMessage.ts","webpack://polykey/./src/lib/peers/PeerInfo.ts","webpack://polykey/./src/lib/vaults/VaultManager.ts","webpack://polykey/external \"isomorphic-git\"","webpack://polykey/external \"encryptedfs\"","webpack://polykey/external \"virtualfs\"","webpack://polykey/./src/lib/index.ts","webpack://polykey/./src/lib/Polykey.ts","webpack://polykey/external \"kbpgp\"","webpack://polykey/external \"util\"","webpack://polykey/./src/lib/git/GitClient.ts","webpack://polykey/./src/lib/git/GitBackend.ts","webpack://polykey/./src/lib/git/upload-pack/uploadPack.ts","webpack://polykey/./src/lib/git/upload-pack/GitPackedRefs.ts","webpack://polykey/./src/lib/git/side-band/GitSideBand.ts","webpack://polykey/external \"buffer\"","webpack://polykey/./src/lib/git/pack-objects/packObjects.ts","webpack://polykey/./src/lib/git/pack-objects/log.ts","webpack://polykey/./src/lib/git/pack-objects/GitObject.ts","webpack://polykey/./src/lib/git/pack-objects/shasum.ts","webpack://polykey/external \"sha.js/sha1\"","webpack://polykey/./src/lib/git/pack-objects/GitTree.ts","webpack://polykey/external \"sha.js\"","webpack://polykey/external \"protobufjs\"","webpack://polykey/./src/lib/utils.ts","webpack://polykey/./src/lib/peers/MulticastBroadcaster.ts","webpack://polykey/external \"dgram\"","webpack://polykey/external \"events\"","webpack://polykey/./src/lib/vaults/Vault.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","polyKeyPath","homedir","fileSystem","passphrase","useWebWorkers","workerPool","primaryKeyPair","private","public","metadata","privateKeyPath","publicKeyPath","pkiKeyPath","pkiCertPath","caCertPath","pkiInfo","cert","caCert","derivedKeys","Map","polykeyPath","keypairPath","join","existsSync","mkdirSync","metadataPath","loadMetadata","publicKey","readFileSync","privateKey","loadKeyPair","loadPKIInfo","email","nbits","replacePrimary","progressCallback","Error","flags","openpgp","params","asp","ASP","progress_hook","undefined","userid","primary","certify_keys","sign_data","auth","encrypt_comm","encrypt_storage","expire_in","subkeys","identity","promisify","KeyManager","generate","sign","export_pgp_public","keypair","export_pgp_private","primaryIdentity","loadPrivateKey","loadPublicKey","loadIdentity","keyBuffer","Buffer","from","promises","readFile","writeMetadata","toString","getPublicKey","getPrivateKey","import_from_armored_pgp","armored","merge_pgp_private","is_pgp_locked","unlock_pgp","path","writeFile","salt","randomBytes","pbkdf2Sync","pbkdf2","createPath","has","dirname","recursive","writeFileSync","mkdir","data","keyPassphrase","resolvedIdentity","getIdentityFromPrivateKey","queue","async","workerCrypto","signData","msg","sign_with","result_string","box","filePath","buffer","signedBuffer","signedPath","signature","ring","keyring","KeyRing","getIdentityFromPublicKey","add_key_manager","verifyData","keyfetch","keyManager","dataSigner","unbox","get_data_signer","get_key_manager","get_pgp_fingerprint","signaturePath","fileBuffer","signatureBuffer","encryptData","encrypt_for","decryptData","literals","writeToFile","storagePath","JSON","stringify","parse","keybaseDiscovery","findUser","handle","service","url","response","fetch","json","them","public_keys","bundle","err","message","vaultManager","peerInfo","socialDiscoveryServices","customPort","localPeerInfo","hasPublicKey","peerStore","push","multicastBroadcaster","addPeer","peerConnections","gitBackend","server","Server","protoLoader","PROTO_PATH","__dirname","packageDefinition","loadSync","keepCase","longs","String","enums","defaults","oneofs","git_server_proto","loadPackageDefinition","addService","GitServer","requestInfo","callback","vaultName","request","body","handleInfoRequest","requestPack","handlePackRequest","PKIInfo","credentials","ServerCredentials","createSsl","private_key","cert_chain","createInsecure","port","address","Address","start","connect","set","pubKey","Promise","resolve","reject","requestPeerContact","on","timedOutPubKey","tasks","socialDiscovery","error","console","log","pubKeyOrFail","firstPromiseFulfilled","length","pubKeyFound","findPubKey","peer","connectedAddr","existingSocket","peerAddress","getPeer","conn","encodePeerInfo","decodePeerInfo","line","hexlength","b","repeat","padHex","concat","stream","slice","parseInt","compareRefNames","a","_a","replace","_b","tmp","endsWith","GIT_FILES","GitRefManager","gitdir","text","encoding","refs","filepath","packedMap","packedRefs","files","recursiveDirectoryWalk","dir","results","readdir","then","list","pending","forEach","file","stat","isDirectory","res","catch","map","x","keys","startsWith","includes","sort","ref","depth","test","allpaths","refpaths","filter","sha","trim","negateExceptForZero","formatTimezoneOffset","minutes","Math","is","abs","hours","floor","strHours","strMinutes","parseTimezoneOffset","offset","match","Number","parseAuthor","author","timestamp","timezoneOffset","normalize","str","indent","split","GitCommit","commit","_commit","isBuffer","render","payload","headers","justHeaders","justMessage","parseHeaders","assign","indexOf","hs","h","obj","parent","Array","isArray","committer","tree","gpgsig","renderHeaders","PackfileCache","GitObjectManager","oid","format","source","getExternalRefDelta","read","readdirSync","filename","offsets","pack","load","result","inflate","type","unwrap","PeerInfoMessage","loadProto","lookupType","addresses","addr","errMsg","verify","encode","finish","decode","toObject","bytes","arrays","objects","targetPubKey","requestingPubKey","responsePeerInfo","HandshakeMessage","encodedMmessage","Root","resolvePath","origin","target","__filename","ip","addressString","components","addressInfo","Set","add","vaults","vaultKeys","vaultKey","entries","vault","validateVault","vaultExists","generateKey","initRepository","getVault","destroyVault","gitClient","vaultUrl","getRemoteInfo","http","vfsInstance","VirtualFS","newEfs","EncryptedFS","process","clone","fs","singleBranch","rmdirSync","delete","vaultPath","encryptedMetadata","default","peerManager","client","method","onProgress","u","URL","pathname","infoResponse","statusCode","statusMessage","iteratorFromData","packResponse","ended","next","done","peerCanAccess","responseBuffers","exists","createGitPacketLine","buffers","buffersToWrite","wantedObjectId","packResult","readable","PassThrough","progressStream","sideBand","mux","packstream","write","end","hexPrefix","advertiseRefs","capabilities","listRefs","unshift","symrefs","syms","caps","flush","writeRefsAdResponse","caller","GitPackedRefs","parsedConfig","comment","peeled","splitBuffer","maxBytes","index","buf","input","streamReader","packetlines","packfile","progress","nextBit","destroy","protocol","MAX_PACKET_LENGTH","output","packfileWasEmpty","packfileEnded","progressEnded","goodbye","types","blob","tag","ofs_delta","ref_delta","listObjects","oids","commits","trees","blobs","walk","entry","outputStream","hash","chunk","enc","update","writeObject","stype","lastFour","multibyte","byte","unpaddedChunk","deflate","digest","haves","shallows","unshallows","acks","oldshallows","logCommit","signing","withoutSignature","compareAge","since","sinceTimestamp","valueOf","tips","pop","byteLength","actualLength","nudgeIntoShape","limitModeToAllowed","GitTree","_entries","cursor","space","nullchar","parseBuffer","iterator","invertPromise","rej","randomString","random","substr","ps","all","UDP_MULTICAST_PORT","env","UDP_MULTICAST_ADDR","MulticastBroadcaster","EventEmitter","super","peerPubKeyMessages","interval","queryInterval","socket","createSocket","reuseAddr","addMembership","handleHandshakeMessages","queryLAN","pubKeyBuf","randomMessage","encryptedPeerPubKey","encryptedRandomMessage","encryptedLocalPubKey","rawRandomMessage","query","peerMessage","handshakeMessage","encodeHandshakeMessage","send","info","setInterval","rinfo","decodedMessage","decodeHandshakeMessage","decryptedMessage","decryptedTargetPubKey","decryptedRequestingPubKey","myPubKey","originalMessage","newPeerInfo","emit","encryptedTargetPubKey","encryptedMessage","encryptedPubKey","symKey","baseDir","keyLen","efs","secrets","loadSecrets","secretName","secretPath","secret","writePath","commitChanges","secretBuf","successful","unlink","sharedPubKeys","currentBranch","fullname","pull","init","fileContents","action","remove"],"mappings":"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","file":"polykey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"polykey\"] = factory();\n\telse\n\t\troot[\"polykey\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n","module.exports = require(\"path\");","module.exports = require(\"os\");","module.exports = require(\"fs\");","module.exports = require(\"readable-stream\");","import os from 'os'\nimport fs from 'fs'\nimport Path from 'path'\nimport kbpgp from 'kbpgp'\nimport crypto from 'crypto'\nimport { promisify } from 'util'\nimport { Pool, ModuleThread } from 'threads'\nimport { KeyManagerWorker } from '../keys/KeyManagerWorker'\nimport PublicKeyInfrastructure from './pki/PublicKeyInfrastructure'\nimport { pki } from 'node-forge'\n\ntype KeyManagerMetadata = {\n  privateKeyPath: string | null,\n  publicKeyPath: string | null,\n  pkiKeyPath: string | null,\n  pkiCertPath: string | null,\n  caCertPath: string | null,\n}\n\ntype KeyPair = {\n  private: string | null,\n  public: string | null\n}\ntype PKInfo = { key: Buffer | null, cert: Buffer | null, caCert: Buffer | null }\n\nclass KeyManager {\n  private primaryKeyPair: KeyPair = { private: null, public: null }\n  private primaryIdentity?: Object\n  private derivedKeys: Map<string, Buffer>\n  private useWebWorkers: boolean\n  private workerPool?: Pool<ModuleThread<KeyManagerWorker>>\n\n  polykeyPath: string\n  private fileSystem: typeof fs\n\n  private metadataPath: string\n  private metadata: KeyManagerMetadata = {\n    privateKeyPath: null,\n    publicKeyPath: null,\n    pkiKeyPath: null,\n    pkiCertPath: null,\n    caCertPath: null,\n  }\n\n  /////////\n  // PKI //\n  /////////\n  pkiInfo: PKInfo = { key: null, cert: null, caCert: null }\n\n  constructor(\n    polyKeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    passphrase?: string,\n    useWebWorkers: boolean = false,\n    workerPool?: Pool<ModuleThread<KeyManagerWorker>>\n  ) {\n    this.useWebWorkers = useWebWorkers\n    this.workerPool = workerPool\n    this.derivedKeys = new Map()\n    this.fileSystem = fileSystem\n\n    // Load key manager metadata\n    this.polykeyPath = polyKeyPath\n    const keypairPath = Path.join(polyKeyPath, '.keypair')\n    if (!this.fileSystem.existsSync(keypairPath)) {\n      this.fileSystem.mkdirSync(keypairPath)\n    }\n    this.metadataPath = Path.join(keypairPath, 'metadata')\n    this.loadMetadata()\n\n    // Load keys if they were provided\n    if (this.metadata.privateKeyPath && this.metadata.publicKeyPath && passphrase) {\n      // Load files into memory\n      const publicKey = this.fileSystem.readFileSync(this.metadata.publicKeyPath)\n      const privateKey = this.fileSystem.readFileSync(this.metadata.privateKeyPath)\n\n      // Load private and public keys\n      this.loadKeyPair(publicKey, privateKey, passphrase)\n    }\n\n    /////////\n    // PKI //\n    /////////\n    // Load pki keys and certs\n    if (this.metadata.pkiKeyPath) {\n      this.pkiInfo.key = fs.readFileSync(this.metadata.pkiKeyPath)\n    }\n    if (this.metadata.pkiCertPath) {\n      this.pkiInfo.cert = fs.readFileSync(this.metadata.pkiCertPath)\n    }\n    if (this.metadata.caCertPath) {\n      this.pkiInfo.caCert = fs.readFileSync(this.metadata.caCertPath)\n    }\n    this.loadPKIInfo(this.pkiInfo.key, this.pkiInfo.cert, this.pkiInfo.caCert, true)\n  }\n\n  /**\n   * Generates a new assymetric key pair (publicKey and privateKey).\n   * @param name Name of keypair owner\n   * @param email Email of keypair owner\n   * @param passphrase Passphrase to lock the keypair\n   * @param nbits Size of the new keypair\n   * @param replacePrimary If true, the generated keypair becomes the new primary identity of the key manager\n   * @param progressCallback A progress hook for keypair generation\n   */\n  async generateKeyPair(\n    name: string,\n    email: string,\n    passphrase: string,\n    nbits: number = 4096,\n    replacePrimary: boolean = false,\n    progressCallback?: (info) => void\n  ): Promise<KeyPair> {\n    // kbpgp doesn't seem to work for small nbits so set a minimum of 1024\n    if (nbits < 1024) {\n      throw new Error('nbits must be greater than 1024 for keypair generation')\n    }\n    // Define options\n    const flags = kbpgp[\"const\"].openpgp\n    const params = {\n      asp: (progressCallback) ? new kbpgp.ASP({ progress_hook: progressCallback }) : undefined,\n      userid: `${name} <${email}>`,\n      primary: {\n        nbits: nbits,\n        flags: flags.certify_keys | flags.sign_data | flags.auth | flags.encrypt_comm | flags.encrypt_storage,\n        expire_in: 0  // never expire\n      },\n      subkeys: []\n    }\n\n    const identity = await promisify(kbpgp.KeyManager.generate)(params)\n\n    await promisify(identity.sign.bind(identity))({})\n\n    // Export pub key first\n    const publicKey = await promisify(identity.export_pgp_public.bind(identity))({})\n\n    // Finally export priv key\n    const privateKey = await promisify(identity.export_pgp_private.bind(identity))({ passphrase: passphrase })\n\n    // Resolve to parent promise\n    const keypair = { private: privateKey, public: publicKey }\n    if (replacePrimary) {\n      // Set the new keypair\n      this.primaryKeyPair = keypair\n      // Set the new identity\n      this.primaryIdentity = identity\n    }\n\n    return keypair\n  }\n\n  /**\n   * Get the primary keypair\n   */\n  getKeyPair(): KeyPair {\n    return this.primaryKeyPair\n  }\n\n  /**\n   * Determines whether public key is loaded or not\n   */\n  hasPublicKey(): boolean {\n    return (this.primaryKeyPair.public) ? true : false\n  }\n\n  /**\n   * Get the public key of the primary keypair\n   */\n  getPublicKey(): string {\n    if (!this.primaryKeyPair.public) {\n      throw new Error('Public key does not exist in memory')\n    }\n    return this.primaryKeyPair.public\n  }\n\n  /**\n   * Get the private key of the primary keypair\n   */\n  getPrivateKey(): string {\n    if (!this.primaryKeyPair.private) {\n      throw new Error('Private key does not exist in memory')\n    }\n    return this.primaryKeyPair.private\n  }\n\n  /**\n   * Loads the keypair into the key manager as the primary identity\n   * @param publicKey Public Key\n   * @param privateKey Private Key\n   * @param passphrase Passphrase to unlock the private key\n   */\n  async loadKeyPair(publicKey: string | Buffer, privateKey: string | Buffer, passphrase: string): Promise<void> {\n    await this.loadPrivateKey(privateKey)\n    await this.loadPublicKey(publicKey)\n    await this.loadIdentity(passphrase)\n  }\n\n  /**\n   * Loads the private key into the primary keypair\n   * @param privateKey Private Key\n   */\n  async loadPrivateKey(privateKey: string | Buffer): Promise<void> {\n    let keyBuffer: Buffer\n    if (typeof privateKey === 'string') {\n      keyBuffer = Buffer.from(await this.fileSystem.promises.readFile(privateKey))\n      this.metadata.privateKeyPath = privateKey\n      this.writeMetadata()\n    } else {\n      keyBuffer = privateKey\n    }\n    this.primaryKeyPair.private = keyBuffer.toString()\n  }\n\n  /**\n   * Loads the public key into the primary keypair\n   * @param publicKey Public Key\n   */\n  async loadPublicKey(publicKey: string | Buffer): Promise<void> {\n    let keyBuffer: Buffer\n    if (typeof publicKey === 'string') {\n      keyBuffer = Buffer.from(await this.fileSystem.promises.readFile(publicKey))\n      this.metadata.publicKeyPath = publicKey\n      this.writeMetadata()\n    } else {\n      keyBuffer = publicKey\n    }\n    this.primaryKeyPair.public = keyBuffer.toString()\n  }\n\n  /**\n   * Loads the primary identity into the key manager from the existing keypair\n   * @param passphrase Passphrase to unlock the private key\n   */\n  async loadIdentity(passphrase: string): Promise<void> {\n    const publicKey: string = this.getPublicKey()\n    const privateKey: string = this.getPrivateKey()\n\n    const identity = await promisify(kbpgp.KeyManager.import_from_armored_pgp)({ armored: publicKey })\n\n    await promisify(identity.merge_pgp_private.bind(identity))({ armored: privateKey })\n\n    if (identity.is_pgp_locked.bind(identity)()) {\n      await promisify(identity.unlock_pgp.bind(identity))({ passphrase: passphrase })\n    }\n\n    this.primaryIdentity = identity\n  }\n\n  /**\n   * Export the primary private key to a specified location\n   * @param path Destination path\n   */\n  async exportPrivateKey(path: string): Promise<void> {\n    await this.fileSystem.promises.writeFile(path, this.primaryKeyPair.private)\n    this.metadata.privateKeyPath = path\n    this.writeMetadata()\n  }\n\n  /**\n   * Export the primary public key to a specified location\n   * @param path Destination path\n   */\n  async exportPublicKey(path: string): Promise<void> {\n    await this.fileSystem.promises.writeFile(path, this.primaryKeyPair.public)\n    this.metadata.publicKeyPath = path\n    this.writeMetadata()\n  }\n\n  /**\n   * Synchronously generates a new symmetric key and stores it in the key manager\n   * @param name Unique name of the generated key\n   * @param passphrase Passphrase to derive the key from\n   */\n  generateKeySync(name: string, passphrase: string): Buffer {\n    const salt = crypto.randomBytes(32)\n    this.derivedKeys[name] = crypto.pbkdf2Sync(passphrase, salt, 10000, 256 / 8, 'sha256')\n\n    return this.derivedKeys[name]\n  }\n\n  /**\n   * Asynchronously Generates a new symmetric key and stores it in the key manager\n   * @param name Unique name of the generated key\n   * @param passphrase Passphrase to derive the key from\n   */\n  async generateKey(name: string, passphrase: string): Promise<Buffer> {\n    const salt = crypto.randomBytes(32)\n    this.derivedKeys[name] = await promisify(crypto.pbkdf2)(passphrase, salt, 10000, 256 / 8, 'sha256')\n\n    return this.derivedKeys[name]\n  }\n\n  /**\n   * Synchronously imports an existing key from file or Buffer\n   * @param name Unique name of the imported key\n   * @param key Key to be imported\n   */\n  importKeySync(name: string, key: string | Buffer): void {\n    if (typeof key === 'string') {\n      this.derivedKeys[name] = this.fileSystem.readFileSync(key)\n    } else {\n      this.derivedKeys[name] = key\n    }\n  }\n\n  /**\n   * Asynchronously imports an existing key from file or Buffer\n   * @param name Unique name of the imported key\n   * @param key Key to be imported\n   */\n  async importKey(name: string, key: string | Buffer): Promise<void> {\n    if (typeof key === 'string') {\n      this.derivedKeys[name] = await this.fileSystem.promises.readFile(key)\n    } else {\n      this.derivedKeys[name] = key\n    }\n  }\n\n  /**\n   * Synchronously exports an existing key from file or Buffer\n   * @param name Name of the key to be exported\n   * @param path Destination path\n   * @param createPath If set to true, the path is recursively created\n   */\n  exportKeySync(name: string, path: string, createPath?: boolean): void {\n    if (!this.derivedKeys.has(name)) {\n      throw Error(`There is no key loaded for name: ${name}`)\n    }\n    if (createPath) {\n      this.fileSystem.mkdirSync(Path.dirname(path), { recursive: true })\n    }\n    this.fileSystem.writeFileSync(path, this.derivedKeys[name])\n  }\n\n  /**\n   * Asynchronously exports an existing key from file or Buffer\n   * @param name Name of the key to be exported\n   * @param path Destination path\n   * @param createPath If set to true, the path is recursively created\n   */\n  async exportKey(name: string, path: string, createPath?: boolean): Promise<void> {\n    if (!this.derivedKeys.has(name)) {\n      throw Error(`There is no key loaded for name: ${name}`)\n    }\n    if (createPath) {\n      await this.fileSystem.promises.mkdir(Path.dirname(path), { recursive: true })\n    }\n    await this.fileSystem.promises.writeFile(path, this.derivedKeys[name])\n  }\n\n  /**\n   * Loads an identity from the given public key\n   * @param publicKey Buffer containing the public key\n   */\n  async getIdentityFromPublicKey(publicKey: Buffer): Promise<Object> {\n    const identity = await promisify(kbpgp.KeyManager.import_from_armored_pgp)({ armored: publicKey })\n    return identity\n  }\n\n  /**\n   * Loads an identity from the given private key\n   * @param publicKey Buffer containing the public key\n   */\n  async getIdentityFromPrivateKey(privateKey: Buffer, passphrase: string): Promise<Object> {\n    const identity = await promisify(kbpgp.KeyManager.import_from_armored_pgp)({ armored: privateKey })\n    if (identity.is_pgp_locked()) {\n      await promisify(identity.unlock_pgp)({ passphrase: passphrase })\n    }\n    return identity\n  }\n\n  /**\n   * Signs the given data with the provided key or the primary key if none is specified\n   * @param data Buffer or file containing the data to be signed\n   * @param privateKey Buffer containing the key to sign with. Defaults to primary private key if no key is given.\n   * @param keyPassphrase Required if privateKey is provided.\n   */\n  async signData(data: Buffer | string, privateKey?: Buffer, keyPassphrase?: string): Promise<Buffer> {\n    let resolvedIdentity: Object\n    if (privateKey) {\n      if (!keyPassphrase) {\n        throw new Error('passphrase for private key was not provided')\n      }\n      resolvedIdentity = await this.getIdentityFromPrivateKey(privateKey, keyPassphrase!)\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw new Error('no identity available for signing')\n    }\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.signData(data, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      const params = {\n        msg: data.toString(),\n        sign_with: resolvedIdentity\n      }\n      const result_string = await promisify(kbpgp.box)(params)\n\n      return Buffer.from(result_string)\n    }\n  }\n\n  /**\n   * Signs the given file with the provided key or the primary key if none is specified\n   * @param filePath Path to file containing the data to be signed\n   * @param privateKey The key to sign with. Defaults to primary public key if no key is given.\n   * @param keyPassphrase Required if privateKey is provided.\n   */\n  async signFile(filePath: string, privateKey?: string | Buffer, keyPassphrase?: string): Promise<string> {\n    // Get key if provided\n    let keyBuffer: Buffer\n    if (privateKey) {\n      if (typeof privateKey === 'string') {  // Path\n        // Read in from fs\n        keyBuffer = Buffer.from(this.fileSystem.readFileSync(privateKey))\n      } else {  // Buffer\n        keyBuffer = privateKey\n      }\n    }\n    // Read file into buffer\n    const buffer = Buffer.from(this.fileSystem.readFileSync(filePath))\n    // Sign the buffer\n    const signedBuffer = await this.signData(buffer, keyBuffer!, keyPassphrase)\n    // Write buffer to signed file\n    const signedPath = `${filePath}.sig`\n    this.fileSystem.writeFileSync(signedPath, signedBuffer)\n    return signedPath\n  }\n\n  /**\n   * Verifies the given data with the provided key or the primary key if none is specified\n   * @param data Buffer or file containing the data to be verified\n   * @param signature The PGP signature\n   * @param publicKey Buffer containing the key to verify with. Defaults to primary public key if no key is given.\n   */\n  async verifyData(data: Buffer | string, signature: Buffer, publicKey?: Buffer): Promise<boolean> {\n    const ring = new kbpgp.keyring.KeyRing;\n    let resolvedIdentity: Object\n    if (publicKey) {\n      resolvedIdentity = await this.getIdentityFromPublicKey(publicKey)\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw new Error('no identity available for verifying')\n    }\n    ring.add_key_manager(resolvedIdentity)\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.verifyData(data, signature, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      const params = {\n        armored: signature,\n        data: data,\n        keyfetch: ring\n      }\n      const literals = await promisify(kbpgp.unbox)(params)\n      // Get the identity that signed the data if any\n      let dataSigner = literals[0].get_data_signer()\n      // Retrieve the key manager associated with that data signer\n      let keyManager: any\n      if (dataSigner) {\n        keyManager = dataSigner.get_key_manager()\n      }\n      // If we know the pgp finger print then we say the data is verified.\n      // Otherwise it is unverified.\n      if (keyManager) {\n        if (keyManager.get_pgp_fingerprint()) {\n          return true\n        } else {\n          return false\n        }\n      } else {\n        return false\n      }\n    }\n  }\n\n  /**\n   * Verifies the given file with the provided key or the primary key if none is specified\n   * @param filePath Path to file containing the data to be verified\n   * @param signaturePath The path to the file containing the PGP signature\n   * @param publicKey Buffer containing the key to verify with. Defaults to primary public key if no key is given.\n   */\n  async verifyFile(filePath: string, signaturePath: string, publicKey?: string | Buffer): Promise<boolean> {\n    // Get key if provided\n    let keyBuffer: Buffer\n    if (publicKey) {\n      if (typeof publicKey === 'string') {  // Path\n        // Read in from fs\n        keyBuffer = this.fileSystem.readFileSync(publicKey)\n      } else {  // Buffer\n        keyBuffer = publicKey\n      }\n    }\n    // Read in file buffer and signature\n    const fileBuffer = this.fileSystem.readFileSync(filePath)\n    const signatureBuffer = this.fileSystem.readFileSync(signaturePath)\n    const isVerified = await this.verifyData(fileBuffer, signatureBuffer, keyBuffer!)\n    return isVerified\n  }\n\n  /**\n   * Encrypts the given data for a specific public key\n   * @param data The data to be encrypted\n   * @param publicKey The key to encrypt for\n   */\n  async encryptData(data: Buffer, publicKey?: Buffer): Promise<string> {\n    let resolvedIdentity: Object\n    if (publicKey) {\n      resolvedIdentity = await this.getIdentityFromPublicKey(publicKey)\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw new Error(`Identity could not be resolved for encrypting`)\n    }\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.encryptData(data, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      const params = {\n        msg: data,\n        encrypt_for: resolvedIdentity\n      }\n      const result_string = await promisify(kbpgp.box)(params)\n      return result_string\n    }\n  }\n\n  /**\n   * Decrypts the given data with the provided key or the primary key if none is given\n   * @param data The data to be decrypted\n   * @param privateKey The key to decrypt with. Defaults to primary private key if no key is given.\n   * @param keyPassphrase Required if privateKey is provided.\n   */\n  async decryptData(data: Buffer, privateKey?: Buffer, keyPassphrase?: string): Promise<Buffer> {\n    var ring = new kbpgp.keyring.KeyRing;\n    let resolvedIdentity: Object\n    if (privateKey) {\n      if (keyPassphrase) {\n        resolvedIdentity = await this.getIdentityFromPrivateKey(privateKey, keyPassphrase)\n      } else {\n        throw new Error('A key passphrase must be supplied if a privateKey is specified')\n      }\n    } else if (this.primaryIdentity) {\n      resolvedIdentity = this.primaryIdentity\n    } else {\n      throw (Error('no identity available for signing'))\n    }\n\n    if (this.useWebWorkers && this.workerPool) {\n      const workerResponse = await this.workerPool.queue(async (workerCrypto) => {\n        return await workerCrypto.decryptData(data, resolvedIdentity);\n      });\n      return workerResponse\n    } else {\n      ring.add_key_manager(resolvedIdentity)\n      const params = {\n        armored: data.toString(),\n        keyfetch: ring\n      }\n      const literals = await promisify(kbpgp.unbox)(params)\n      const decryptedData = Buffer.from(literals[0].toString())\n      return decryptedData\n    }\n  }\n\n  /////////\n  // PKI //\n  /////////\n  public get PKIInfo(): PKInfo {\n    return this.pkiInfo\n  }\n\n  loadPKIInfo(key?: Buffer | null, cert?: Buffer | null, caCert?: Buffer | null, writeToFile: boolean = false) {\n    if (key) {\n      this.pkiInfo.key = key\n    }\n\n    if (cert) {\n      this.pkiInfo.cert = cert\n    }\n\n    if (caCert) {\n      this.pkiInfo.caCert = caCert\n    }\n\n    if (writeToFile) {\n      // Store in the metadata path folder\n      const storagePath = Path.dirname(this.metadataPath)\n\n      if (key) {\n        this.metadata.pkiKeyPath = Path.join(storagePath, 'pki_private_key')\n        fs.writeFileSync(this.metadata.pkiKeyPath, key)\n      }\n\n      if (cert) {\n        this.metadata.pkiCertPath = Path.join(storagePath, 'pki_cert')\n        fs.writeFileSync(this.metadata.pkiCertPath, cert)\n      }\n\n      if (caCert) {\n        this.metadata.caCertPath = Path.join(storagePath, 'ca_cert')\n        fs.writeFileSync(this.metadata.caCertPath, caCert)\n      }\n    }\n  }\n\n  /* ============ HELPERS =============== */\n  /**\n   * Get the key for a given name\n   * @param name The unique name of the desired key\n   */\n  getKey(name: string): Buffer {\n    return this.derivedKeys[name]\n  }\n\n  /**\n   * Determines if the Key Manager has a certain key\n   * @param name The unique name of the desired key\n   */\n  hasKey(name: string): boolean {\n    if (this.derivedKeys[name]) {\n      return true\n    }\n    return false\n  }\n\n  private writeMetadata(): void {\n    const metadata = JSON.stringify(this.metadata)\n    this.fileSystem.writeFileSync(this.metadataPath, metadata)\n  }\n  private loadMetadata(): void {\n    // Check if file exists\n    if (this.fileSystem.existsSync(this.metadataPath)) {\n      const metadata = this.fileSystem.readFileSync(this.metadataPath).toString()\n      this.metadata = JSON.parse(metadata)\n    }\n  }\n}\n\nexport default KeyManager\nexport { KeyPair }\n","module.exports = require(\"crypto\");","import os from 'os';\nimport fs from 'fs';\nimport path from 'path';\nimport grpc from 'grpc';\nimport GitClient from '../git/GitClient';\nimport GitBackend from '../git/GitBackend';\nimport RPCMessage from '../rpc/RPCMessage';\nimport KeyManager from '../keys/KeyManager';\nimport { firstPromiseFulfilled } from '../utils';\nimport VaultManager from '../vaults/VaultManager';\nimport PeerInfo, { Address } from '../peers/PeerInfo';\nimport MulticastBroadcaster from '../peers/MulticastBroadcaster';\n\ninterface SocialDiscovery {\n  // Must return a public pgp key\n  name: string\n  findUser(handle: string, service: string): Promise<string>\n}\n\nconst keybaseDiscovery: SocialDiscovery = {\n  name: 'Keybase',\n  findUser: async (handle: string, service: string): Promise<string> => {\n    const url = `https://keybase.io/_/api/1.0/user/lookup.json?${service}=${handle}`\n\n    try {\n      const response = await fetch(url)\n      const data = await response.json()\n\n      const pubKey = data.them[0].public_keys.primary.bundle\n      return pubKey\n    } catch (err) {\n      throw new Error(`User was not found: ${err.message}`)\n    }\n  }\n}\n\ntype PeerManagerMetadata = {\n  localPeerInfo: PeerInfo | null\n}\n\nclass PeerManager {\n  private fileSystem: typeof fs\n\n  private metadataPath: string\n  private metadata: PeerManagerMetadata = { localPeerInfo: null }\n\n  private localPeerInfo: PeerInfo\n  private peerStore: Map<string, PeerInfo>\n  private keyManager: KeyManager\n  multicastBroadcaster: MulticastBroadcaster\n  private socialDiscoveryServices: SocialDiscovery[]\n\n  // Peer connections\n  server: grpc.Server\n  private gitBackend: GitBackend\n  private credentials: grpc.ServerCredentials\n  private peerConnections: Map<string, GitClient>\n\n  constructor(\n    polykeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    keyManager: KeyManager,\n    vaultManager: VaultManager,\n    peerInfo?: PeerInfo,\n    socialDiscoveryServices: SocialDiscovery[] = [],\n    customPort?: number\n  ) {\n    this.fileSystem = fileSystem\n\n    this.fileSystem.mkdirSync(polykeyPath, { recursive: true })\n    this.metadataPath = path.join(polykeyPath, '.peerMetadata')\n\n    // Set given variables\n    this.keyManager = keyManager\n    this.socialDiscoveryServices = socialDiscoveryServices\n\n    // Load metadata with peer info\n    this.loadMetadata()\n\n    // Load peer store and local peer info\n    if (peerInfo) {\n      this.localPeerInfo = peerInfo\n      this.writeMetadata()\n    } else if (this.metadata.localPeerInfo) {\n      this.localPeerInfo = this.metadata.localPeerInfo\n    } else if (this.keyManager.hasPublicKey()) {\n      this.localPeerInfo = new PeerInfo(this.keyManager.getPublicKey())\n    }\n    this.peerStore = new Map()\n\n    this.socialDiscoveryServices = []\n    this.socialDiscoveryServices.push(keybaseDiscovery)\n    for (const service of socialDiscoveryServices) {\n      this.socialDiscoveryServices.push(service)\n    }\n\n    this.multicastBroadcaster = new MulticastBroadcaster(this.addPeer, this.localPeerInfo, this.keyManager)\n\n    this.peerConnections = new Map()\n    /////////////////\n    // GRPC Server //\n    /////////////////\n    this.gitBackend = new GitBackend(polykeyPath, vaultManager)\n    this.server = new grpc.Server();\n    const protoLoader = require('@grpc/proto-loader')\n    const PROTO_PATH = __dirname + '/../../proto/git_server.proto';\n\n    const packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n      keepCase: true,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true\n    });\n\n    const git_server_proto = grpc.loadPackageDefinition(packageDefinition);\n\n    // Add service\n    async function requestInfo(call, callback) {\n      const vaultName = call.request.vaultName\n      const body = await this.gitBackend.handleInfoRequest(vaultName)\n      callback(null, { vaultName: vaultName, body: body });\n    }\n\n    async function requestPack(call, callback) {\n      const vaultName = call.request.vaultName\n      const body = call.request.body.toString()\n      callback(null, { vaultName: vaultName, body: await this.gitBackend.handlePackRequest(vaultName, body) });\n    }\n    this.server.addService((git_server_proto.GitServer as any).service, {\n      requestInfo: requestInfo.bind(this),\n      requestPack: requestPack.bind(this)\n    });\n\n    // Create the server credentials. SSL only if ca cert exists\n    const pkiInfo = this.keyManager.PKIInfo\n    if (pkiInfo.caCert && pkiInfo.cert && pkiInfo.key) {\n      this.credentials = grpc.ServerCredentials.createSsl(\n        pkiInfo.caCert,\n        [{\n          private_key: pkiInfo.key,\n          cert_chain: pkiInfo.cert,\n        }],\n        true\n      )\n    } else {\n      this.credentials = grpc.ServerCredentials.createInsecure()\n    }\n\n    // Bind server and set address\n    const port = this.server.bind('0.0.0.0:0', this.credentials);\n    const address = new Address('localhost', port.toString())\n    this.server.start();\n    this.localPeerInfo.connect(address)\n  }\n\n  ////////////////\n  // Peer store //\n  ////////////////\n  /**\n   * Get the peer info of the current keynode\n   */\n  getLocalPeerInfo(): PeerInfo {\n    return this.localPeerInfo\n  }\n\n  /**\n   * Set the address of the active server\n   * @param adress Address of active server\n   */\n  connectLocalPeerInfo(address: Address) {\n    this.localPeerInfo.connect(address)\n  }\n\n  /**\n   * Add a peer's info to the peerStore\n   * @param peerInfo Info of the peer to be added\n   */\n  addPeer(peerInfo: PeerInfo): void {\n    this.peerStore.set(peerInfo.publicKey, peerInfo)\n  }\n\n  /**\n   * Retrieves a peer for the given public key\n   * @param publicKey Public key of the desired peer\n   */\n  getPeer(publicKey: string): PeerInfo | null {\n    return this.peerStore.get(publicKey) ?? null\n  }\n\n  /**\n   * Determines if the peerStore contains the desired peer\n   * @param publicKey Public key of the desired peer\n   */\n  hasPeer(pubKey: string): boolean {\n    return this.peerStore.has(pubKey)\n  }\n\n  //////////////////////\n  // Social discovery //\n  //////////////////////\n  /**\n   * Finds an existing peer using multicast peer discovery\n   * @param publicKey Public key of the desired peer\n   */\n  async findPubKey(publicKey: string): Promise<PeerInfo> {\n    return new Promise<PeerInfo>((resolve, reject) => {\n      this.multicastBroadcaster.requestPeerContact(publicKey)\n      this.multicastBroadcaster.on('found', (peerInfo: PeerInfo) => {\n        if (peerInfo.publicKey == publicKey) {\n          resolve(peerInfo)\n        }\n      })\n\n      this.multicastBroadcaster.on('timeout', (timedOutPubKey: string) => {\n        if (timedOutPubKey == publicKey) {\n          reject('The broadcaster stopped looking')\n        }\n      })\n    })\n  }\n\n  /**\n   * Finds an existing peer given a social service and handle\n   * @param handle Username or handle of the user (e.g. @john-smith)\n   * @param service Service on which to search for the user (e.g. github)\n   */\n  async findSocialUser(handle: string, service: string): Promise<PeerInfo> {\n    const tasks: Promise<string>[] = []\n    for (const socialDiscovery of this.socialDiscoveryServices) {\n\n      try {\n        tasks.push(socialDiscovery.findUser(handle, service))\n      } catch (error) {\n        console.log(`Could not find user on this discovery service: ${socialDiscovery.name}`);\n      }\n    }\n\n    const pubKeyOrFail = await firstPromiseFulfilled(tasks)\n    if (pubKeyOrFail.length > 1) {\n      throw new Error('Could not find public key from services')\n    }\n\n    const pubKeyFound = pubKeyOrFail[0]\n    const peerInfo = await this.findPubKey(pubKeyFound)\n    return peerInfo\n  }\n\n  ///////////////////////\n  // Peers Connections //\n  ///////////////////////\n  /**\n   * Get a secure connection to the peer\n   * @param peer Public key of an existing peer or address of new peer\n   */\n  connectToPeer(peer: string | Address): GitClient {\n    // Throw error if trying to connect to self\n    if (peer == this.localPeerInfo.connectedAddr || peer == this.localPeerInfo.publicKey) {\n      throw new Error('Cannot connect to self')\n    }\n    let address: Address\n    if (typeof peer == 'string') {\n      const existingSocket = this.peerConnections.get(peer)\n      if (existingSocket) {\n        return existingSocket\n      }\n      const peerAddress = this.getPeer(peer)?.connectedAddr\n\n      if (peerAddress) {\n        address = peerAddress\n      } else {\n        throw new Error('Peer does not exist in peer store')\n      }\n    } else {\n      address = peer\n    }\n\n    const conn = new GitClient(address, this.keyManager)\n\n    if (typeof peer == 'string') {\n      this.peerConnections.set(peer, conn)\n    }\n\n    return conn\n  }\n\n  /* ============ HELPERS =============== */\n  private writeMetadata(): void {\n    const metadata = JSON.stringify(RPCMessage.encodePeerInfo(this.localPeerInfo))\n    this.fileSystem.writeFileSync(this.metadataPath, metadata)\n  }\n  private loadMetadata(): void {\n    // Check if file exists\n    if (this.fileSystem.existsSync(this.metadataPath)) {\n      const metadata = this.fileSystem.readFileSync(this.metadataPath).toString()\n      this.localPeerInfo = RPCMessage.decodePeerInfo(Buffer.from(metadata))\n    }\n  }\n}\n\nexport default PeerManager\nexport { SocialDiscovery }\n","module.exports = require(\"grpc\");","module.exports = require(\"@grpc/proto-loader\");","/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementors MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\n\n\nfunction padHex(b, n) {\n  const s = n.toString(16)\n  return '0'.repeat(b - s.length) + s\n}\n\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\n\nclass GitPktLine {\n  static flush() {\n    return Buffer.from('0000', 'utf8')\n  }\n\n  static encode(line) {\n    if (typeof line === 'string') {\n      line = Buffer.from(line)\n    }\n    const length = line.length + 4\n    const hexlength = padHex(4, length)\n    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])\n  }\n\n  static streamReader (stream) {\n    return async function read () {\n      try {\n        let length = await stream.slice(4)\n        if (length === null) return true\n        length = parseInt(length.toString('utf8'), 16)\n        if (length === 0) return null\n        let buffer = await stream.slice(length - 4)\n        if (buffer === null) return true\n        return buffer\n      } catch (err) {\n        console.log('error', err)\n        return true\n      }\n    }\n  }\n}\n\nexport default GitPktLine\n","// This is a convenience wrapper for reading and writing files in the 'refs' directory.\nimport path from 'path'\nimport { EncryptedFS } from 'encryptedfs'\nimport GitPackedRefs from './GitPackedRefs'\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst refpaths = ref => [\n  `${ref}`,\n  `refs/${ref}`,\n  `refs/tags/${ref}`,\n  `refs/heads/${ref}`,\n  `refs/remotes/${ref}`,\n  `refs/remotes/${ref}/HEAD`,\n]\n\nfunction compareRefNames(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  const _a = a.replace(/\\^\\{\\}$/, '')\n  const _b = b.replace(/\\^\\{\\}$/, '')\n  const tmp = -(_a < _b) || +(_a > _b)\n  if (tmp === 0) {\n    return a.endsWith('^{}') ? 1 : -1\n  }\n  return tmp\n}\n\n\n// @see https://git-scm.com/docs/gitrepository-layout\nconst GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir']\n\n\n// This function is used to get all the files in the refs folder for listRefs function\nasync function recursiveDirectoryWalk(dir: string, fileSystem: EncryptedFS): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n    let results: string[] = [];\n    fileSystem.promises.readdir(dir).then(async (list) => {\n      var pending = list.length;\n      if (!pending) return resolve(results);\n      list.forEach(async function(file) {\n        file = path.resolve(dir, file);\n        fileSystem.promises.stat(file).then(async (stat) => {\n          if (stat && stat.isDirectory()) {\n            const res = await recursiveDirectoryWalk(file, fileSystem)\n            results = results.concat(res);\n            if (!--pending) resolve(results);\n          } else {\n            results.push(file);\n            if (!--pending) resolve(results);\n          }\n        });\n      });\n    }).catch((err) => {\n      if (err) return reject(err);\n    })\n  })\n};\n\nclass GitRefManager {\n  static async packedRefs(fileSystem: EncryptedFS, gitdir: string) {\n    const text = fileSystem.readFileSync(`${gitdir}/packed-refs`, { encoding: 'utf8' })\n    const packed = GitPackedRefs.from(text)\n    return packed.refs\n  }\n\n  // List all the refs that match the `filepath` prefix\n  static async listRefs(fileSystem: EncryptedFS, gitdir: string, filepath: string): Promise<string[]> {\n    const packedMap = GitRefManager.packedRefs(fileSystem, gitdir)\n    let files: string[] = []\n    try {\n      files = await recursiveDirectoryWalk(`${gitdir}/${filepath}`, fileSystem)\n\n      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''))\n    } catch (err) {\n      files = []\n    }\n\n    for (let key of (await packedMap).keys()) {\n      // filter by prefix\n      if (key.startsWith(filepath)) {\n        // remove prefix\n        key = key.replace(filepath + '/', '')\n        // Don't include duplicates; the loose files have precedence anyway\n        if (!files.includes(key)) {\n          files.push(key)\n        }\n      }\n    }\n    // since we just appended things onto an array, we need to sort them now\n    files.sort(compareRefNames)\n\n    return files\n  }\n  static async resolve(fileSystem: EncryptedFS, gitdir: string, ref: string, depth?: number) {\n    if (depth !== undefined) {\n      depth--\n      if (depth === -1) {\n        return ref\n      }\n    }\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length)\n      return GitRefManager.resolve(fileSystem, gitdir, ref, depth)\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs(fileSystem, gitdir)\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)) // exclude git system files (#709)\n\n    for (const ref of allpaths) {\n      const sha = (fileSystem.readFileSync(`${gitdir}/${ref}`, { encoding: 'utf8' }).toString()) || packedMap.get(ref)\n      if (sha) {\n        return GitRefManager.resolve(fileSystem, gitdir, sha.trim(), depth)\n      }\n    }\n    // Do we give up?\n    throw(Error('RefNotFound'))\n  }\n\n}\n\nexport default GitRefManager\n","module.exports = require(\"pako\");","// The amount of work that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction simpleSign (n) {\n  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)\n}\n\nfunction negateExceptForZero (n) {\n  return n === 0 ? n : -n\n}\n\nfunction formatTimezoneOffset (minutes) {\n  let sign = simpleSign(negateExceptForZero(minutes))\n  minutes = Math.abs(minutes)\n  let hours = Math.floor(minutes / 60)\n  minutes -= hours * 60\n  let strHours = String(hours)\n  let strMinutes = String(minutes)\n  if (strHours.length < 2) strHours = '0' + strHours\n  if (strMinutes.length < 2) strMinutes = '0' + strMinutes\n  return (sign === -1 ? '-' : '+') + strHours + strMinutes\n}\n\nfunction parseTimezoneOffset (offset) {\n  let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/)\n  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes))\n  return negateExceptForZero(minutes)\n}\n\nfunction parseAuthor (author) {\n  let [, name, email, timestamp, offset] = author.match(\n    /^(.*) <(.*)> (.*) (.*)$/\n  )\n  return {\n    name: name,\n    email: email,\n    timestamp: Number(timestamp),\n    timezoneOffset: parseTimezoneOffset(offset)\n  }\n}\n\nfunction normalize (str) {\n  // remove all <CR>\n  str = str.replace(/\\r/g, '')\n  // no extra newlines up front\n  str = str.replace(/^\\n+/, '')\n  // and a single newline at the end\n  str = str.replace(/\\n+$/, '') + '\\n'\n  return str\n}\n\nfunction indent (str) {\n  return (\n    str\n      .trim()\n      .split('\\n')\n      .map(x => ' ' + x)\n      .join('\\n') + '\\n'\n  )\n}\n\nfunction outdent (str) {\n  return str\n    .split('\\n')\n    .map(x => x.replace(/^ /, ''))\n    .join('\\n')\n}\n\n// TODO: Make all functions have static async signature?\n\nclass GitCommit {\n  _commit: string\n  constructor (commit) {\n    if (typeof commit === 'string') {\n      this._commit = commit\n    } else if (Buffer.isBuffer(commit)) {\n      this._commit = commit.toString('utf8')\n    } else if (typeof commit === 'object') {\n      this._commit = GitCommit.render(commit)\n    } else {\n      throw(new Error('invalid type passed to GitCommit constructor'))\n    }\n  }\n\n  static fromPayloadSignature ({ payload, signature }) {\n    let headers = GitCommit.justHeaders(payload)\n    let message = GitCommit.justMessage(payload)\n    let commit = normalize(\n      headers + '\\ngpgsig' + indent(signature) + '\\n' + message\n    )\n    return new GitCommit(commit)\n  }\n\n  static from (commit) {\n    return new GitCommit(commit)\n  }\n\n  toObject () {\n    return Buffer.from(this._commit, 'utf8')\n  }\n\n  // Todo: allow setting the headers and message\n  headers () {\n    return this.parseHeaders()\n  }\n\n  // Todo: allow setting the headers and message\n  message () {\n    return GitCommit.justMessage(this._commit)\n  }\n\n  parse () {\n    return Object.assign({ message: this.message() }, this.headers())\n  }\n\n  static justMessage (commit) {\n    return normalize(commit.slice(commit.indexOf('\\n\\n') + 2))\n  }\n\n  static justHeaders (commit) {\n    return commit.slice(0, commit.indexOf('\\n\\n'))\n  }\n\n  parseHeaders () {\n    let headers = GitCommit.justHeaders(this._commit).split('\\n')\n    let hs: string[] = []\n    for (let h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1)\n      } else {\n        hs.push(h)\n      }\n    }\n    let obj: any = {\n      parent: []\n    }\n    for (let h of hs) {\n      let key = h.slice(0, h.indexOf(' '))\n      let value = h.slice(h.indexOf(' ') + 1)\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value)\n      } else {\n        obj[key] = value\n      }\n    }\n    if (obj.author) {\n      obj.author = parseAuthor(obj.author)\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer)\n    }\n    return obj\n  }\n\n  static renderHeaders (obj) {\n    let headers = ''\n    if (obj.tree) {\n      headers += `tree ${obj.tree}\\n`\n    } else {\n      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n` // the null tree\n    }\n    if (obj.parent) {\n      if (obj.parent.length === undefined) {\n        throw(new Error(`commit 'parent' property should be an array`))\n      }\n      for (let p of obj.parent) {\n        headers += `parent ${p}\\n`\n      }\n    }\n    let author = obj.author\n    headers += `author ${author.name} <${author.email}> ${\n      author.timestamp\n    } ${formatTimezoneOffset(author.timezoneOffset)}\\n`\n    let committer = obj.committer || obj.author\n    headers += `committer ${committer.name} <${committer.email}> ${\n      committer.timestamp\n    } ${formatTimezoneOffset(committer.timezoneOffset)}\\n`\n    if (obj.gpgsig) {\n      headers += 'gpgsig' + indent(obj.gpgsig)\n    }\n    return headers\n  }\n\n  static render (obj) {\n    return GitCommit.renderHeaders(obj) + '\\n' + normalize(obj.message)\n  }\n\n  render () {\n    return this._commit\n  }\n\n  withoutSignature () {\n    let commit = normalize(this._commit)\n    if (commit.indexOf('\\ngpgsig') === -1) return commit\n    let headers = commit.slice(0, commit.indexOf('\\ngpgsig'))\n    let message = commit.slice(\n      commit.indexOf('-----END PGP SIGNATURE-----\\n') +\n        '-----END PGP SIGNATURE-----\\n'.length\n    )\n    return normalize(headers + '\\n' + message)\n  }\n\n  isolateSignature () {\n    let signature = this._commit.slice(\n      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._commit.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    )\n    return outdent(signature)\n  }\n}\n\nexport default GitCommit\n","import fs from 'fs'\nimport pako from 'pako'\nimport path from 'path'\nimport GitObject from './GitObject'\nimport { EncryptedFS } from 'encryptedfs'\n\nconst PackfileCache = new Map()\n\nclass GitObjectManager {\n  static async read(fileSystem: EncryptedFS, gitdir: string, oid: string, format = 'content') {\n    // Look for it in the loose object directory.\n    let file = fileSystem.readFileSync(`${gitdir}/objects/${oid.slice(0, 2)}/${oid.slice(2)}`)\n    let source = `./objects/${oid.slice(0, 2)}/${oid.slice(2)}`\n    // Check to see if it's in a packfile.\n    if (!file) {\n      // Curry the current read method so that the packfile un-deltification\n      // process can acquire external ref-deltas.\n      const getExternalRefDelta = oid =>\n        GitObjectManager.read(fileSystem, gitdir, oid)\n      // Iterate through all the .pack files\n      let list = fs.readdirSync(path.join(gitdir, '/objects/pack'))\n      list = list.filter(x => x.endsWith('.pack'))\n      for (let filename of list) {\n        // Try to get the packfile from the in-memory cache\n        let p = PackfileCache.get(filename)\n        // If the packfile DOES have the oid we're looking for...\n        if (p.offsets.has(oid)) {\n          // Make sure the packfile is loaded in memory\n          if (!p.pack) {\n            const pack = fileSystem.readFileSync(`${gitdir}/objects/pack/${filename}`)\n            await p.load({ pack })\n          }\n          // Get the resolved git object from the packfile\n          let result = await p.read({ oid, getExternalRefDelta })\n          result.source = `./objects/pack/${filename}`\n          return result\n        }\n      }\n    }\n    // Check to see if it's in shallow commits.\n    if (!file) {\n      let text = fileSystem.readFileSync(`${gitdir}/shallow`, { encoding: 'utf8' })\n      if (text !== null && text.includes(oid)) {\n        throw(new Error(`ReadShallowObjectFail: ${oid}`))\n      }\n    }\n    // Finally\n    if (!file) {\n      throw(new Error(`ReadObjectFail: ${oid}`))\n    }\n    if (format === 'deflated') {\n      return { format: 'deflated', object: file, source }\n    }\n    let buffer = Buffer.from(pako.inflate(file))\n    if (format === 'wrapped') {\n      return { format: 'wrapped', object: buffer, source }\n    }\n    let { type, object } = GitObject.unwrap({ oid, buffer })\n    if (format === 'content') return { type, format: 'content', object, source }\n  }\n}\n\nexport default GitObjectManager\n","import Path from 'path'\nimport protobuf, { Root } from 'protobufjs'\nimport PeerInfo from '../peers/PeerInfo'\n\ntype HandshakeMessage = {\n  targetPubKey: Buffer\n  requestingPubKey: Buffer\n  message: Buffer\n  responsePeerInfo?: PeerInfo\n}\n\nclass RPCMessage {\n  /**\n   * Encode peer info into a protocol buffer\n   * @param peerInfo The peerInfo to be encoded\n   */\n  static encodePeerInfo(peerInfo: PeerInfo): Uint8Array {\n    const root = this.loadProto(\"PeerInfoMessage.proto\")\n\n    // Obtain a message type\n    const PeerInfoMessage = root!.lookupType(\"peerinfopackage.PeerInfoMessage\");\n\n    // Encode address set to array\n    const addresses: string[] = []\n    for (const addr of peerInfo.addresses) {\n      addresses.push(addr.toString())\n    }\n\n    // Exemplary payload\n    const payload = {\n      pubKey: peerInfo.publicKey,\n      addresses: addresses,\n      connectedAddr: peerInfo.connectedAddr?.toString()\n    };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    const errMsg = PeerInfoMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    const message = PeerInfoMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    const buffer = PeerInfoMessage.encode(message).finish();\n\n    return buffer\n  }\n  /**\n   * Deccode a protocol buffer into peer info\n   * @param buffer\n   */\n  static decodePeerInfo(buffer: Uint8Array): PeerInfo {\n    const root = this.loadProto(\"PeerInfoMessage.proto\")\n\n    // Obtain a message type\n    const PeerInfoMessage = root!.lookupType(\"peerinfopackage.PeerInfoMessage\");\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    const message = PeerInfoMessage.decode(buffer);\n\n    // Convert the message back to a plain object\n    const object = PeerInfoMessage.toObject(message, {\n      enums: String,  // enums as string names\n      longs: String,  // longs as strings (requires long.js)\n      bytes: String,  // bytes as base64 encoded strings\n      defaults: true, // includes default values\n      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n      objects: true,  // populates empty objects (map fields) even if defaults=false\n      oneofs: true    // includes virtual oneof fields set to the present field's name\n    });\n\n    return new PeerInfo(\n      object.pubKey,\n      object.addresses,\n      object.connectedAddr\n    )\n  }\n\n  /**\n   * Encode a handshake message into a protocol buffer\n   * @param targetPubKey\n   * @param requestingPubKey\n   * @param message\n   * @param responsePeerInfo\n   */\n  static encodeHandshakeMessage(targetPubKey: Buffer, requestingPubKey: Buffer, message: Buffer, responsePeerInfo?: PeerInfo): Uint8Array {\n    const root = this.loadProto(\"HandshakeMessage.proto\")\n\n    // Obtain a message type\n    const HandshakeMessage = root!.lookupType(\"handshakepackage.HandshakeMessage\");\n\n    // Exemplary payload\n    const payload = {\n      targetPubKey: targetPubKey,\n      requestingPubKey: requestingPubKey,\n      message: message,\n      responsePeerInfo: (responsePeerInfo) ? this.encodePeerInfo(responsePeerInfo) : undefined\n    };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    const errMsg = HandshakeMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    const encodedMmessage = HandshakeMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    const buffer = HandshakeMessage.encode(encodedMmessage).finish();\n\n    return buffer\n  }\n  /**\n   * Deccode a protocol buffer into a handshake message\n   * @param buffer\n   */\n  static decodeHandshakeMessage(buffer: Uint8Array): HandshakeMessage {\n    const root = this.loadProto(\"HandshakeMessage.proto\")\n\n    // Obtain a message type\n    const HandshakeMessage = root!.lookupType(\"handshakepackage.HandshakeMessage\");\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    const message = HandshakeMessage.decode(buffer);\n\n    // Convert the message back to a plain object\n    const object = HandshakeMessage.toObject(message, {\n      enums: String,  // enums as string names\n      longs: String,  // longs as strings (requires long.js)\n      bytes: String,  // bytes as base64 encoded strings\n      defaults: true, // includes default values\n      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n      objects: true,  // populates empty objects (map fields) even if defaults=false\n      oneofs: true    // includes virtual oneof fields set to the present field's name\n    });\n\n    return {\n      targetPubKey: Buffer.from(object.targetPubKey, 'base64'),\n      requestingPubKey: Buffer.from(object.requestingPubKey, 'base64'),\n      message: Buffer.from(object.message, 'base64'),\n      responsePeerInfo: (object.responsePeerInfo) ? this.decodePeerInfo(Buffer.from(object.responsePeerInfo, 'base64')) : undefined\n    }\n  }\n\n  // ==== Helper methods ==== //\n  private static loadProto(name: string): Root {\n    // Load root\n    const root: Root = new protobuf.Root()\n    root.resolvePath = (origin, target) => {\n      return Path.join(Path.dirname(__filename), target)\n    }\n\n    return root.loadSync(name)\n  }\n}\n\nexport default RPCMessage\n","import { AddressInfo } from 'net'\n\nclass Address {\n  ip: string\n  port: string\n  constructor(\n    ip: string,\n    port: string\n  ) {\n    this.ip = ip\n    this.port = port\n  }\n\n  /**\n   * Create an address object from a address string\n   * @param addressString Address string in the format of `${this.ip}:${this.port}`\n   */\n  static parse(addressString: string): Address {\n    const components = addressString.split(':')\n    const ip = components[0]\n    const port = components[1]\n\n    return new Address(ip, port)\n  }\n\n  /**\n   * Create an address object from a net.AddressInfo\n   * @param addressInfo AddressInfo of desired address\n   */\n  static fromAddressInfo(addressInfo: AddressInfo) {\n    const ip = (addressInfo.address == '::') ? 'localhost' : addressInfo.address\n    return new Address(ip, addressInfo.port.toString())\n  }\n\n  /**\n   * Convert address into string of format `${this.ip}:${this.port}`\n   */\n  toString() {\n    return `${this.ip}:${this.port}`\n  }\n}\n\nAddress.prototype.toString = function() {\n  return `${this.ip}:${this.port}`\n}\n\nclass PeerInfo {\n  publicKey: string\n  addresses: Set<Address>\n  connectedAddr?: Address\n  constructor(\n    pubKey: string,\n    addresses: string[] = [],\n    connectedAddr?: string\n  ) {\n    this.publicKey = pubKey\n    this.addresses = new Set(addresses.map((addr) => {\n      return Address.parse(addr)\n    }))\n    this.connectedAddr = (connectedAddr) ? Address.parse(connectedAddr) : undefined\n  }\n\n  /**\n   * Sets the main server address for the peer\n   * @param address Main server address for peer\n   */\n  connect(address: Address) {\n    if (!this.addresses.has(address)) {\n      this.addresses.add(address)\n    }\n\n    this.connectedAddr = address\n  }\n\n  /**\n   * Clears the main server address for the peer\n   */\n  disconnect() {\n    this.connectedAddr = undefined\n  }\n}\n\nexport default PeerInfo\nexport { Address }\n","\nimport fs from 'fs';\nimport os from 'os';\nimport Path from 'path';\nimport git from 'isomorphic-git';\nimport Vault from '../vaults/Vault';\nimport GitClient from '../git/GitClient';\nimport { EncryptedFS } from 'encryptedfs';\nimport KeyManager from '../keys/KeyManager';\n\nclass VaultManager {\n  polykeyPath: string\n  fileSystem: typeof fs\n  keyManager: KeyManager\n\n  metadataPath: string\n  vaults: Map<string, Vault>\n  vaultKeys: Map<string, Buffer>\n  constructor(\n    polykeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    keyManager: KeyManager\n  ) {\n    this.polykeyPath = polykeyPath\n    this.fileSystem = fileSystem\n    this.keyManager = keyManager\n    this.metadataPath = Path.join(polykeyPath, '.vaultKeys')\n\n    // Make polykeyPath if it doesn't exist\n    this.fileSystem.mkdirSync(this.polykeyPath, { recursive: true })\n\n    // Initialize stateful variables\n    this.vaults = new Map()\n    this.vaultKeys = new Map()\n\n    // Read in vault keys\n    this.loadMetadata()\n\n    // Initialize vaults in memory\n    for (const [vaultName, vaultKey] of this.vaultKeys.entries()) {\n      const path = Path.join(this.polykeyPath, vaultName)\n      if (this.fileSystem.existsSync(path)) {\n        const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n        this.vaults.set(vaultName, vault)\n      }\n    }\n  }\n\n  /**\n   * Get a vault from the vault manager\n   * @param vaultName Name of desired vault\n   */\n  getVault(vaultName: string): Vault {\n    if (this.vaults.has(vaultName)) {\n      const vault = this.vaults.get(vaultName)\n      return vault!\n    } else if (this.vaultKeys.has(vaultName)) {\n      // vault not in map, create new instance\n      this.validateVault(vaultName)\n\n      const vaultKey = this.vaultKeys.get(vaultName)\n\n      const vault = new Vault(vaultName, vaultKey!, this.polykeyPath)\n      this.vaults.set(vaultName, vault)\n      return vault\n    } else {\n      throw new Error('Vault does not exist in memory')\n    }\n  }\n\n  /**\n   * Get a vault from the vault manager\n   * @param vaultName Unique name of new vault\n   * @param key Optional key to use for the vault encryption, otherwise it is generated\n   */\n  async createVault(vaultName: string, key?: Buffer): Promise<Vault> {\n\n    if (this.vaultExists(vaultName)) {\n      throw Error('Vault already exists!')\n    }\n\n    try {\n      const path = Path.join(this.polykeyPath, vaultName)\n      // Directory not present, create one\n      this.fileSystem.mkdirSync(path, { recursive: true })\n      // Create key if not provided\n      let vaultKey: Buffer\n      if (!key) {\n        // Generate new key\n        vaultKey = await this.keyManager.generateKey(`${vaultName}-Key`, this.keyManager.getPrivateKey())\n      } else {\n        // Assign key if it is provided\n        vaultKey = key\n      }\n      this.vaultKeys.set(vaultName, vaultKey)\n      this.writeMetadata()\n      const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n      await vault.initRepository()\n      this.vaults.set(vaultName, vault)\n      return this.getVault(vaultName)\n    } catch (err) {\n      // Delete vault dir and garbage collect\n      this.destroyVault(vaultName)\n      throw err\n    }\n  }\n\n  /**\n   * Get a vault from the vault manager\n   * @param vaultName Name of vault to be cloned\n   * @param address Address of polykey node that owns vault to be cloned\n   * @param getSocket Function to get an active connection to provided address\n   */\n  async cloneVault(vaultName: string, gitClient: GitClient): Promise<Vault> {\n    // Confirm it doesn't exist locally already\n    if (this.vaultExists(vaultName)) {\n      throw new Error('Vault name already exists locally, try pulling instead')\n    }\n\n    const vaultUrl = `http://0.0.0.0/${vaultName}`\n\n    // First check if it exists on remote\n    const info = await git.getRemoteInfo({\n      http: gitClient,\n      url: vaultUrl\n    })\n\n    if (!info.refs) {\n      throw new Error(`Peer does not have vault: '${vaultName}'`)\n    }\n\n    // Create new efs first\n    // Generate new key\n    const vaultKey = await this.keyManager.generateKey(`${vaultName}-Key`, this.keyManager.getPrivateKey())\n\n    // Set filesystem\n    const vfsInstance = new (require('virtualfs')).VirtualFS\n\n    const newEfs = new EncryptedFS(\n      vaultKey,\n      vfsInstance,\n      vfsInstance,\n      this.fileSystem,\n      process\n    )\n\n    // Clone vault from address\n    await git.clone({\n      fs: { promises: newEfs.promises },\n      http: gitClient,\n      dir: Path.join(this.polykeyPath, vaultName),\n      url: vaultUrl,\n      ref: 'master',\n      singleBranch: true\n    })\n\n    // Finally return the vault\n    const vault = new Vault(vaultName, vaultKey, this.polykeyPath)\n    this.vaults.set(vaultName, vault)\n    return vault\n  }\n\n  /**\n   * Determines whether the vault exists\n   * @param vaultName Name of desired vault\n   */\n  vaultExists(vaultName: string): boolean {\n    const path = Path.join(this.polykeyPath, vaultName)\n    const vaultExists = this.fileSystem.existsSync(path)\n\n    return vaultExists\n  }\n\n  /**\n   * [WARNING] Destroys a certain vault and all its secrets\n   * @param vaultName Name of vault to be destroyed\n   */\n  destroyVault(vaultName: string) {\n\n    // this is convenience function for removing all tags\n    // and triggering garbage collection\n    // destruction is a better word as we should ensure all traces is removed\n\n    const path = Path.join(this.polykeyPath, vaultName)\n    // Remove directory on file system\n    if (this.fileSystem.existsSync(path)) {\n      this.fileSystem.rmdirSync(path, { recursive: true })\n    }\n\n    // Remove from maps\n    this.vaults.delete(vaultName)\n    this.vaultKeys.delete(vaultName)\n\n    // Write to metadata file\n    this.writeMetadata()\n\n    const vaultPathExists = this.fileSystem.existsSync(path)\n    if (vaultPathExists) {\n      throw new Error('Vault folder could not be destroyed!')\n    }\n  }\n\n  /**\n   * List the names of all vaults in memory\n   */\n  listVaults(): string[] {\n    return Array.from(this.vaults.keys())\n  }\n\n  /* ============ HELPERS =============== */\n  private validateVault(vaultName: string): void {\n    if (!this.vaults.has(vaultName)) {\n      throw Error('Vault does not exist in memory')\n    }\n    if (!this.vaultKeys.has(vaultName)) {\n      throw Error('Vault key does not exist in memory')\n    }\n    const vaultPath = Path.join(this.polykeyPath, vaultName)\n    if (!this.fileSystem.existsSync(vaultPath)) {\n      throw Error('Vault directory does not exist')\n    }\n  }\n  private async writeMetadata(): Promise<void> {\n    const metadata = JSON.stringify([...this.vaultKeys])\n    const encryptedMetadata = await this.keyManager.encryptData(Buffer.from(metadata))\n    await this.fileSystem.promises.writeFile(this.metadataPath, encryptedMetadata)\n  }\n  private async loadMetadata(): Promise<void> {\n    // Check if file exists\n    if (this.fileSystem.existsSync(this.metadataPath)) {\n      const encryptedMetadata = this.fileSystem.readFileSync(this.metadataPath)\n      const metadata = (await this.keyManager.decryptData(encryptedMetadata)).toString()\n\n      for (const [key, value] of new Map<string, any>(JSON.parse(metadata))) {\n        this.vaultKeys[key] = Buffer.from(value)\n      }\n    }\n  }\n}\n\nexport default VaultManager\n","module.exports = require(\"isomorphic-git\");","module.exports = require(\"encryptedfs\");","module.exports = require(\"virtualfs\");","export { default } from './Polykey'\nexport { default as KeyManager } from './keys/KeyManager'\nexport { default as PeerManager } from './peers/PeerManager'\nexport { default as VaultManager } from './vaults/VaultManager'\n","import os from 'os';\nimport fs from 'fs';\nimport KeyManager from './keys/KeyManager';\nimport PeerManager from './peers/PeerManager';\nimport VaultManager from './vaults/VaultManager';\n\nclass Polykey {\n  polykeyPath: string\n\n  vaultManager: VaultManager\n  keyManager: KeyManager\n  peerManager: PeerManager\n\n  constructor(\n    polykeyPath: string = `${os.homedir()}/.polykey`,\n    fileSystem: typeof fs,\n    keyManager?: KeyManager,\n    vaultManager?: VaultManager,\n    peerManager?: PeerManager,\n    port?: number\n  ) {\n    this.polykeyPath = polykeyPath\n\n    // Set key manager\n    this.keyManager = keyManager ?? new KeyManager(this.polykeyPath, fileSystem)\n\n    // Set or Initialize vaultManager\n    this.vaultManager = vaultManager ?? new VaultManager(this.polykeyPath, fileSystem, this.keyManager)\n\n    // Initialize peer store and peer discovery classes\n    this.peerManager = peerManager ?? new PeerManager(\n      this.polykeyPath,\n      fileSystem,\n      this.keyManager,\n      this.vaultManager,\n      undefined,\n      undefined,\n      port\n    )\n  }\n}\n\nexport default Polykey\n","module.exports = require(\"kbpgp\");","module.exports = require(\"util\");","import fs from 'fs';\nimport path from 'path';\nimport grpc from 'grpc';\nimport { Address } from '../peers/PeerInfo';\nimport KeyManager from '../keys/KeyManager';\n\n/**\n * Responsible for converting HTTP messages from isomorphic-git into requests and sending them to a specific peer.\n */\nclass GitClient {\n  private client: any\n  private credentials: grpc.ChannelCredentials\n\n  constructor(\n    address: Address,\n    keyManager: KeyManager\n  ) {\n    const PROTO_PATH = __dirname + '/../../proto/git_server.proto';\n\n    const protoLoader = require('@grpc/proto-loader');\n    const packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n      keepCase: true,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true\n    });\n    const git_server_proto = grpc.loadPackageDefinition(packageDefinition);\n\n    const pkiInfo = keyManager.PKIInfo\n    if (pkiInfo.caCert && pkiInfo.cert && pkiInfo.key) {\n      this.credentials = grpc.credentials.createSsl(\n        pkiInfo.caCert,\n        pkiInfo.key,\n        pkiInfo.cert,\n        // { checkServerIdentity: this.checkServerIdentity }\n      )\n    } else {\n      this.credentials = grpc.credentials.createInsecure()\n    }\n\n    this.client = new (git_server_proto.GitServer as any)(address.toString(), this.credentials);\n  }\n\n  // checkServerIdentity(hostname: string, cert: grpc.Certificate): Error | undefined {\n  //   console.log(hostname);\n  //   console.log(cert);\n\n  //   return\n  // }\n\n  /**\n   * The custom http request method to feed into isomorphic-git's [custom http object](https://isomorphic-git.org/docs/en/http)\n   */\n  async request({\n    url,\n    method,\n    headers,\n    body,\n    onProgress\n  }) {\n    return new Promise<any>(async (resolve, reject) => {\n      const u = new URL(url)\n\n      // Parse request\n      if (method == 'GET') {\n        // Info request\n        const match = u.pathname.match(/\\/(.+)\\/info\\/refs$/)\n        if (!match || /\\.\\./.test(match[1])) {\n          reject(new Error('Error'))\n        }\n\n        const vaultName = match![1]\n\n        const infoResponse = await this.requestInfo(vaultName)\n\n        resolve({\n          url: url,\n          method: method,\n          statusCode: 200,\n          statusMessage: 'OK',\n          body: this.iteratorFromData(infoResponse),\n          headers: headers\n        })\n      } else if (method == 'POST') {\n        // Info request\n        const match = u.pathname.match(/\\/(.+)\\/git-(.+)/)\n        if (!match || /\\.\\./.test(match[1])) {\n          reject(new Error('Error'))\n        }\n\n        const vaultName = match![1]\n\n        const packResponse = await this.requestPack(vaultName, body[0])\n\n        resolve({\n          url: url,\n          method: method,\n          statusCode: 200,\n          statusMessage: 'OK',\n          body: this.iteratorFromData(packResponse),\n          headers: headers\n        })\n      } else {\n        reject(new Error('Method not supported'))\n      }\n    })\n  }\n\n  // ==== HELPER METHODS ==== //\n  /**\n   * Requests remote info from the connected peer for the named vault.\n   * @param vaultName Name of the desired vault\n   */\n  private async requestInfo(vaultName: string): Promise<Buffer> {\n    return new Promise<Buffer>((resolve, reject) => {\n      this.client.requestInfo({ vaultName: vaultName }, function (err, response) {\n        if (err) {\n          console.log('err');\n          console.log(err);\n\n          reject(err)\n        } else {\n          resolve(response.body);\n        }\n      });\n    })\n  }\n\n  /**\n   * Requests a pack from the connected peer for the named vault.\n   * @param vaultName Name of the desired vault\n   */\n  private async requestPack(vaultName: string, body: Buffer): Promise<Buffer> {\n    return new Promise<Buffer>((resolve, reject) => {\n      this.client.requestPack({ vaultName: vaultName, body: body }, function (err, response) {\n        if (err) {\n          console.log('err');\n          console.log(err);\n\n          reject(err)\n        } else {\n          resolve(response.body);\n        }\n      });\n    })\n  }\n\n  /**\n   * Converts a buffer into an iterator expected by isomorphic git.\n   * @param data Data to be turned into an iterator\n   */\n  private iteratorFromData(data: Buffer) {\n    let ended = false\n    return {\n      next(): Promise<any> {\n        return new Promise((resolve, reject) => {\n          if (ended) {\n            return resolve({ done: true })\n          } else {\n            ended = true\n            resolve({ value: data, done: false })\n          }\n        })\n      },\n    }\n  }\n}\n\nexport default GitClient\n","import Path from 'path';\nimport { PassThrough } from 'readable-stream';\nimport VaultManager from '../vaults/VaultManager';\nimport uploadPack from './upload-pack/uploadPack';\nimport GitSideBand from './side-band/GitSideBand';\nimport packObjects from './pack-objects/packObjects';\n\n// Here is the protocol git outlines for sending pack files over http:\n// https://git-scm.com/docs/pack-protocol/2.17.0\n// https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt\n// This should be consulted in developing our upload pack implementation\n\n// This git backend (as well as HttpDuplex class) is heavily inspired by node-git-server:\n// https://github.com/gabrielcsapo/node-git-server\n\n// We need someway to notify other agents about what vaults we have based on some type of authorisation because they don't explicitly know about them\n\nclass GitBackend {\n  private polykeyPath: string;\n  private vaultManager: VaultManager;\n  constructor(\n    polykeyPath: string,\n    vaultManager: VaultManager\n  ) {\n    this.polykeyPath = polykeyPath\n    this.vaultManager = vaultManager\n  }\n\n  /**\n   * Find out whether vault exists.\n   * @param vaultName Name of vault to check\n   * @param publicKey Public key of peer trying to access vault\n   */\n  private exists(vaultName: string, publicKey: string) {\n    const vault = this.vaultManager.getVault(vaultName)\n    if (vault) {\n      return vault.peerCanAccess(publicKey)\n    }\n    return false\n  }\n\n  async handleInfoRequest(vaultName: string): Promise<Buffer> {\n    // Only handle upload-pack for now\n    const service = 'upload-pack'\n\n    const connectingPublicKey = ''\n\n    const responseBuffers: Buffer[] = []\n\n    if (!this.exists(vaultName, connectingPublicKey)) {\n      throw new Error('Vault does not exist')\n    } else {\n      responseBuffers.push(Buffer.from(this.createGitPacketLine('# service=git-' + service + '\\n')))\n      responseBuffers.push(Buffer.from('0000'))\n\n      const fileSystem = this.vaultManager.getVault(vaultName)?.EncryptedFS\n\n      const buffers = await uploadPack(\n        fileSystem,\n        Path.join(this.polykeyPath, vaultName),\n        undefined,\n        true\n      )\n      const buffersToWrite = buffers ?? []\n      responseBuffers.push(...buffersToWrite)\n    }\n\n    return Buffer.concat(responseBuffers)\n  }\n  async handlePackRequest(vaultName: string, body: Buffer): Promise<Buffer> {\n    return new Promise<Buffer>(async (resolve, reject) => {\n      const responseBuffers: Buffer[] = []\n\n      // Check if vault exists\n      const connectingPublicKey = ''\n      if (!this.exists(vaultName, connectingPublicKey)) {\n        throw new Error('Vault does not exist')\n      }\n\n      const fileSystem = this.vaultManager.getVault(vaultName)?.EncryptedFS\n\n      if (fileSystem) {\n        if (body.toString().slice(4, 8) == 'want') {\n          const wantedObjectId = body.toString().slice(9, 49)\n          const packResult = await packObjects(\n            fileSystem,\n            Path.join(this.polykeyPath, vaultName),\n            [wantedObjectId],\n            undefined\n          )\n\n          // This the 'wait for more data' line as I understand it\n          responseBuffers.push(Buffer.from('0008NAK\\n'))\n\n          // This is to get the side band stuff working\n          const readable = new PassThrough()\n          const progressStream = new PassThrough()\n          const sideBand = GitSideBand.mux(\n            'side-band-64',\n            readable,\n            packResult.packstream,\n            progressStream,\n            []\n          )\n          sideBand.on('data', (data: Buffer) => {\n            responseBuffers.push(data)\n          })\n          sideBand.on('end', () => {\n            resolve(Buffer.concat(responseBuffers))\n          })\n          sideBand.on('error', (err) => {\n            reject(err)\n          })\n\n\n          // Write progress to the client\n          progressStream.write(Buffer.from('0014progress is at 50%\\n'))\n          progressStream.end()\n        }\n      }\n    })\n  }\n\n  // ============ Helper functions ============ //\n  private createGitPacketLine(line: string) {\n    const hexPrefix = (4 + line.length).toString(16)\n    return Array(4 - hexPrefix.length + 1).join('0') + hexPrefix + line\n  }\n}\n\nexport default GitBackend\n","import path from 'path'\nimport GitPktLine from './GitPktLine'\nimport { EncryptedFS } from 'encryptedfs'\nimport GitRefManager from './GitRefManager'\n\nasync function writeRefsAdResponse({ capabilities, refs, symrefs }) {\n  const stream: Buffer[] = []\n  // Compose capabilities string\n  let syms = ''\n  for (const [key, value] of Object.entries(symrefs)) {\n    syms += `symref=${key}:${value} `\n  }\n  let caps = `\\x00${[...capabilities].join(' ')} ${syms}agent=git/isomorphic-git@1.4.0`\n  // stream.write(GitPktLine.encode(`# service=${service}\\n`))\n  // stream.write(GitPktLine.flush())\n  // Note: In the edge case of a brand new repo, zero refs (and zero capabilities)\n  // are returned.\n  for (const [key, value] of Object.entries(refs)) {\n    stream.push(GitPktLine.encode(`${value} ${key}${caps}\\n`))\n    caps = ''\n  }\n  stream.push(GitPktLine.flush())\n  return stream\n}\n\nasync function uploadPack(\n  fileSystem: EncryptedFS,\n  dir: string,\n  gitdir: string = path.join(dir, '.git'),\n  advertiseRefs: boolean = false,\n) {\n  try {\n    if (advertiseRefs) {\n      // Send a refs advertisement\n      const capabilities = [\n        'side-band-64k',\n      ]\n      let keys = await GitRefManager.listRefs(\n        fileSystem,\n        gitdir,\n        'refs'\n      )\n      keys = keys.map(ref => `refs/${ref}`)\n      const refs = {}\n      keys.unshift('HEAD') // HEAD must be the first in the list\n      for (const key of keys) {\n        refs[key] = await GitRefManager.resolve(fileSystem, gitdir, key)\n      }\n\n      const symrefs = {}\n\n      symrefs['HEAD'] = await GitRefManager.resolve(\n        fileSystem,\n        gitdir,\n        'HEAD',\n        2,\n      )\n\n      return writeRefsAdResponse({\n        capabilities,\n        refs,\n        symrefs,\n      })\n    }\n  } catch (err) {\n    err.caller = 'git.uploadPack'\n    throw err\n  }\n}\n\nexport default uploadPack\n","type Config = {\n  line: string\n  ref?: string\n  peeled?: string\n  oid?: string\n  comment?: boolean\n}\n\nclass GitPackedRefs {\n  refs: Map<string, string>\n  parsedConfig: Config[]\n  constructor(text: string) {\n    this.refs = new Map()\n    this.parsedConfig = []\n    if (text) {\n      let key: string\n      this.parsedConfig = text\n        .trim()\n        .split('\\n')\n        .map(line => {\n          if (/^\\s*#/.test(line)) {\n            return { line: line, comment: true }\n          }\n          const i = line.indexOf(' ')\n          if (line.startsWith('^')) {\n            // This is a oid for the commit associated with the annotated tag immediately preceding this line.\n            // Trim off the '^'\n            const value = line.slice(1)\n            // The tagname^{} syntax is based on the output of `git show-ref --tags -d`\n            this.refs.set(key + '^{}', value)\n            return { line: line, ref: key, peeled: value }\n          } else {\n            // This is an oid followed by the ref name\n            const value = line.slice(0, i)\n            key = line.slice(i + 1)\n            this.refs.set(key, value)\n            return { line: line, ref: key, oid: value }\n          }\n        })\n    }\n    return this\n  }\n\n  static from(text) {\n    return new GitPackedRefs(text)\n  }\n}\n\nexport default GitPackedRefs\n","/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\nimport { Buffer } from 'buffer'\nimport { PassThrough } from 'readable-stream'\n\nimport GitPktLine from '../upload-pack/GitPktLine'\n\nfunction splitBuffer(buffer: Buffer, maxBytes: number) {\n  const result: Buffer[] = [];\n  let index = 0\n  while (index < buffer.length) {\n    const buf = buffer.slice(index, index+maxBytes)\n    result.push(buf)\n    index += buf.length\n  }\n  result.push(buffer.slice(index))\n  return result;\n}\n\nclass GitSideBand {\n  static demux (input) {\n    let read = GitPktLine.streamReader(input)\n    // And now for the ridiculous side-band or side-band-64k protocol\n    let packetlines = new PassThrough()\n    let packfile = new PassThrough()\n    let progress = new PassThrough()\n    // TODO: Use a proper through stream?\n    const nextBit = async function () {\n      let line = await read()\n      // Skip over flush packets\n      if (line === null) return nextBit()\n      // A made up convention to signal there's no more to read.\n      if (line === true) {\n        packetlines.end()\n        progress.end()\n        packfile.end()\n        return\n      }\n      // Examine first byte to determine which output \"stream\" to use\n      switch (line[0]) {\n        case 1: // pack data\n          packfile.write(line.slice(1))\n          break\n        case 2: // progress message\n          progress.write(line.slice(1))\n          break\n        case 3: // fatal error message just before stream aborts\n          let error = line.slice(1)\n          progress.write(error)\n          packfile.destroy(new Error(error.toString('utf8')))\n          return\n        default:\n          // Not part of the side-band-64k protocol\n          packetlines.write(line.slice(0))\n      }\n      // Careful not to blow up the stack.\n      // I think Promises in a tail-call position should be OK.\n      nextBit()\n    }\n    nextBit()\n    return {\n      packetlines,\n      packfile,\n      progress\n    }\n  }\n  static mux (\n    protocol, // 'side-band' or 'side-band-64k'\n    packetlines,\n    packfile,\n    progress,\n    error\n  ) {\n    const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519\n    let output = new PassThrough()\n    packetlines.on('data', data => {\n      if (data === null) {\n        output.write(GitPktLine.flush())\n      } else {\n        output.write(GitPktLine.encode(data))\n      }\n    })\n    let packfileWasEmpty = true\n    let packfileEnded = false\n    let progressEnded = false\n    let errorEnded = true\n    let goodbye = Buffer.concat([\n      GitPktLine.encode(Buffer.from('010A', 'hex')),\n      GitPktLine.flush()\n    ])\n    packfile\n      .on('data', data => {\n        packfileWasEmpty = false\n        const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n        for (const buffer of buffers) {\n          output.write(\n            GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))\n          )\n        }\n      })\n      .on('end', () => {\n        packfileEnded = true\n        if (!packfileWasEmpty) output.write(goodbye)\n        if (progressEnded && errorEnded) output.end()\n      })\n    progress\n      .on('data', data => {\n        const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n        for (const buffer of buffers) {\n          output.write(\n            GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))\n          )\n        }\n      })\n      .on('end', () => {\n        progressEnded = true\n        if (packfileEnded && errorEnded) output.end()\n      })\n    // error\n    //   .on('data', data => {\n    //     const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n    //     for (const buffer of buffers) {\n    //       output.write(\n    //         GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n    //       )\n    //     }\n    //   })\n    //   .on('end', () => {\n    //     errorEnded = true\n    //     if (progressEnded && packfileEnded) output.end()\n    //   })\n    return output\n  }\n}\n\nexport default GitSideBand\n","module.exports = require(\"buffer\");","import pako from 'pako'\nimport path from 'path'\nimport log from './log'\nimport GitTree from './GitTree'\nimport createHash from 'sha.js'\nimport GitCommit from './GitCommit'\nimport { EncryptedFS } from 'encryptedfs'\nimport { PassThrough } from 'readable-stream'\nimport GitObjectManager from './GitObjectManager'\n\nconst types = {\n  commit: 0b0010000,\n  tree: 0b0100000,\n  blob: 0b0110000,\n  tag: 0b1000000,\n  ofs_delta: 0b1100000,\n  ref_delta: 0b1110000\n}\n\ntype Ack = {\n  oid: string\n}\n/**\n * Create a packfile stream\n *\n * @link https://isomorphic-git.github.io/docs/packObjects.html\n */\nasync function packObjects (\n  fileSystem: EncryptedFS,\n  dir: string,\n  refs: string[],\n  depth?: number,\n  haves?: string[],\n) {\n  const gitdir = path.join(dir, '.git')\n  let oids = new Set<string>()\n  let shallows = new Set<string>()\n  let unshallows = new Set()\n  let acks: Ack[] = []\n\n  haves = (haves) ? haves : []\n\n  const emitter = undefined\n  const since = undefined\n  for (const ref of refs) {\n    try {\n      let commits = await log(\n        fileSystem,\n        dir,\n        gitdir,\n        emitter,\n        ref,\n        depth,\n        since\n      )\n\n      let oldshallows: string[] = []\n\n      for (let i = 0; i < commits.length; i++) {\n        let commit = commits[i]\n        if (haves.includes(commit.oid)) {\n          acks.push({\n            oid: ref\n          })\n          break\n        }\n        oids.add(commit.oid)\n        if (i === commits.length - 1) {\n          if (\n            !oldshallows.includes(commit.oid) &&\n            (depth !== undefined || since !== undefined)\n          ) {\n            console.log('make it shallow', commit.oid)\n            shallows.add(commit.oid)\n          }\n        } else if (oldshallows.includes(commit.oid)) {\n          console.log('make it unshallow', commit.oid)\n          unshallows.add(commit.oid)\n        }\n      }\n    } catch (err) {\n      console.log(err);\n      // oh well.\n    }\n  }\n  let objects = await listObjects(fileSystem, dir, gitdir, Array.from(oids))\n\n  let packstream = new PassThrough()\n  pack(\n    fileSystem,\n    dir,\n    undefined,\n    [...objects],\n    packstream\n  )\n  return { packstream, shallows, unshallows, acks }\n}\n\nasync function listObjects (\n  fileSystem: EncryptedFS,\n  dir: string,\n  gitdir: string = path.join(dir, '.git'),\n  oids: string[]\n) {\n  let commits = new Set<string>()\n  let trees = new Set<string>()\n  let blobs = new Set<string>()\n\n  // We don't do the purest simplest recursion, because we can\n  // avoid reading Blob objects entirely since the Tree objects\n  // tell us which oids are Blobs and which are Trees. And we\n  // do not need to recurse through commit parents.\n  async function walk (oid) {\n    let { type, object } = await GitObjectManager.read(fileSystem, gitdir, oid)\n    if (type === 'commit') {\n      commits.add(oid)\n      let commit = GitCommit.from(object)\n      let tree = commit.headers().tree\n      await walk(tree)\n    } else if (type === 'tree') {\n      trees.add(oid)\n      let tree = GitTree.from(object)\n      for (let entry of tree) {\n        if (entry.type === 'blob') {\n          blobs.add(entry.oid)\n        }\n        // only recurse for trees\n        if (entry.type === 'tree') {\n          await walk(entry.oid)\n        }\n      }\n    }\n  }\n\n  // Let's go walking!\n  for (let oid of oids) {\n    await walk(oid)\n  }\n  return [...commits, ...trees, ...blobs]\n}\n\nasync function pack (\n  fileSystem: EncryptedFS,\n  dir: string,\n  gitdir: string = path.join(dir, '.git'),\n  oids: string[],\n  outputStream: PassThrough\n) {\n  let hash = createHash('sha1')\n  function write(chunk: any, enc: string | undefined = undefined) {\n    if(enc) {\n      outputStream.write(chunk, enc)\n    } else {\n      outputStream.write(chunk)\n    }\n    hash.update(chunk, enc)\n  }\n  function writeObject (object, stype) {\n    let lastFour\n    let multibyte\n    let length\n    // Object type is encoded in bits 654\n    let type = types[stype]\n    if (type === undefined) throw new Error('Unrecognized type: ' + stype)\n    // The length encoding get complicated.\n    length = object.length\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    multibyte = length > 0b1111 ? 0b10000000 : 0b0\n    // Last four bits of length is encoded in bits 3210\n    lastFour = length & 0b1111\n    // Discard those bits\n    length = length >>> 4\n    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)\n    let byte: any = (multibyte | type | lastFour).toString(16)\n    write(byte, 'hex')\n    // Now we keep chopping away at length 7-bits at a time until its zero,\n    // writing out the bytes in what amounts to little-endian order.\n    while (multibyte) {\n      multibyte = length > 0b01111111 ? 0b10000000 : 0b0\n      byte = multibyte | (length & 0b01111111)\n      const unpaddedChunk = byte.toString(16)\n      const paddedChunk = '0'.repeat(2-unpaddedChunk.length) + unpaddedChunk\n      write(paddedChunk, 'hex')\n      length = length >>> 7\n    }\n    // Lastly, we can compress and write the object.\n    write(Buffer.from(pako.deflate(object)))\n  }\n\n  write('PACK')\n  write('00000002', 'hex')\n  // Write a 4 byte (32-bit) int\n  const unpaddedChunk = oids.length.toString(16)\n  const paddedChunk = '0'.repeat(8-unpaddedChunk.length) + unpaddedChunk\n  write(paddedChunk, 'hex')\n  for (let oid of oids) {\n    let { type, object } = await GitObjectManager.read(fileSystem, gitdir, oid)\n    writeObject(object, type)\n  }\n  // Write SHA1 checksum\n  let digest = hash.digest()\n  outputStream.end(digest)\n  return outputStream\n}\n\nexport default packObjects\nexport {listObjects, pack}\n","import path = require(\"path\")\nimport GitCommit from './GitCommit'\nimport { EncryptedFS } from 'encryptedfs'\nimport GitObjectManager from './GitObjectManager'\nimport GitRefManager from '../upload-pack/GitRefManager'\n\n\n\nasync function logCommit (fileSystem: EncryptedFS, gitdir: string, oid: string, signing: boolean) {\n  try {\n    let { type, object } = await GitObjectManager.read(fileSystem, gitdir, oid)\n    if (type !== 'commit') {\n      throw(new Error('expected type to be commit'))\n    }\n    const commit = GitCommit.from(object)\n    const result = Object.assign({ oid }, commit.parse())\n    if (signing) {\n      result.payload = commit.withoutSignature()\n    }\n    return result\n  } catch (err) {\n    return {\n      oid,\n      error: err\n    }\n  }\n}\n\n\nfunction compareAge (a, b) {\n  return a.committer.timestamp - b.committer.timestamp\n}\n\n/**\n * Get commit descriptions from the git history\n *\n * @link https://isomorphic-git.github.io/docs/log.html\n */\nasync function log (\n  fileSystem: EncryptedFS,\n  dir,\n  gitdir = path.join(dir, '.git'),\n  ref = 'HEAD',\n  depth,\n  since, // Date\n  signing = false\n) {\n  try {\n    let sinceTimestamp =\n      since === undefined ? undefined : Math.floor(since.valueOf() / 1000)\n    // TODO: In the future, we may want to have an API where we return a\n    // async iterator that emits commits.\n    let commits: any[] = []\n    let oid = await GitRefManager.resolve(fileSystem, gitdir, ref)\n    let tips /* : Array */ = [await logCommit(fileSystem, gitdir, oid, signing)]\n\n    while (true) {\n      let commit = tips.pop()\n\n      // Stop the loop if we encounter an error\n      if (commit.error) {\n        commits.push(commit)\n        break\n      }\n\n      // Stop the log if we've hit the age limit\n      if (\n        sinceTimestamp !== undefined &&\n        commit.committer.timestamp <= sinceTimestamp\n      ) {\n        break\n      }\n\n      commits.push(commit)\n\n      // Stop the loop if we have enough commits now.\n      if (depth !== undefined && commits.length === depth) break\n\n      // Add the parents of this commit to the queue\n      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.\n      for (const oid of commit.parent) {\n        let commit = await logCommit(fileSystem, gitdir, oid, signing)\n        if (!tips.map(commit => commit.oid).includes(commit.oid)) {\n          tips.push(commit)\n        }\n      }\n\n      // Stop the loop if there are no more commit parents\n      if (tips.length === 0) break\n\n      // Process tips in order by age\n      tips.sort(compareAge)\n    }\n    return commits\n  } catch (err) {\n    err.caller = 'git.log'\n    throw err\n  }\n}\n\nexport default log\nexport {logCommit}\n","import shasum from './shasum'\n\nclass GitObject {\n  static hash ({ type, object }) {\n    let buffer = Buffer.concat([\n      Buffer.from(`${type} ${object.byteLength.toString()}\\0`),\n      Buffer.from(object)\n    ])\n    let oid = shasum(buffer)\n    return oid\n  }\n  static wrap ({ type, object }) {\n    let buffer = Buffer.concat([\n      Buffer.from(`${type} ${object.byteLength.toString()}\\0`),\n      object\n    ])\n    let oid = shasum(buffer)\n    return {\n      oid,\n      buffer\n    }\n  }\n  static unwrap ({ oid, buffer }) {\n    if (oid) {\n      let sha = shasum(buffer)\n      if (sha !== oid) {\n        throw(new Error(`SHA check failed! Expected ${oid}, computed ${sha}`))\n      }\n    }\n    let s = buffer.indexOf(32) // first space\n    let i = buffer.indexOf(0) // first null value\n    let type = buffer.slice(0, s).toString('utf8') // get type of object\n    let length = buffer.slice(s + 1, i).toString('utf8') // get type of object\n    let actualLength = buffer.length - (i + 1)\n    // verify length\n    if (parseInt(length) !== actualLength) {\n      throw(new Error(`Length mismatch: expected ${length} bytes but got ${actualLength} instead.`))\n    }\n    return {\n      type,\n      object: Buffer.from(buffer.slice(i + 1))\n    }\n  }\n}\n\nexport default GitObject\n","import Hash from 'sha.js/sha1'\n\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasum (buffer: Buffer) {\n  return new Hash().update(buffer).digest('hex')\n}\n\nexport default shasum\n","module.exports = require(\"sha.js/sha1\");","/*::\ntype TreeEntry = {\n  mode: string,\n  path: string,\n  oid: string,\n  type?: string\n}\n*/\n\nfunction parseBuffer (buffer) {\n  let _entries: any[] = []\n  let cursor = 0\n  while (cursor < buffer.length) {\n    let space = buffer.indexOf(32, cursor)\n    if (space === -1) {\n      throw(new Error(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`))\n    }\n    let nullchar = buffer.indexOf(0, cursor)\n    if (nullchar === -1) {\n      throw(new Error(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`))\n    }\n    let mode = buffer.slice(cursor, space).toString('utf8')\n    if (mode === '40000') mode = '040000' // makes it line up neater in printed output\n    let type = mode === '040000' ? 'tree' : 'blob'\n    let path = buffer.slice(space + 1, nullchar).toString('utf8')\n    let oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex')\n    cursor = nullchar + 21\n    _entries.push({ mode, path, oid, type })\n  }\n  return _entries\n}\n\nfunction limitModeToAllowed (mode) {\n  if (typeof mode === 'number') {\n    mode = mode.toString(8)\n  }\n  // tree\n  if (mode.match(/^0?4.*/)) return '40000' // Directory\n  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file\n  if (mode.match(/^1007.*/)) return '100755' // Regular executable file\n  if (mode.match(/^120.*/)) return '120000' // Symbolic link\n  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)\n  throw(new Error(`Could not understand file mode: ${mode}`))\n}\n\nfunction nudgeIntoShape (entry) {\n  if (!entry.oid && entry.sha) {\n    entry.oid = entry.sha // Github\n  }\n  entry.mode = limitModeToAllowed(entry.mode) // index\n  if (!entry.type) {\n    entry.type = 'blob' // index\n  }\n  return entry\n}\n\nclass GitTree {\n  /* ::\n  _entries: Array<TreeEntry>\n  */\n _entries: any[]\n  constructor (entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries)\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(nudgeIntoShape)\n    } else {\n      throw(new Error('invalid type passed to GitTree constructor'))\n    }\n  }\n  static from (tree) {\n    return new GitTree(tree)\n  }\n  render () {\n    return this._entries\n      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n  toObject () {\n    return Buffer.concat(\n      this._entries.map((entry) => {\n        let mode = Buffer.from(entry.mode.replace(/^0/, ''))\n        let space = Buffer.from(' ')\n        let path = Buffer.from(entry.path)\n        // let path = Buffer.from(entry.path, { encoding: 'utf8' })\n        let nullchar = Buffer.from([0])\n        let oid = Buffer.from(entry.oid.match(/../g).map(n => parseInt(n, 16)))\n        return Buffer.concat([mode, space, path, nullchar, oid])\n      })\n    )\n  }\n  entries () {\n    return this._entries\n  }\n  * [Symbol.iterator] () {\n    for (let entry of this._entries) {\n      yield entry\n    }\n  }\n}\n\nexport default GitTree\n","module.exports = require(\"sha.js\");","module.exports = require(\"protobufjs\");","/**\n * Returns a 5 character long random string of lower case letters\n */\nfunction randomString(): string {\n\treturn Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5)\n}\n\n/**\n * Inverts the provided promise\n * @param p Promise to invert\n */\nfunction invertPromise<T>(p: Promise<T>): Promise<T> {\n  return new Promise((res, rej) => p.then(rej, res));\n}\n\n/**\n * Gets the first promise fulfiled\n * @param ps List of promises\n */\nfunction firstPromiseFulfilled<T>(ps: Promise<T>[]) {\n  return invertPromise(Promise.all(ps.map(invertPromise)))\n}\n\nexport { randomString, firstPromiseFulfilled }\n","import dgram from 'dgram'\nimport crypto from 'crypto'\nimport PeerInfo from './PeerInfo'\nimport { EventEmitter } from 'events'\nimport RPCMessage from '../rpc/RPCMessage'\nimport KeyManager from '../keys/KeyManager'\n\n// This module is based heavily on libp2p's mDNS module:\n// https://github.com/libp2p/js-libp2p-mdns\n// It is supposed to discover peers on the local network\n// This module was also generated with the help of:\n// https://nrempel.com/using-udp-multicast-with-node-js/\n//\n// \"\"\"\n// In computer networking, the multicast DNS (mDNS) protocol\n// resolves hostnames to IP addresses within small networks\n// that do not include a local name server\n// \"\"\"\n\nconst UDP_MULTICAST_PORT = parseInt(process.env.UDP_MULTICAST_PORT ?? '5353');\nconst UDP_MULTICAST_ADDR = process.env.UDP_MULTICAST_ADDR ?? \"224.0.0.251\";\n\ntype PeerMessage = {\n  encryptedLocalPubKey: Buffer\n  encryptedPeerPubKey: Buffer\n  rawRandomMessage: Buffer\n  encryptedRandomMessage: Buffer\n}\n\nclass MulticastBroadcaster extends EventEmitter {\n  addPeer: (peerInfo: PeerInfo) => void\n  localPeerInfo: PeerInfo\n  keyManager: KeyManager\n\n  socket: dgram.Socket\n\n  interval: number\n  queryInterval: NodeJS.Timeout | null\n  peerPubKeyMessages: Map<string, PeerMessage> = new Map()\n  constructor(\n    addPeer: (peerInfo: PeerInfo) => void,\n    localPeerInfo: PeerInfo,\n    keyManager: KeyManager\n  ) {\n    super()\n\n    this.addPeer = addPeer\n    this.localPeerInfo = localPeerInfo\n    this.keyManager = keyManager\n\n    this.interval = (1e3)\n    this.queryInterval = null\n\n    // Create socket\n    this.socket = dgram.createSocket({ type: \"udp4\", reuseAddr: true })\n    this.socket.bind(<number>UDP_MULTICAST_PORT)\n\n    // Set up listener\n    this.socket.on(\"listening\", (() => {\n      this.socket.addMembership(UDP_MULTICAST_ADDR);\n      const address = this.socket.address();\n    }).bind(this));\n\n    // Handle messages\n    this.socket.on(\"message\", this.handleHandshakeMessages.bind(this));\n\n    // Start the query process\n    this.queryInterval = this.queryLAN()\n  }\n\n  /**\n   * Request a peer contact for the multicast peer discovery to check for\n   * @param publicKey Public key of the desired peer\n   */\n  async requestPeerContact(publicKey: string) {\n    const pubKeyBuf = Buffer.from(publicKey)\n    const randomMessage = crypto.randomBytes(16)\n    // Encrypt message\n    const encryptedPeerPubKey = await this.keyManager.encryptData(pubKeyBuf, pubKeyBuf)\n    const encryptedRandomMessage = await this.keyManager.encryptData(randomMessage, pubKeyBuf)\n    const encryptedLocalPubKey = await this.keyManager.encryptData(Buffer.from(this.keyManager.getPublicKey()), pubKeyBuf)\n\n    // Add to peer messages to be sent over multicast\n    this.peerPubKeyMessages.set(publicKey, {\n      encryptedLocalPubKey: Buffer.from(encryptedLocalPubKey),\n      encryptedPeerPubKey: Buffer.from(encryptedPeerPubKey),\n      rawRandomMessage: randomMessage,\n      encryptedRandomMessage: Buffer.from(encryptedRandomMessage)\n    })\n  }\n\n  // ==== Helper methods ==== //\n  private queryLAN() {\n    const query = () => {\n      for (const pubKey of this.peerPubKeyMessages.keys()) {\n        const peerMessage = this.peerPubKeyMessages.get(pubKey)\n        if (peerMessage) {\n          const handshakeMessage = RPCMessage.encodeHandshakeMessage(\n            peerMessage.encryptedPeerPubKey,\n            peerMessage.encryptedLocalPubKey,\n            peerMessage.encryptedRandomMessage\n          )\n\n          this.socket.send(handshakeMessage, 0, handshakeMessage.length, UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR, () => {\n            console.info(`Sending message to peer`);\n          });\n        }\n\n      }\n    }\n\n    // Immediately start a query, then do it every interval.\n    query()\n    return setInterval(query, this.interval)\n  }\n\n  private async handleHandshakeMessages(message: any, rinfo: any) {\n    try {\n      const decodedMessage = RPCMessage.decodeHandshakeMessage(message)\n      console.info(`Message from: ${rinfo.address}:${rinfo.port}`);\n\n      // Try to decrypt message and pubKey\n      const decryptedMessage = await this.keyManager.decryptData(decodedMessage.message)\n      const decryptedTargetPubKey = await this.keyManager.decryptData(decodedMessage.targetPubKey)\n      const decryptedRequestingPubKey = await this.keyManager.decryptData(decodedMessage.requestingPubKey)\n\n      const myPubKey = this.keyManager.getPublicKey()\n\n      if (decryptedRequestingPubKey.toString() == myPubKey) { // Response\n        // Make sure decrypted bytes equal raw bytes in memory\n        const originalMessage = this.peerPubKeyMessages.get(decryptedTargetPubKey.toString())?.rawRandomMessage\n\n        if (decryptedMessage.toString() == originalMessage?.toString()) {  // Validated!\n          // Add peer info to peerStore\n          const newPeerInfo = decodedMessage.responsePeerInfo\n          if (newPeerInfo) {\n            this.addPeer(newPeerInfo)\n            // Remove peerId from requested messages\n            const pubKey = newPeerInfo.publicKey\n            this.peerPubKeyMessages.delete(pubKey)\n            console.log(`New peer added to the store`);\n            this.emit('found', newPeerInfo)\n          } else {\n            this.emit('error', \"I got a validated response. But no peerInfo\");\n          }\n        }\n      } else {  // Requests on target node\n        // Try decrypting message\n        // Re-encrypt the data and send it on its way\n\n        const encryptedTargetPubKey = await this.keyManager.encryptData(Buffer.from(myPubKey), decryptedRequestingPubKey)\n        const encryptedMessage = await this.keyManager.encryptData(decryptedMessage, decryptedRequestingPubKey)\n        const encryptedPubKey = await this.keyManager.encryptData(decryptedRequestingPubKey, decryptedRequestingPubKey)\n        const handshakeMessage = RPCMessage.encodeHandshakeMessage(\n          Buffer.from(encryptedTargetPubKey),\n          Buffer.from(encryptedPubKey),\n          Buffer.from(encryptedMessage),\n          this.localPeerInfo\n        )\n        this.socket.send(handshakeMessage, 0, handshakeMessage.length, <number>UDP_MULTICAST_PORT, UDP_MULTICAST_ADDR);\n      }\n    } catch (err) { // Couldn't decode message\n      // We don't want the multicast discovery to error on every message it coudln't decode!\n    }\n  }\n}\n\nexport default MulticastBroadcaster\n","module.exports = require(\"dgram\");","module.exports = require(\"events\");","import fs from 'fs';\nimport Path from 'path';\nimport git from 'isomorphic-git';\nimport GitClient from '../git/GitClient';\nimport { EncryptedFS } from 'encryptedfs';\n\n\ntype VaultMetadata = {\n  sharedPubKeys: string[]\n}\n\nclass Vault {\n\n  private key: Buffer\n  private keyLen: number\n  name: string\n  private efs: EncryptedFS\n  vaultPath: string\n  private secrets: Map<string, any>\n  private sharedPubKeys: Set<string>\n  private metadataPath: string\n  constructor(\n    name: string,\n    symKey: Buffer,\n    baseDir: string\n  ) {\n    // how do we create pub/priv key pair?\n    // do we use the same gpg pub/priv keypair\n    this.key = symKey\n    this.keyLen = symKey.length\n    // Set filesystem\n    const vfsInstance = new (require('virtualfs')).VirtualFS\n\n    this.efs = new EncryptedFS(\n      this.key,\n      vfsInstance,\n      vfsInstance,\n      fs,\n      process\n    )\n\n    this.name = name\n    this.vaultPath = Path.join(baseDir, name)\n    // make the vault directory\n    this.efs.mkdirSync(this.vaultPath, { recursive: true })\n    this.secrets = new Map()\n\n    this.loadSecrets()\n\n    // Load metadata\n    this.metadataPath = Path.join(this.vaultPath, '.vault', 'metadata')\n    this.loadMetadata()\n  }\n\n  /**\n   * Returns the Encrypted File System used for vault operations\n   */\n  public get EncryptedFS(): EncryptedFS {\n    return this.efs\n  }\n\n  /**\n   * Determines whether a secret exists in the vault\n   * @param secretName Name of desired secret\n   */\n  secretExists(secretName: string): boolean {\n    const secretPath = Path.join(this.vaultPath, secretName)\n    return this.secrets.has(secretName) && this.efs.existsSync(secretPath)\n  }\n\n  /**\n   * Adds a secret to the vault\n   * @param secretName Name of new secret\n   * @param secret Content of new secret\n   */\n  async addSecret(secretName: string, secret: Buffer): Promise<void> {\n    // Check if secret already exists\n    if (this.secrets.has(secretName)) {\n      throw new Error('Secret already exists, try updating it instead.')\n    }\n    const writePath = Path.join(this.vaultPath, secretName)\n    // Write secret\n    await this.efs.promises.writeFile(writePath, secret, {})\n    // Update secrets map\n    this.secrets.set(secretName, secret)\n    // Auto commit message\n    await this.commitChanges(`Add secret: ${secretName}`, secretName, 'added')\n  }\n\n  /**\n   * Updates a secret in the vault\n   * @param secretName Name of secret to be updated\n   * @param secret Content of updated secret\n   */\n  async updateSecret(secretName: string, secret: Buffer): Promise<void> {\n    // Check if secret already exists\n    if (!this.secrets.has(secretName)) {\n      throw new Error('Secret does not exist, try adding it instead.')\n    }\n    const writePath = Path.join(this.vaultPath, secretName)\n    // Write secret\n    await this.efs.promises.writeFile(writePath, secret, {})\n    // Update secrets map\n    this.secrets.set(secretName, secret)\n    // Auto commit message\n    await this.commitChanges(`Update secret: ${secretName}`, secretName, 'modified')\n  }\n\n  /**\n   * Get a secret from the vault\n   * @param secretName Name of secret to be retrieved\n   */\n  getSecret(secretName: string): Buffer | string {\n    if (this.secrets.has(secretName)) {\n      const secret = this.secrets.get(secretName)\n      if (secret) {\n        return secret\n      } else {\n        const secretPath = Path.join(this.vaultPath, secretName)\n        // TODO: this should be async\n        const secretBuf = this.efs.readFileSync(secretPath, {})\n        this.secrets.set(secretName, secretBuf)\n        return secretBuf\n      }\n    }\n    throw Error('Secret: ' + secretName + ' does not exist')\n  }\n\n  /**\n   * [WARNING] Removes a secret from the vault\n   * @param secretName Name of secret to be removed\n   */\n  async removeSecret(secretName: string): Promise<void> {\n    if (this.secrets.has(secretName)) {\n      const successful = this.secrets.delete(secretName)\n      // Remove from fs\n      await this.efs.promises.unlink(Path.join(this.vaultPath, secretName))\n      // Auto commit message\n      await this.commitChanges(`Remove secret: ${secretName}`, secretName, 'removed')\n\n      if (successful) {\n        return\n      }\n      throw Error('Secret: ' + secretName + ' was not removed')\n    }\n    throw Error('Secret: ' + secretName + ' does not exist')\n  }\n\n  /**\n   * Lists all the secrets currently in the vault\n   */\n  listSecrets(): string[] {\n    let secrets: string[] = Array.from(this.secrets.keys())\n    return secrets\n  }\n\n  tagVault() {\n\n  }\n\n  untagVault() {\n\n  }\n\n  /////////////\n  // Sharing //\n  /////////////\n  /**\n   * Allows a particular public key to access the vault\n   * @param publicKey Public key to share with\n   */\n  shareVault(publicKey: string) {\n    if (this.sharedPubKeys.has(name)) {\n      throw new Error('Vault is already shared with given public key')\n    }\n\n    this.sharedPubKeys.add(publicKey)\n\n    // Write metadata\n    this.writeMetadata()\n  }\n\n  /**\n   * Removes access to the vault for a particular public key\n   * @param publicKey Public key to unshare with\n   */\n  unshareVault(publicKey: string) {\n    if (!this.sharedPubKeys.has(publicKey)) {\n      throw new Error('Vault is not shared with given public key')\n    }\n\n    this.sharedPubKeys.delete(publicKey)\n\n    // Write metadata\n    this.writeMetadata()\n  }\n\n  /**\n   * Determines if a particular public key can access the vault\n   * @param publicKey Public key to check\n   */\n  peerCanAccess(publicKey: string): boolean {\n    // return this.sharedPubKeys.has(publicKey)\n    return true\n  }\n\n  /**\n   * Pulls the vault from a specific address\n   * @param address Address of polykey node that owns vault to be pulled\n   * @param getSocket Function to get an active connection to provided address\n   */\n  async pullVault(gitClient: GitClient) {\n    // Strangely enough this is needed for pulls along with ref set to 'HEAD'\n    // In isogit's documentation, this is just to get the currentBranch name\n    // But it solves a bug whereby if not used, git.pull complains that it can't\n    // find the master branch or HEAD\n    await git.currentBranch({\n      fs: { promises: this.efs.promises },\n      dir: this.vaultPath,\n      fullname: true\n    })\n    // First pull\n    await git.pull({\n      fs: { promises: this.efs.promises },\n      http: gitClient,\n      dir: this.vaultPath,\n      url: \"http://\" + '0.0.0.0:0' + '/' + this.name,\n      ref: 'HEAD',\n      singleBranch: true,\n      author: {\n        name: this.name\n      }\n    })\n\n    // Load any new secrets\n    this.loadSecrets()\n  }\n\n  /**\n   * Initializes the git repository for new vaults\n   */\n  async initRepository() {\n    const fileSystem = this.efs\n    await git.init({\n      fs: fileSystem,\n      dir: this.vaultPath\n    })\n\n    // Initial commit\n    await git.commit({\n      fs: fileSystem,\n      dir: this.vaultPath,\n      author: {\n        name: this.name\n      },\n      message: \"init commit\"\n    })\n\n    // Write packed-refs file because isomorphic git goes searching for it\n    // and apparently its not autogenerated\n    this.efs.writeFileSync(Path.join(this.vaultPath, '.git', 'packed-refs'), '# pack-refs with: peeled fully-peeled sorted')\n  }\n\n  // ============== Helper methods ============== //\n  private writeMetadata(): void {\n    // mkdir first\n    this.efs.mkdirSync(Path.dirname(this.metadataPath), { recursive: true })\n\n    // Create and write metadata\n    const metadata: VaultMetadata = {\n      sharedPubKeys: Array.from(this.sharedPubKeys.keys())\n    }\n    this.efs.writeFileSync(this.metadataPath, JSON.stringify(metadata))\n  }\n\n  private loadMetadata(): void {\n    if (this.efs.existsSync(this.metadataPath)) {\n      const fileContents = this.efs.readFileSync(this.metadataPath).toString()\n      const metadata: VaultMetadata = JSON.parse(fileContents)\n      this.sharedPubKeys = new Set(metadata.sharedPubKeys)\n    } else {\n      // Need to create it\n      this.sharedPubKeys = new Set()\n      this.writeMetadata()\n    }\n  }\n\n  private async commitChanges(message: string, secretName: string, action: 'added' | 'modified' | 'removed'): Promise<string> {\n    if (action == 'removed') {\n      await git.remove({\n        fs: this.efs,\n        dir: this.vaultPath,\n        filepath: secretName\n      })\n    } else {\n      await git.add({\n        fs: this.efs,\n        dir: this.vaultPath,\n        filepath: secretName\n      })\n    }\n\n    return await git.commit({\n      fs: this.efs,\n      dir: this.vaultPath,\n      author: {\n        name: this.name\n      },\n      message: message\n    })\n  }\n\n  private loadSecrets(): void {\n    const secrets = fs.readdirSync(this.vaultPath, undefined)\n\n    for (const secret of secrets.filter((s) => s[0] != '.')) {\n      this.secrets.set(secret, null)\n    }\n  }\n}\n\nexport default Vault\n"],"sourceRoot":""}