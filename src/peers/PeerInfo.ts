import crypto from 'crypto';
import { AddressInfo } from 'net';
import { LinkInfo, LinkInfoIdentity } from '../links';
import { md, pki } from 'node-forge';
import { gestaltKey, GestaltKey } from '../gestalts';
import * as agentInterface from '../../proto/js/Agent_pb';
import { JSONMapReplacer, JSONMapReviver } from '../utils';

class Address {
  host: string;
  port: number;
  constructor(host: string, port: number) {
    const parsedAddress = Address.parseHelper(`${host}:${port}`);
    this.host = parsedAddress.host;
    this.port = parsedAddress.port;
  }

  updateHost(host?: string) {
    if (host != undefined && host != '') {
      this.host = host;
    }
  }

  updatePort(port?: number) {
    if (port != undefined && port != 0) {
      this.port = port;
    }
  }

  /**
   * Create an address object from a address string
   * @param addressString Address string in the format of `${this.ip}:${this.port}`
   */
  static parse(addressString: string): Address {
    const { host, port } = Address.parseHelper(addressString);
    return new Address(host, port);
  }

  /**
   * Create an address object from a net.AddressInfo
   * @param addressInfo AddressInfo of desired address
   */
  static fromAddressInfo(addressInfo: AddressInfo) {
    const host = addressInfo.address == '::' ? 'localhost' : addressInfo.address;
    return new Address(host, addressInfo.port);
  }

  /**
   * Convert address into string of format `${this.host}:${this.port}`
   */
  toString() {
    return `${this.host}:${this.port}`;
  }

  /**
   * Parses an address string in the format of `host:port`
   */
  private static parseHelper(addressString: string): { host: string; port: number } {
    if (!addressString || addressString == '') {
      throw Error(`cannot parse empty or undefined string`);
    }
    const url = new URL(addressString);
    return {host: url.hostname, port: Number(url.port)};
  }
}

// The PeerInfo class is reserved for the local peer's information and is modifiable
// as we have the ability to change its information and re-sign it as the owner
// of the private key it describes.
class PeerInfo {
  private internalAlias: string;
  public get alias(): string {
    return this.internalAlias;
  }
  public set alias(value: string) {
    this.internalAlias = value;
  }
  private internalId: string;
  public get id(): string {
    return this.internalId;
  }
  public set id(value: string) {
    this.internalId = value;
  }
  // Public key generated by kbpgp
  private internalPublicKey: string;
  public get publicKey(): string {
    return this.internalPublicKey;
  }
  public set publicKey(publicKey: string) {
    throw Error('cannot change public key once set');
  }

  // peer root certificate for trusted connections
  private internalRootPublicKey: string;
  public get rootPublicKey(): string {
    return this.internalRootPublicKey;
  }
  public set rootPublicKey(certificate: string) {
    this.internalRootPublicKey = certificate;
  }

  // Address where all peer operations occur over (might be obscured by NAT)
  private internalPeerAddress?: Address;
  public get peerAddress(): Address | undefined {
    return this.internalPeerAddress;
  }
  public set peerAddress(address: Address | undefined) {
    this.internalPeerAddress = address;
  }

  // Address over which the polykey HTTP API is serve
  private internalApiAddress?: Address;
  public get apiAddress(): Address | undefined {
    return this.internalApiAddress;
  }
  public set apiAddress(address: Address | undefined) {
    this.internalApiAddress = address;
  }

  // List of social proofs made by this peer
  private internalLinkInfoMap: Map<GestaltKey, LinkInfo> = new Map;
  public get linkInfoList(): LinkInfo[] {
    return Array.from(this.internalLinkInfoMap.values());
  }
  public set linkInfoList(values: LinkInfo[]) {
    this.internalLinkInfoMap = new Map
    values.forEach(li => this.publishLinkInfo(li))
  }
  publishLinkInfo(linkInfo: LinkInfo) {
    let provider: string | undefined = undefined
    try {
      provider = (linkInfo as LinkInfoIdentity).provider
    } catch (error) {
      // no throw in case linkInfo is LinkInfoNode
    }
    const gKey = gestaltKey(linkInfo.key, provider)
    this.internalLinkInfoMap.set(gKey, linkInfo)
  }
  getLinkInfo(gKey: GestaltKey): LinkInfo | undefined {
    return this.internalLinkInfoMap.get(gKey)
  }

  constructor(
    alias: string,
    publicKey: string,
    rootPublicKey?: string,
    peerAddress?: string,
    apiAddress?: string,
    linkInfoList?: LinkInfo[],
  ) {
    this.internalAlias = alias
    this.internalPublicKey = PeerInfo.formatPublicKey(publicKey);
    this.internalId = PeerInfo.publicKeyToId(this.internalPublicKey);
    if (rootPublicKey) {
      this.internalRootPublicKey = PeerInfo.formatPublicKey(rootPublicKey);
    }
    if (peerAddress) {
      this.internalPeerAddress = Address.parse(peerAddress);
    }
    if (apiAddress) {
      this.internalApiAddress = Address.parse(apiAddress);
    }
    if (linkInfoList) {
      this.internalLinkInfoMap = new Map
      linkInfoList.forEach(li => this.publishLinkInfo(li))
    }
  }

  static publicKeyToId(publicKey: string) {
    const formatedPublicKey = PeerInfo.formatPublicKey(publicKey);
    // we are using md5 for hash + hex for encoding on the public key to make a short,
    // human readable/sharable name. example peerId: 167dcbfa28e9425f3db39e89ab748540
    return crypto.createHash('md5').update(formatedPublicKey).digest('hex');
  }

  static formatPublicKey(str: string): string {
    const startString = '-----BEGIN PUBLIC KEY-----';
    const endString = '-----END PUBLIC KEY-----';
    return str.slice(str.indexOf(startString), str.indexOf(endString) + endString.length);
  }

  static formatPemCertificate(str: string): string {
    const startString = '-----BEGIN CERTIFICATE-----';
    const endString = '-----END CERTIFICATE-----';
    return str.slice(str.indexOf(startString), str.indexOf(endString) + endString.length);
  }

  deepCopy(): PeerInfo {
    return new PeerInfo(
      this.alias,
      this.publicKey,
      this.rootPublicKey,
      this.internalPeerAddress?.toString(),
      this.internalApiAddress?.toString(),
      this.linkInfoList,
    );
  }

  toX509Pem(signingKey: pki.rsa.PrivateKey): string {
    // create a certification request (CSR)
    const certificate = pki.createCertificate();
    certificate.serialNumber = '01';
    certificate.validity.notBefore = new Date();
    certificate.validity.notAfter = new Date();
    // valid for 10 years
    certificate.validity.notAfter.setFullYear(certificate.validity.notBefore.getFullYear() + 10);

    const attrs = [
      {
        name: 'commonName',
        value: 'polykey',
      },
      {
        // alias
        type: '1.3.1.4.1',
        value: this.alias
      },
      {
        // root certificate
        type: '1.3.1.4.2',
        value: this.rootPublicKey ?? ''
      },
      {
        // peer address
        type: '1.3.1.4.3',
        value: this.internalPeerAddress?.toString() ?? ''
      },
      {
        // api address
        type: '1.3.1.4.4',
        value: this.internalApiAddress?.toString() ?? ''
      },
      {
        // link claim identity list
        type: '1.3.1.4.5',
        value: JSON.stringify(this.internalLinkInfoMap, JSONMapReplacer)
      }
    ];

    certificate.setSubject(attrs);
    certificate.setIssuer(attrs);
    certificate.publicKey = pki.publicKeyFromPem(this.internalPublicKey);

    certificate.setExtensions([
      {
        name: 'basicConstraints',
        cA: true,
      },
      {
        name: 'keyUsage',
        keyCertSign: true,
        digitalSignature: true,
        nonRepudiation: true,
        keyEncipherment: true,
        dataEncipherment: true,
      },
      {
        name: 'extKeyUsage',
        serverAuth: true,
        clientAuth: true,
        codeSigning: true,
        emailProtection: false,
        timeStamping: true,
      },
      {
        name: 'nsCertType',
        client: true,
        server: true,
        email: false,
        objsign: false,
        sslCA: true,
        emailCA: false,
        objCA: true,
      },
    ]);

    // sign certificate
    certificate.sign(signingKey, md.sha512.create());

    return pki.certificateToPem(certificate);
  }

  static parseX509Pem(pem: string) {
    const cert = pki.certificateFromPem(pem)

    // create a mapping from type to value
    const attributes: Map<string, any> = new Map
    cert.issuer.attributes.forEach(a => { attributes.set(a.type, a.value) })

    // retrieve attributes
    const alias: string = attributes.get('1.3.1.4.1') ?? ''
    const rootPublicKey: string = attributes.get('1.3.1.4.2') ?? ''
    const peerAddress: string = attributes.get('1.3.1.4.3') ?? ''
    const apiAddress: string = attributes.get('1.3.1.4.4') ?? ''
    const linkInfoListString: string = attributes.get('1.3.1.4.5')
    const linkInfoList: Map<GestaltKey, LinkInfo> = JSON.parse(linkInfoListString, JSONMapReviver) ?? new Map
    return {
      alias,
      publicKey: pki.publicKeyToPem(cert.publicKey),
      rootPublicKey,
      peerAddress,
      apiAddress,
      linkInfoList
    }
  }

  static fromX509Pem(pem: string): PeerInfo {
    const parsedCert = PeerInfo.parseX509Pem(pem)
    return new PeerInfo(
      parsedCert.alias,
      parsedCert.publicKey,
      parsedCert.rootPublicKey,
      parsedCert.peerAddress,
      parsedCert.apiAddress,
      Array.from(parsedCert.linkInfoList.values())
    )
  }
}


// This class is meant to be a readonly version of PeerInfo as we
// do not own the private key it describes so we can not resign
// changes made to it. The peerAddress and apiAddresses are
// however changeable to make certain use cases practical.
class PeerInfoReadOnly extends PeerInfo {
  private internalPem: string
  public get pem(): string {
    return this.internalPem
  }
  public set pem(value: string) {
    throw Error('pem cannot be set')
  }
  public get id(): string {
    return super.id
  }
  public set id(v: string) {
    throw Error('cannot set peerId on a readonly peer info')
  }
  public get publicKey(): string {
    return super.publicKey
  }
  public set publicKey(v: string) {
    throw Error('cannot set publicKey on a readonly peer info')
  }
  public get rootPublicKey(): string {
    return super.rootPublicKey
  }
  public set rootPublicKey(v: string) {
    throw Error('cannot set rootPublicKey on a readonly peer info')
  }
  public get linkInfoList(): LinkInfo[] {
    // underlying array should be immutable
    return [...super.linkInfoList]
  }
  public set linkInfoList(v: LinkInfo[]) {
    throw Error('cannot set proofList on a readonly peer info')
  }

  // the only 3 things that can change in a read only peer info
  // are the alias, peerAddress and apiAddress. This is to facillitate
  // the user being able to change these if new knowledge becomes
  // available
  // unsignedAlias
  private signedAlias: string
  private unsignedAlias?: string
  public get hasUnsignedAlias(): boolean {
    return this.unsignedAlias != undefined
  }
  public get alias(): string {
    if (this.unsignedAlias) {
      return this.unsignedAlias
    } else {
      return this.signedAlias
    }
  }
  public set alias(v: string) {
    this.unsignedAlias = v
  }
  // unsignedPeerAddress
  private unsignedPeerAddress?: Address
  public get hasUnsignedPeerAddress(): boolean {
    return this.unsignedPeerAddress != undefined
  }
  public get peerAddress(): Address | undefined {
    if (this.unsignedPeerAddress) {
      return this.unsignedPeerAddress
    } else {
      return super.peerAddress
    }
  }
  public set peerAddress(v: Address | undefined) {
    this.unsignedPeerAddress = v
  }
  // unsignedApiAddress
  private unsignedApiAddress?: Address
  public get hasUnsignedApiAddress(): boolean {
    return this.unsignedApiAddress != undefined
  }
  public get apiAddress(): Address | undefined {
    if (this.unsignedApiAddress) {
      return this.unsignedApiAddress
    } else {
      return super.apiAddress
    }
  }
  public set apiAddress(v: Address | undefined) {
    this.unsignedApiAddress = v
  }

  constructor(peerInfoPem: string) {
    const pem = PeerInfo.formatPemCertificate(peerInfoPem)
    const parsedCert = PeerInfo.parseX509Pem(pem)
    super(
      parsedCert.alias,
      parsedCert.publicKey,
      parsedCert.rootPublicKey,
      parsedCert.peerAddress,
      parsedCert.apiAddress,
      Array.from(parsedCert.linkInfoList.values())
    )
    this.internalPem = pem
    this.signedAlias = parsedCert.alias
  }

  deepCopy(): PeerInfoReadOnly {
    const newPeerInfo = new PeerInfoReadOnly(this.internalPem);
    newPeerInfo.unsignedAlias = this.unsignedAlias
    newPeerInfo.unsignedApiAddress = this.unsignedApiAddress
    newPeerInfo.unsignedPeerAddress = this.unsignedPeerAddress
    return newPeerInfo
  }

  toPeerInfoReadOnlyMessage(): agentInterface.PeerInfoReadOnlyMessage {
    const message = new agentInterface.PeerInfoReadOnlyMessage
    message.setPeerId(this.id)
    message.setPem(this.pem)
    if (this.hasUnsignedAlias) {
      message.setUnsignedAlias(this.alias)
    }
    if (this.hasUnsignedPeerAddress) {
      message.setUnsignedPeerAddress(this.peerAddress?.toString() ?? '')
    }
    if (this.hasUnsignedApiAddress) {
      message.setUnsignedApiAddress(this.apiAddress?.toString() ?? '')
    }
    return message
  }

  static fromPeerInfoReadOnlyMessage(
    message: agentInterface.PeerInfoReadOnlyMessage.AsObject
  ): PeerInfoReadOnly {
    const {
      pem,
      unsignedAlias,
      unsignedPeerAddress,
      unsignedApiAddress,
    } = message
    const peerInfo = new PeerInfoReadOnly(pem)
    if (unsignedAlias) {
      peerInfo.alias = unsignedAlias
    }
    if (unsignedPeerAddress) {
      peerInfo.peerAddress = Address.parse(unsignedPeerAddress)
    }
    if (unsignedApiAddress) {
      peerInfo.apiAddress = Address.parse(unsignedApiAddress)
    }
    return peerInfo
  }
}

export { Address, PeerInfo, PeerInfoReadOnly };
