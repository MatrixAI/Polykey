import type { NodePermissions, ACL, FileChanges } from './types';
import type { NodeConnection } from '../nodes/types';
import fs from 'fs';
import path from 'path';
import git from 'isomorphic-git';
import { Mutex } from 'async-mutex';
import { VirtualFS } from 'virtualfs';
import { EncryptedFS } from 'encryptedfs';
import Logger from '@matrixai/logger';
import { GitFrontend } from '../git';
import * as vaultsUtils from './utils';
import * as errors from './errors';

class Vault {
  public readonly baseDir: string;
  public vaultName: string;
  private nodePermissions: ACL;
  private efs: EncryptedFS;
  private mutex: Mutex;
  protected gitFrontend: GitFrontend;
  protected logger: Logger;
  /**
   *
   * @param vaultName Name of vault
   * @param baseDir Base path of vaults
   * @param key Vault Key
   * @param logger Logger
   */
  constructor({
    vaultName,
    key,
    baseDir,
    logger,
  }: {
    vaultName: string;
    key: Buffer;
    baseDir: string;
    logger?: Logger;
  }) {
    this.vaultName = vaultName;
    this.logger = logger ?? new Logger('Vault');
    this.baseDir = baseDir;
    const vfsinstance = new VirtualFS();
    this.efs = new EncryptedFS(key, vfsinstance, vfsinstance, fs, process);
    this.nodePermissions = {};
    this.mutex = new Mutex();

    // Git frontend
    const nodeConnection: NodeConnection = { placeholder: true };
    this.gitFrontend = new GitFrontend(() => nodeConnection);
  }

  public async create() {
    // make the vault directory
    this.efs.mkdirSync(path.join(this.baseDir, this.vaultName), {
      recursive: true,
    });
    this.logger.info(
      `Created vault directory at ${path.join(this.baseDir, this.vaultName)}`,
    );
    this.loadNodePermissions();
  }

  public async destroy() {
    return;
  }

  public get EncryptedFS(): EncryptedFS {
    return this.efs;
  }

  /**
   * Creates the git repositiory for the vault
   */
  public async initializeVault(): Promise<void> {
    // Initialize repository for vault
    const efs = this.efs;
    const fileSystem = { promises: efs.promises };

    // Init repository
    await git.init({
      fs: fileSystem,
      dir: path.join(this.baseDir, this.vaultName),
    });

    // Initial commit
    await git.commit({
      fs: fileSystem,
      dir: path.join(this.baseDir, this.vaultName),
      author: {
        name: this.vaultName,
      },
      message: 'Initial Commit',
    });

    // Write pack-refs file bcause isomorphic git goes searching for it and
    // apparently its not autogenerated
    efs.writeFileSync(
      path.join(path.join(this.baseDir, this.vaultName), '.git', 'packed-refs'),
      '# pack-refs with: peeled fully-peeled sorted',
    );
    this.logger.info(
      `Writing initial vault commit at '${path.join(
        this.baseDir,
        this.vaultName,
        '.git',
        'packed-refs',
      )}'`,
    );
  }

  /**
   * Retreives stats for a vault
   *
   * @returns the stats of the vault directory
   */
  public async vaultStats(): Promise<fs.Stats> {
    const release = await this.mutex.acquire();
    try {
      return this.efs.statSync(path.join(this.baseDir, this.vaultName));
    } finally {
      release();
    }
  }

  /**
   * Pulls this vault from a nodeId
   *
   * @param nodeId identifier of node to pull from
   */
  public async pullVault(nodeId: string): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      await git.currentBranch({
        fs: { promises: this.efs.promises },
        dir: path.join(this.baseDir, this.vaultName),
        fullname: true,
      });
      const gitClient = this.gitFrontend.connectToNodeGit(nodeId);
      await git.pull({
        fs: { promises: this.efs.promises },
        http: gitClient,
        dir: path.join(this.baseDir, this.vaultName),
        url: 'http://' + '0.0.0.0:0' + '/' + this.vaultName,
        ref: 'HEAD',
        singleBranch: true,
        author: {
          name: this.vaultName,
        },
      });
    } finally {
      release();
    }
    return;
  }

  /**
   * Adds an empty directory to the root of the vault.
   * i.e. mkdir("folder", {recursive = false}) creates the "<vaultDir>/folder" directory
   *
   * @param path path of the directory
   * @param recursive determines if the directory is added recursively
   */
  public async mkdir(
    dirPath: string,
    { recursive = false }: { recursive: boolean },
  ): Promise<void> {
    const newDir = path.join(this.baseDir, this.vaultName, dirPath);
    const release = await this.mutex.acquire();
    try {
      await this.efs.promises.mkdir(newDir, { recursive: recursive });
    } finally {
      release();
    }
  }

  /**
   * Adds a secret to the vault
   *
   * @throws ErrorVaultUninitialised if the vault repository has
   * not been initialised
   * @throws ErrorSecretDefined if the secret name matches an existing file
   * @throws ErrorGitFile if the secret added is a .git file
   * @param secretName name of the secret to add
   * @param content content of the secret to add
   * @param secretPath path of directory to store secret
   * @returns true if the secret exists in the vault directory
   */
  public async addSecret(
    secretName: string,
    content: Buffer,
    secretDir: string = '',
  ): Promise<boolean> {
    const secretPath = path.join(
      this.baseDir,
      this.vaultName,
      secretDir,
      secretName,
    );
    const release = await this.mutex.acquire();
    try {
      if (
        !this.efs.existsSync(path.join(this.baseDir, this.vaultName, '.git'))
      ) {
        throw new errors.ErrorVaultUninitialised(
          `${this.vaultName} has not been initialised`,
        );
      } else if (this.efs.existsSync(secretPath)) {
        // throw error if secret exists
        throw new errors.ErrorSecretDefined(
          `${secretName} already exists, try updating instead`,
        );
      } else if (secretName === '.git') {
        throw new errors.ErrorGitFile('`.git files cannot be added to a vault');
      }
      // create the directory if it doesn't exist
      await this.efs.promises.mkdir(path.dirname(secretPath), {
        recursive: true,
      });
      // Write secret
      await this.efs.promises.writeFile(secretPath, content, {});
      this.logger.info(`Wrote secret to directory at '${secretPath}'`);

      // Auto commit message
      await this.commitChanges(
        [{ fileName: path.join(secretDir, secretName), action: 'added' }],
        `Add secret: ${secretName}`,
      );
    } finally {
      release();
    }

    if (fs.existsSync(secretPath)) {
      return true;
    }
    return false;
  }

  /**
   * Adds a secret directory to the vault
   *
   * @throws ErrorVaultUninitialised if the vault repository has
   * not been initialised
   * @throws ErrorGitFile if the secret added is a .git file
   * @param secretDirectory on disk path to directory of secrets to be added
   */
  public async addSecretDirectory(secretDirectory: string): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      const commitList: FileChanges = [];
      const absoluteDirPath = path.resolve(secretDirectory);
      for await (const secretPath of vaultsUtils.readdirRecursively(
        absoluteDirPath,
      )) {
        // get rid of the root path to each secret
        const secretName = path.basename(secretPath);
        const content = fs.readFileSync(secretPath);
        if (
          !this.efs.existsSync(path.join(this.baseDir, this.vaultName, '.git'))
        ) {
          throw new errors.ErrorVaultUninitialised(
            `${this.vaultName} has not been initialised`,
          );
        } else if (
          this.efs.existsSync(
            path.join(this.baseDir, this.vaultName, secretName),
          )
        ) {
          const writePath = path.join(this.baseDir, this.vaultName, secretName);
          // Write secret
          await this.efs.promises.writeFile(writePath, content, {});
          this.logger.info(`Updated secret at directory ${writePath}`);
          commitList.push({ fileName: secretName, action: 'modified' });
        } else if (secretName === '.git') {
          throw new errors.ErrorGitFile(
            '`.git files cannot be added to a vault',
          );
        } else {
          const writePath = path.join(this.baseDir, this.vaultName, secretName);
          // create the directory if it doesn't exist
          await this.efs.promises.mkdir(path.dirname(writePath), {
            recursive: true,
          });
          // Write secret
          await this.efs.promises.writeFile(writePath, content, {});
          this.logger.info(`Wrote secret to directory at '${writePath}'`);
          commitList.push({ fileName: secretName, action: 'added' });
        }
      }

      // Auto commit message
      await this.commitChanges(
        commitList,
        `Add/Modify secrets: ${commitList[0].fileName} and ${
          commitList.length - 2
        } more`,
      );
    } finally {
      release();
    }
  }

  /**
   * Changes the editing permissions of a node
   *
   * @param nodeId identifier of the node
   * @param newPermissions new permissions for the node
   */
  public changePermissions(
    nodeId: string,
    newPermissions: NodePermissions,
  ): void {
    this.nodePermissions[nodeId] = newPermissions;
    this.writeNodePermissions();
  }

  /**
   * Returns the editing permissions of a node
   *
   * @param nodeId identifier for the node
   * @returns the permissions of the node
   */
  public checkPermissions(nodeId: string): NodePermissions {
    return this.nodePermissions[nodeId];
  }

  /**
   * Changes the contents of a secret
   * @throws ErrorSecretUndefined if the secret name does not match
   * an existing file
   * @param secretName name of the secret to update
   * @param content content of the secret to update
   */
  public async updateSecret(
    secretName: string,
    content: Buffer,
  ): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      // Check if secret already exists
      if (!fs.existsSync(path.join(this.baseDir, this.vaultName, secretName))) {
        throw new errors.ErrorSecretUndefined(
          'Secret does not exist, try adding it instead.',
        );
      }
      const writePath = path.join(this.baseDir, this.vaultName, secretName);
      // Write secret
      await this.efs.promises.writeFile(writePath, content, {});

      this.logger.info(`Updated secret at directory ${writePath}`);

      // Auto commit message
      await this.commitChanges(
        [{ fileName: secretName, action: 'modified' }],
        `Update secret: ${secretName}`,
      );
    } finally {
      release();
    }
  }

  /**
   * Renames the vault
   *
   * @param newVaultName name to change to
   * @returns true if the new name exists in the directory
   */
  public async renameVault(newVaultName: string): Promise<boolean> {
    const release = await this.mutex.acquire();
    try {
      this.efs.rename(
        `${this.baseDir}/${this.vaultName}`,
        `${this.baseDir}/${newVaultName}`,
      );
      this.logger.info(
        `Renamed vault directory at '${this.baseDir}/${this.vaultName}' to '${this.baseDir}/${newVaultName}'`,
      );
    } finally {
      release();
    }

    if (
      fs.existsSync(path.join(this.baseDir, this.vaultName)) ||
      !fs.existsSync(path.join(this.baseDir, newVaultName))
    ) {
      return false;
    }

    this.vaultName = newVaultName;
    return true;
  }

  /**
   * Changes the name of a secret in a vault
   *
   * @throws ErrorGitFile is the currSecretName or newSecretName is '.git'
   * @throws ErrorSecretDefined if the new name of the secret already exists
   * @param currSecretName current name of the secret
   * @param newSecretName new name of the secret
   * @return true if the new secret name exists in the directory
   */
  public async renameSecret(
    currSecretName: string,
    newSecretName: string,
  ): Promise<boolean> {
    if (currSecretName === '.git' || newSecretName === '.git') {
      throw new errors.ErrorGitFile('Cannot rename a file to or from .git');
    }
    const release = await this.mutex.acquire();
    try {
      if (
        this.efs.existsSync(
          path.join(this.baseDir, this.vaultName, newSecretName),
        )
      ) {
        throw new errors.ErrorSecretDefined(`${newSecretName} already exists`);
      }
      this.efs.rename(
        `${this.baseDir}/${this.vaultName}/${currSecretName}`,
        `${this.baseDir}/${this.vaultName}/${path.dirname(
          currSecretName,
        )}/${newSecretName}`,
      );
      this.logger.info(
        `Renamed secret at '${this.baseDir}/${this.vaultName}/${currSecretName}' to '${this.baseDir}/${this.vaultName}/${newSecretName}'`,
      );
    } finally {
      release();
    }
    if (
      fs.existsSync(path.join(this.baseDir, this.vaultName, currSecretName)) ||
      !fs.existsSync(path.join(this.baseDir, this.vaultName, newSecretName))
    ) {
      return false;
    }
    return true;
  }

  /**
   * Retrieves a list of the secrets in a vault
   *
   * @returns a list of the curent secrets
   */
  public async listSecrets(): Promise<Array<string>> {
    const secrets: Array<string> = [];
    for await (const secret of vaultsUtils.readdirRecursivelyEFS(
      this.efs,
      path.join(this.baseDir, this.vaultName),
    )) {
      if (path.basename(secret) != 'nodePermissions') {
        secrets.push(
          path.relative(path.join(this.baseDir, this.vaultName), secret),
        );
      }
    }
    return secrets;
  }

  /**
   * Returns the contents of a secret
   * @throws ErrorSecretUndefined if secret with specified name does not exist
   * @param secretName name of secret
   * @param secretDir dir secret is in, defaults to root
   * @returns Buffer or string representing the contents of the secret
   */
  public async getSecret(
    secretName: string,
    secretDir: string = '',
  ): Promise<Buffer | string> {
    const secretPath = path.join(
      this.baseDir,
      this.vaultName,
      secretDir,
      secretName,
    );
    try {
      return this.efs.readFileSync(secretPath);
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new errors.ErrorSecretUndefined(
          `Secret with name: ${secretName} does not exist`,
        );
      }
      throw err;
    }
  }

  /**
   * Removes a secret from a vault
   * @throws ErrorGitFile if secretName is '.git'
   * @throws ErrorRecursiveDelete if the specified secret is a directory but
   * the deletion is not recursive
   * @throws ErrorSecretUdefined if the secret does not exist
   * @param secretName name of the secret
   * @param recursive if the deletion should be recursive
   * @returns true if the secret no longer exists in the vault directory
   */
  public async deleteSecret(
    secretName: string,
    recursive: boolean,
  ): Promise<boolean> {
    if (secretName === '.git') {
      throw new errors.ErrorGitFile('Cannot remove .git');
    }
    const release = await this.mutex.acquire();
    // make secret path
    const secretPath = path.join(this.baseDir, this.vaultName, secretName);
    try {
      if (this.efs.existsSync(secretPath)) {
        // Remove from fs
        await this.efs.promises.unlink(secretPath);
        // Delete dir if it is empty
        const dirname = path.dirname(secretPath);
        if (
          path.join(this.baseDir, this.vaultName) != dirname &&
          (await this.efs.promises.readdir(dirname)).length == 0
        ) {
          await this.efs.promises.rmdir(dirname, { recursive: true });
          this.logger.info(`Deleted directory at '${secretPath}'`);
        }
        // Auto commit message
        await this.commitChanges(
          [{ fileName: secretName, action: 'removed' }],
          `Remove secret: ${secretName}`,
        );
      } else if ((await this.efs.promises.stat(secretPath)).isDirectory()) {
        if (recursive) {
          await this.efs.promises.rmdir(secretPath, { recursive: true });
          this.logger.info(`Deleted directory at '${secretPath}'`);
          await this.commitChanges(
            [{ fileName: secretName, action: 'removed' }],
            `Remove directory: ${secretName}`,
          );
        } else {
          throw new errors.ErrorRecursive(
            'delete a vault directory must be recursive',
          );
        }
      } else {
        throw new errors.ErrorSecretUndefined(
          'path: ' + secretName + ' does not exist in vault',
        );
      }
    } finally {
      release();
    }
    if (fs.existsSync(secretPath)) {
      return false;
    }
    return true;
  }

  /* === Helpers === */

  /**
   * Commits the changes made to a vault repository
   *
   * @param fileChanges changes that have been made to files
   * @param message description of change
   * @returns a commit message
   */
  private async commitChanges(
    fileChanges: FileChanges,
    message: string,
  ): Promise<string> {
    for (const fileChange of fileChanges) {
      if (fileChange.action == 'removed') {
        await git.remove({
          fs: { promises: this.efs.promises },
          dir: path.join(this.baseDir, this.vaultName),
          filepath: fileChange.fileName,
        });
      } else {
        await git.add({
          fs: { promises: this.efs.promises },
          dir: path.join(this.baseDir, this.vaultName),
          filepath: fileChange.fileName,
        });
      }
    }

    return await git.commit({
      fs: { promises: this.efs.promises },
      dir: path.join(this.baseDir, this.vaultName),
      author: {
        name: this.vaultName,
      },
      message: message,
    });
  }

  /**
   * Writes out the stored node permissions
   */
  private writeNodePermissions(): void {
    // Create and write metadata
    this.efs.writeFileSync(
      path.join(this.baseDir, this.vaultName, 'nodePermissions'),
      JSON.stringify(this.nodePermissions),
    );
    this.logger.info(
      `Wrote node permissions at '${path.join(
        this.baseDir,
        'nodePermissions',
      )}'`,
    );
  }

  /**
   * Loads the node permissions
   */
  private loadNodePermissions(): void {
    // Load the node permissions from exisitng metadata, otherwise create it
    if (
      this.efs.existsSync(
        path.join(this.baseDir, this.vaultName, 'nodePermissions'),
      )
    ) {
      const fileContents = this.efs
        .readFileSync(
          path.join(this.baseDir, this.vaultName, 'nodePermissions'),
        )
        .toString();
      this.nodePermissions = JSON.parse(fileContents);
    } else {
      this.writeNodePermissions();
    }
  }
}

export default Vault;
