import type { FileSystem } from '../types';
import type {
  FileChanges,
  VaultKey,
  VaultName,
  VaultId,
  SecretName,
  SecretList,
  FileOptions,
} from './types';
import type { NodeId } from '../nodes/types';
import type { WorkerManager } from '../workers';

import fs from 'fs';
import path from 'path';
import git from 'isomorphic-git';
import { Mutex } from 'async-mutex';
import { EncryptedFS } from 'encryptedfs';
import { PassThrough } from 'readable-stream';
import Logger from '@matrixai/logger';

import { GitRequest } from '../git';

import * as utils from '../utils';
import { utils as gitUtils } from '../git';
import * as vaultsUtils from './utils';
import { errors as vaultsErrors } from './';

class Vault {
  public readonly baseDir: string;
  public readonly vaultId: VaultId;

  public vaultName: VaultName;
  protected fs: FileSystem;
  protected efs: EncryptedFS;
  protected lock: Mutex = new Mutex();
  protected logger: Logger;
  protected workerManager?: WorkerManager;
  protected _started: boolean;

  constructor({
    vaultId,
    vaultName,
    baseDir,
    fs,
    logger,
  }: {
    vaultId: VaultId;
    vaultName: VaultName;
    baseDir: string;
    fs: FileSystem;
    logger?: Logger;
  }) {
    this.vaultId = vaultId;
    this.vaultName = vaultName;
    this.baseDir = baseDir;
    this.fs = fs;
    this.logger = logger ?? new Logger(this.constructor.name);
    this._started = false;
  }

  get started(): boolean {
    return this._started;
  }

  public setWorkerManager(workerManager: WorkerManager): void {
    this.workerManager = workerManager;
    this.efs.setWorkerManager(workerManager);
  }

  public unsetWorkerManager(): void {
    delete this.workerManager;
    this.efs.unsetWorkerManager();
  }

  // TODO: Once EFS is updated, pass `this.fs` into EFS constructor
  public async start({ key }: { key: VaultKey }): Promise<void> {
    const efs = new EncryptedFS(key, fs, this.baseDir);
    this.efs = efs;
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    this.logger.info(`Created vault directory at ${this.baseDir}`);

    if (!(await exists('.git'))) {
      const release = await this.lock.acquire();
      try {
        await git.init({
          fs: this.efs,
          dir: '',
        });

        await git.commit({
          fs: this.efs,
          dir: '',
          author: {
            name: this.vaultId,
          },
          message: 'Initial Commit',
        });

        // pack-refs not auto-generated by isomorphic git but needed
        const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
        await writeFile(
          path.join('.git', 'packed-refs'),
          '# pack-refs with: peeled fully-peeled sorted',
        );
        this.logger.info(
          `Writing initial vault commit at '${path.join(
            '.git',
            'packed-refs',
          )}'`,
        );
      } finally {
        release();
      }
    }
  }

  public async stop(): Promise<void> {
    const release = await this.lock.acquire();
    try {
      await fs.promises.rmdir(this.baseDir, { recursive: true });
      this.logger.info(`Destroyed vault directory at ${this.baseDir}`);
    } finally {
      release();
    }
  }

  /**
   * Renames the vault, does not effect the underlying fs name
   *
   * @param newVaultName name to change to
   */
  public async renameVault(newVaultName: VaultName): Promise<void> {
    this.vaultName = newVaultName;
  }

  /**
   * Retreives stats for a vault
   *
   * @returns the stats of the vault directory
   */
  public async stats(): Promise<fs.Stats> {
    return await this.fs.promises.stat(this.baseDir);
  }

  /**
   * Adds a secret to the vault
   *
   * @throws ErrorVaultUninitialised if the vault repository has
   * not been initialised
   * @throws ErrorSecretDefined if the secret name matches an existing file
   * @throws ErrorGitFile if the secret added is a .git file
   * @param secretName full path of the secret to add
   * @param content content of the secret to add
   * @param secretPath path of directory to store secret
   * @returns true if the secret exists in the vault directory
   */
  public async addSecret(
    secretName: SecretName,
    content: string,
  ): Promise<boolean> {
    const release = await this.lock.acquire();
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
    const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);
    try {
      // Throw an error if the vault is not initialised
      if (!(await exists('.git'))) {
        throw new vaultsErrors.ErrorVaultUninitialised(
          `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
        );
        // Throw an error if the secret exists
      } else if (await exists(secretName)) {
        throw new vaultsErrors.ErrorSecretDefined(
          `${secretName} already exists, try updating instead`,
        );
        // Throw an error if the secret contains a '.git' dir
      } else if (path.basename(secretName) === '.git') {
        throw new vaultsErrors.ErrorGitFile(
          '.git files cannot be added to a vault',
        );
      }

      // Create the directory to the secret if it doesn't exist
      await mkdir(path.dirname(secretName), {
        recursive: true,
      });

      // Write the secret into the vault
      await writeFile(secretName, content, {});
      this.logger.info(`Wrote secret to directory at '${secretName}'`);

      // Commit the changes
      await this.commitChanges(
        [
          {
            fileName: secretName,
            action: 'added',
          },
        ],
        `Add secret: ${secretName}`,
      );
      if (await exists(secretName)) {
        return true;
      }
      return false;
    } finally {
      release();
    }
  }

  /**
   * Changes the contents of a secret
   * @throws ErrorSecretUndefined if the secret name does not match
   * an existing file
   * @param secretName name of the secret to update
   * @param content content of the secret to update
   */
  public async updateSecret(
    secretName: SecretName,
    content: string,
  ): Promise<void> {
    const release = await this.lock.acquire();
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
    try {
      // Throw error if secret does not exist
      if (!(await exists(secretName))) {
        throw new vaultsErrors.ErrorSecretUndefined(
          'Secret does not exist, try adding it instead.',
        );
      }

      // Write secret into vault
      await writeFile(secretName, content, {});
      this.logger.info(`Updated secret at directory '${secretName}'`);

      // Commit changes
      await this.commitChanges(
        [{ fileName: secretName, action: 'modified' }],
        `Update secret: ${secretName}`,
      );
    } finally {
      release();
    }
  }

  /**
   * Changes the name of a secret in a vault
   *
   * @throws ErrorGitFile is the currSecretName or newSecretName is '.git'
   * @throws ErrorSecretDefined if the new name of the secret already exists
   * @param currSecretName current name of the secret (full path)
   * @param newSecretName new name of the secret (full path)
   * @return true if the new secret name exists in the directory
   */
  public async renameSecret(
    currSecretName: SecretName,
    newSecretName: SecretName,
  ): Promise<boolean> {
    const release = await this.lock.acquire();
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const rename = utils.promisify(this.efs.rename).bind(this.efs);
    try {
      // Throw error if trying to rename a '.git' file
      if (
        path.basename(currSecretName) === '.git' ||
        path.basename(newSecretName) === '.git'
      ) {
        throw new vaultsErrors.ErrorGitFile(
          'Cannot rename a file to or from .git',
        );
      }

      // Throw an error if the old secret does not exist
      if (!(await exists(currSecretName))) {
        throw new vaultsErrors.ErrorSecretUndefined(
          `${currSecretName} does not exist`,
        );
      }

      // Throw an error if the new name already exists
      if (await exists(newSecretName)) {
        throw new vaultsErrors.ErrorSecretDefined(
          `${newSecretName} already exists`,
        );
      }

      // Renames the secret in the vault
      await rename(currSecretName, newSecretName);
      this.logger.info(
        `Renamed secret at ${currSecretName} to ${newSecretName}`,
      );
      // Commit changes
      await this.commitChanges(
        [
          {
            fileName: currSecretName,
            action: 'removed',
          },
          {
            fileName: newSecretName,
            action: 'added',
          },
        ],
        `Renamed secret: ${currSecretName}`,
      );
      if ((await exists(currSecretName)) || !(await exists(newSecretName))) {
        return false;
      }
      return true;
    } finally {
      release();
    }
  }

  /**
   * Returns the contents of a secret
   * @throws ErrorSecretUndefined if secret with specified name does not exist
   * @param secretName name of secret including the path.
   * @returns Buffer or string representing the contents of the secret
   */
  public async getSecret(secretName: SecretName): Promise<string> {
    const release = await this.lock.acquire();
    const readFile = utils.promisify(this.efs.readFile).bind(this.efs);
    try {
      return (await readFile(secretName)).toString();
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new vaultsErrors.ErrorSecretUndefined(
          `Secret with name: ${secretName} does not exist`,
        );
      }
      throw err;
    } finally {
      release();
    }
  }

  /**
   * Removes a secret from a vault
   * @throws ErrorGitFile if secretName is '.git'
   * @throws ErrorRecursiveDelete if the specified secret is a directory but
   * the deletion is not recursive
   * @throws ErrorSecretUdefined if the secret does not exist
   * @param secretName name of the secret
   * @param recursive if the deletion should be recursive
   * @returns true if the secret no longer exists in the vault directory
   */
  public async deleteSecret(
    secretName: SecretName,
    fileOptions?: FileOptions,
  ): Promise<boolean> {
    const release = await this.lock.acquire();
    const stat = utils.promisify(this.efs.stat).bind(this.efs);
    const rmdir = utils.promisify(this.efs.rmdir).bind(this.efs);
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const unlink = utils.promisify(this.efs.unlink).bind(this.efs);
    try {
      // Throw error if trying to remove '.git' file
      if (path.basename(secretName) === '.git') {
        throw new vaultsErrors.ErrorGitFile('Cannot remove .git');
      }
      // Handle if secret is a directory
      if ((await stat(secretName)).isDirectory()) {
        if (fileOptions?.recursive) {
          // Remove the specified directory
          await rmdir(secretName, { recursive: true });
          this.logger.info(`Deleted directory at '${secretName}}'`);
          await this.commitChanges(
            [
              {
                fileName: secretName,
                action: 'removed',
              },
            ],
            `Remove directory: ${secretName}`,
          );
          // Throw error if not recursively deleting a directory
        } else {
          throw new vaultsErrors.ErrorRecursive(
            'delete a vault directory must be recursive',
          );
        }
      } else if (await exists(secretName)) {
        await unlink(secretName);

        // Commit changes
        await this.commitChanges(
          [
            {
              fileName: secretName,
              action: 'removed',
            },
          ],
          `Remove secret: ${secretName}`,
        );
        // Throw error if secret doesn't exist
      } else {
        throw new vaultsErrors.ErrorSecretUndefined(
          'path: ' + secretName + ' does not exist in vault',
        );
      }
      if (await exists(secretName)) {
        return false;
      }
      return true;
    } finally {
      release();
    }
  }

  /**
   * Adds an empty directory to the root of the vault.
   * i.e. mkdir("folder", {recursive = false}) creates the "<vaultDir>/folder" directory
   *
   * @param path path of the directory
   * @param recursive determines if the directory is added recursively
   * @returns true if the dir exists in the vault directory
   */
  public async mkdir(
    dirPath: SecretName,
    fileOptions?: FileOptions,
  ): Promise<boolean> {
    const release = await this.lock.acquire();
    const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    try {
      // Create the specified directory
      const recursive = fileOptions?.recursive ?? false;
      try {
        await mkdir(dirPath, { recursive: recursive });
      } catch (err) {
        if (err.code === 'ENOENT' && !recursive) {
          throw new vaultsErrors.ErrorRecursive(
            `Could not create directory '${dirPath}' without recursive option`,
          );
        }
      }
      this.logger.info(`Created secret directory at '${dirPath}'`);
      if (await exists(dirPath)) {
        return true;
      }
      return false;
    } finally {
      release();
    }
  }

  /**
   * Adds a secret directory to the vault
   *
   * @throws ErrorVaultUninitialised if the vault repository has
   * not been initialised
   * @throws ErrorGitFile if the secret added is a .git file
   * @param secretDirectory on disk path to directory of secrets to be added
   */
  public async addSecretDirectory(secretDirectory: SecretName): Promise<void> {
    const release = await this.lock.acquire();
    const commitList: FileChanges = [];
    const absoluteDirPath = path.resolve(secretDirectory);
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
    const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);
    try {
      for await (const secretPath of vaultsUtils.readdirRecursively(
        absoluteDirPath,
      )) {
        // Determine the path to the secret
        const relPath = path.relative(
          path.dirname(absoluteDirPath),
          secretPath,
        );
        const secretName = path.basename(secretPath);
        const content = await fs.promises.readFile(secretPath);
        // Throw error if the '.git' file is nonexistent
        if (!(await exists('.git'))) {
          throw new vaultsErrors.ErrorVaultUninitialised(
            `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
          );
          // Throw error if trying to add '.git' file
        } else if (secretName === '.git') {
          throw new vaultsErrors.ErrorGitFile(
            '`.git files cannot be added to a vault',
          );
          // If existing path exists, write secret
        } else if (await exists(relPath)) {
          try {
            await writeFile(relPath, content, {});
            this.logger.info(`Updated secret at directory '${relPath}'`);
            commitList.push({
              fileName: relPath,
              action: 'modified',
            });
          } catch (err) {
            this.logger.warn(`Adding secret ${relPath} failed`);
          }
        } else {
          try {
            // Create the directory if it doesn't exist
            await mkdir(path.dirname(relPath), {
              recursive: true,
            });
            // Write secret into the vault
            await writeFile(relPath, content, {});
            this.logger.info(`Wrote secret to directory at '${relPath}'`);
            commitList.push({
              fileName: relPath,
              action: 'added',
            });
          } catch (err) {
            this.logger.warn(`Adding secret ${relPath} failed`);
          }
        }
      }

      // Commit changes
      await this.commitChanges(
        commitList,
        `Add/Modify secrets: ${commitList[0].fileName} and ${
          commitList.length - 1
        } more`,
      );
    } finally {
      release();
    }
  }

  /**
   * Retrieves a list of the secrets in a vault
   *
   * @returns a list of the curent secrets
   */
  public async listSecrets(): Promise<SecretList> {
    const secrets: SecretList = [];
    for await (const secret of vaultsUtils.readdirRecursivelyEFS(
      this.efs,
      '',
    )) {
      secrets.push(secret);
    }
    return secrets;
  }

  /**
   * Clones secrets from a remote vault into this vault
   * TODO: Once EFS is updated, pass `this.fs` into EFS constructor
   */
  public async cloneVault(
    gitHandler: GitRequest,
    vaultKey: VaultKey,
    nodeId: NodeId,
  ): Promise<void> {
    const efs = new EncryptedFS(vaultKey, fs, this.baseDir);
    this.efs = efs;
    await git.clone({
      fs: this.efs,
      http: gitHandler,
      dir: '',
      url: `http://0.0.0.0/${vaultsUtils.splitVaultId(this.vaultId)}:${nodeId}`,
      ref: 'master',
      singleBranch: true,
    });
    // pack-refs not auto-generated by isomorphic git but needed
    const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
    await writeFile(
      path.join('.git', 'packed-refs'),
      '# pack-refs with: peeled fully-peeled sorted',
    );
    this.logger.info(
      `Writing initial vault clone commit at '${path.join(
        '.git',
        'packed-refs',
      )}'`,
    );
  }

  /**
   * Pulls secrets from a remote vault into this vault
   */
  public async pullVault(
    gitHandler: GitRequest,
    nodeId: NodeId,
  ): Promise<void> {
    // Throw an error if merge conflicts occur
    try {
      await git.pull({
        fs: this.efs,
        http: gitHandler,
        dir: '',
        url: `http://0.0.0.0/${vaultsUtils.splitVaultId(
          this.vaultId,
        )}:${nodeId}`,
        ref: 'HEAD',
        singleBranch: true,
        author: {
          name: this.vaultId,
        },
      });
    } catch (err) {
      if (err instanceof git.Errors.MergeNotSupportedError) {
        throw new vaultsErrors.ErrorVaultMergeConflict(
          'Merge Conflicts are not supported yet',
        );
      }
    }
  }

  /**
   * Returns an async generator that yields buffers representing the git info response
   * @param vaultName Name of vault
   */
  public async *handleInfoRequest(): AsyncGenerator<Buffer | null> {
    // Service for uploading packets
    const service = 'upload-pack';
    // define the service
    yield Buffer.from(
      gitUtils.createGitPacketLine('# service=git-' + service + '\n'),
    );

    yield Buffer.from('0000');

    for (const buffer of (await gitUtils.uploadPack(this.efs, '.git', true)) ??
      []) {
      yield buffer;
    }
  }

  /**
   * Takes vaultName and a pack request and returns two streams used to handle the pack
   * response
   * @param vaultName name of the vault
   * @param body body of pack request
   * @returns Two streams used to send the pack response
   */
  public async handlePackRequest(body: Buffer): Promise<PassThrough[]> {
    if (body.toString().slice(4, 8) === 'want') {
      const wantedObjectId = body.toString().slice(9, 49);
      const packResult = await gitUtils.packObjects(this.efs, '.git', [
        wantedObjectId,
      ]);
      const readable = new PassThrough();
      const progressStream = new PassThrough();
      const sideBand = gitUtils.mux(
        'side-band-64',
        readable,
        packResult.packstream,
        progressStream,
      );
      return [sideBand, progressStream];
    } else {
      throw new Error('Method not implemented');
    }
  }

  /* === Helpers === */

  /**
   * Commits the changes made to a vault repository
   *
   * @param fileChanges changes that have been made to files
   * @param message description of change
   * @returns a commit message
   */
  protected async commitChanges(
    fileChanges: FileChanges,
    message: string,
  ): Promise<void> {
    // Obtain each file change
    for (const fileChange of fileChanges) {
      if (fileChange.action === 'removed') {
        await git.remove({
          fs: this.efs,
          dir: '',
          filepath: fileChange.fileName,
        });
      } else {
        await git.add({
          fs: this.efs,
          dir: '',
          filepath: fileChange.fileName,
        });
      }
    }

    // Commit the changes made
    await git.commit({
      fs: this.efs,
      dir: '',
      author: {
        name: this.vaultId,
      },
      message: message,
    });
  }
}

export default Vault;
