import type { FileChanges } from './types';

import fs from 'fs';
import path from 'path';
import git from 'isomorphic-git';
import { Mutex } from 'async-mutex';
import { EncryptedFS } from 'encryptedfs';
import Logger from '@matrixai/logger';

import * as utils from '../utils';
import * as vaultsUtils from './utils';
import * as errors from './errors';

class Vault {
  public readonly baseDir: string;
  public readonly vaultId: string;
  public vaultName: string;
  private efs: EncryptedFS;
  private mutex: Mutex;
  protected logger: Logger;
  /**
   * Construct a vault object
   * @param vaultName Name of vault
   * @param baseDir Base path of vaults
   * @param key Vault Key
   * @param logger Logger
   */
  constructor({
    vaultId,
    vaultName,
    key,
    baseDir,
    logger,
  }: {
    vaultId: string;
    vaultName: string;
    key: Buffer;
    baseDir: string;
    logger?: Logger;
  }) {
    this.vaultId = vaultId;
    this.vaultName = vaultName;
    this.logger = logger ?? new Logger('Vault');
    this.baseDir = baseDir;
    this.efs = new EncryptedFS(key, fs, this.baseDir);
    this.mutex = new Mutex();
  }

  public async create() {
    // make the vault directory
    const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);
    await mkdir(this.vaultId, {
      recursive: true,
    });
    this.logger.info(
      `Created vault directory at ${path.join(this.baseDir, this.vaultId)}`,
    );
  }

  public async destroy() {
    const rmdir = utils.promisify(this.efs.rmdir).bind(this.efs);
    await rmdir(this.vaultId, {
      recursive: true,
    });
    this.logger.info(
      `Destroyed vault directory at ${path.join(this.baseDir, this.vaultId)}`,
    );
  }

  public get EncryptedFS(): EncryptedFS {
    return this.efs;
  }

  /**
   * Creates the git repositiory for the vault
   */
  public async initializeVault(): Promise<void> {
    // Initialize repository for vault
    const efs = this.efs;

    // Init repository
    await git.init({
      fs: efs,
      dir: this.vaultId,
    });

    // Initial commit
    await git.commit({
      fs: efs,
      dir: this.vaultId,
      author: {
        name: this.vaultId,
      },
      message: 'Initial Commit',
    });

    // Write pack-refs file bcause isomorphic git goes searching for it and
    // apparently its not autogenerated
    const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
    await writeFile(
      path.join(this.vaultId, '.git', 'packed-refs'),
      '# pack-refs with: peeled fully-peeled sorted',
    );
    this.logger.info(
      `Writing initial vault commit at '${path.join(
        this.baseDir,
        this.vaultId,
        '.git',
        'packed-refs',
      )}'`,
    );
  }

  /**
   * Adds an empty directory to the root of the vault.
   * i.e. mkdir("folder", {recursive = false}) creates the "<vaultDir>/folder" directory
   *
   * @param path path of the directory
   * @param recursive determines if the directory is added recursively
   */
  public async mkdir(
    dirPath: string,
    { recursive = false }: { recursive: boolean },
  ): Promise<void> {
    try {
      if (
        (await git.getConfig({
          fs: this.efs,
          dir: this.vaultId,
          path: 'remote.origin.url',
        })) != undefined &&
        (await git.currentBranch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
        })) === 'master'
      ) {
        await git.branch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
          ref: 'changes',
          checkout: true,
        });
      }
    } catch {
      throw new errors.ErrorVaultUninitialised(
        `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
      );
    }
    const newDir = path.join(this.vaultId, dirPath);
    const release = await this.mutex.acquire();
    try {
      const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);
      await mkdir(newDir, { recursive: recursive });
    } finally {
      release();
    }
  }

  /**
   * Adds a secret to the vault
   *
   * @throws ErrorVaultUninitialised if the vault repository has
   * not been initialised
   * @throws ErrorSecretDefined if the secret name matches an existing file
   * @throws ErrorGitFile if the secret added is a .git file
   * @param secretName full path of the secret to add
   * @param content content of the secret to add
   * @param secretPath path of directory to store secret
   * @returns true if the secret exists in the vault directory
   */
  public async addSecret(
    secretName: string,
    content: Buffer,
  ): Promise<boolean> {
    const secretPath = path.join(this.vaultId, secretName);
    const release = await this.mutex.acquire();
    try {
      if (
        (await git.getConfig({
          fs: this.efs,
          dir: this.vaultId,
          path: 'remote.origin.url',
        })) != undefined &&
        (await git.currentBranch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
        })) === 'master'
      ) {
        await git.branch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
          ref: 'changes',
          checkout: true,
        });
      }
    } catch {
      throw new errors.ErrorVaultUninitialised(
        `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
      );
    }
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    try {
      if (!(await exists(path.join(this.vaultId, '.git')))) {
        throw new errors.ErrorVaultUninitialised(
          `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
        );
      } else if (await exists(secretPath)) {
        // throw error if secret exists
        throw new errors.ErrorSecretDefined(
          `${secretName} already exists, try updating instead`,
        );
      } else if (path.basename(secretName) === '.git') {
        throw new errors.ErrorGitFile('`.git files cannot be added to a vault');
      }
      // create the directory if it doesn't exist
      const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);
      await mkdir(path.dirname(secretPath), {
        recursive: true,
      });

      // Write secret
      const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
      await writeFile(secretPath, content, {});
      this.logger.info(
        `Wrote secret to directory at '${this.baseDir}/${secretPath}'`,
      );

      // Auto commit message
      await this.commitChanges(
        [
          {
            fileName: path.relative(this.vaultId, secretPath),
            action: 'added',
          },
        ],
        `Add secret: ${secretName}`,
      );
    } finally {
      release();
    }

    if (await exists(secretPath)) {
      return true;
    }
    return false;
  }

  /**
   * Adds a secret directory to the vault
   *
   * @throws ErrorVaultUninitialised if the vault repository has
   * not been initialised
   * @throws ErrorGitFile if the secret added is a .git file
   * @param secretDirectory on disk path to directory of secrets to be added
   */
  public async addSecretDirectory(secretDirectory: string): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      try {
        if (
          (await git.getConfig({
            fs: this.efs,
            dir: this.vaultId,
            path: 'remote.origin.url',
          })) != undefined &&
          (await git.currentBranch({
            fs: this.EncryptedFS,
            dir: this.vaultId,
          })) === 'master'
        ) {
          await git.branch({
            fs: this.EncryptedFS,
            dir: this.vaultId,
            ref: 'changes',
            checkout: true,
          });
        }
      } catch {
        throw new errors.ErrorVaultUninitialised(
          `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
        );
      }
      const commitList: FileChanges = [];
      const absoluteDirPath = path.resolve(secretDirectory);

      const exists = utils.promisify(this.efs.exists).bind(this.efs);
      const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);
      const mkdir = utils.promisify(this.efs.mkdir).bind(this.efs);

      for await (const secretPath of vaultsUtils.readdirRecursively(
        absoluteDirPath,
      )) {
        const relPath = path.relative(
          path.dirname(absoluteDirPath),
          secretPath,
        );
        // get rid of the root path to each secret
        const secretName = path.basename(secretPath);
        const content = await fs.promises.readFile(secretPath);
        if (!(await exists(path.join(this.vaultId, '.git')))) {
          throw new errors.ErrorVaultUninitialised(
            `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
          );
        } else if (await exists(path.join(this.vaultId, relPath))) {
          try {
            const writePath = path.join(this.vaultId, relPath);
            // Write secret
            await writeFile(writePath, content, {});
            this.logger.info(
              `Updated secret at directory '${this.baseDir}/${writePath}'`,
            );
            commitList.push({ fileName: relPath, action: 'modified' });
          } catch (err) {
            this.logger.warn(`Adding secret ${relPath} failed`);
          }
        } else if (secretName === '.git') {
          throw new errors.ErrorGitFile(
            '`.git files cannot be added to a vault',
          );
        } else {
          try {
            const writePath = path.join(this.vaultId, relPath);
            // create the directory if it doesn't exist
            await mkdir(path.dirname(writePath), {
              recursive: true,
            });
            // Write secret
            await writeFile(writePath, content, {});
            this.logger.info(
              `Wrote secret to directory at '${this.baseDir}/${writePath}'`,
            );
            commitList.push({ fileName: relPath, action: 'added' });
          } catch (err) {
            this.logger.warn(`Adding secret ${relPath} failed`);
          }
        }
      }

      // Auto commit message
      await this.commitChanges(
        commitList,
        `Add/Modify secrets: ${commitList[0].fileName} and ${
          commitList.length - 2
        } more`,
      );
    } finally {
      release();
    }
  }

  /**
   * Changes the contents of a secret
   * @throws ErrorSecretUndefined if the secret name does not match
   * an existing file
   * @param secretName name of the secret to update
   * @param content content of the secret to update
   */
  public async updateSecret(
    secretName: string,
    content: Buffer,
  ): Promise<void> {
    try {
      if (
        (await git.getConfig({
          fs: this.efs,
          dir: this.vaultId,
          path: 'remote.origin.url',
        })) != undefined &&
        (await git.currentBranch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
        })) === 'master'
      ) {
        await git.branch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
          ref: 'changes',
          checkout: true,
        });
      }
    } catch {
      throw new errors.ErrorVaultUninitialised(
        `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
      );
    }
    const release = await this.mutex.acquire();

    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const writeFile = utils.promisify(this.efs.writeFile).bind(this.efs);

    try {
      // Check if secret already exists
      if (!(await exists(path.join(this.vaultId, secretName)))) {
        throw new errors.ErrorSecretUndefined(
          'Secret does not exist, try adding it instead.',
        );
      }
      const writePath = path.join(this.vaultId, secretName);
      // Write secret
      await writeFile(writePath, content, {});

      this.logger.info(
        `Updated secret at directory '${this.baseDir}/${writePath}'`,
      );

      // Auto commit message
      await this.commitChanges(
        [{ fileName: secretName, action: 'modified' }],
        `Update secret: ${secretName}`,
      );
    } finally {
      release();
    }
  }

  /**
   * Renames the vault, does not effect the underlying fs name
   *
   * @param newVaultName name to change to
   * @returns true if the new name exists in the directory
   */
  public async renameVault(newVaultName: string): Promise<boolean> {
    this.vaultName = newVaultName;
    return true;
  }

  /**
   * Changes the name of a secret in a vault
   *
   * @throws ErrorGitFile is the currSecretName or newSecretName is '.git'
   * @throws ErrorSecretDefined if the new name of the secret already exists
   * @param currSecretName current name of the secret (full path)
   * @param newSecretName new name of the secret (full path)
   * @return true if the new secret name exists in the directory
   */
  public async renameSecret(
    currSecretName: string,
    newSecretName: string,
  ): Promise<boolean> {
    try {
      if (
        (await git.getConfig({
          fs: this.efs,
          dir: this.vaultId,
          path: 'remote.origin.url',
        })) != undefined &&
        (await git.currentBranch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
        })) === 'master'
      ) {
        await git.branch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
          ref: 'changes',
          checkout: true,
        });
      }
    } catch {
      throw new errors.ErrorVaultUninitialised(
        `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
      );
    }
    if (
      path.basename(currSecretName) === '.git' ||
      path.basename(newSecretName) === '.git'
    ) {
      throw new errors.ErrorGitFile('Cannot rename a file to or from .git');
    }
    const release = await this.mutex.acquire();

    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const rename = utils.promisify(this.efs.rename).bind(this.efs);

    try {
      if (await exists(path.join(this.baseDir, this.vaultId, newSecretName))) {
        throw new errors.ErrorSecretDefined(`${newSecretName} already exists`);
      }
      await rename(
        path.join(this.vaultId, currSecretName),
        path.join(this.vaultId, newSecretName),
      );

      this.logger.info(
        `Renamed secret at ${path.join(
          this.baseDir,
          this.vaultId,
          currSecretName,
        )} to ${path.join(this.baseDir, this.vaultId, newSecretName)}`,
      );
    } finally {
      release();
    }
    if (
      (await exists(path.join(this.vaultId, currSecretName))) ||
      !(await exists(path.join(this.vaultId, newSecretName)))
    ) {
      return false;
    }
    return true;
  }

  /**
   * Retrieves a list of the secrets in a vault
   *
   * @returns a list of the curent secrets
   */
  public async listSecrets(): Promise<Array<string>> {
    const secrets: Array<string> = [];
    for await (const secret of vaultsUtils.readdirRecursivelyEFS(
      this.efs,
      this.vaultId,
    )) {
      if (path.basename(secret) != 'nodePermissions') {
        secrets.push(path.relative(path.join(this.vaultId), secret));
      }
    }
    return secrets;
  }

  /**
   * Returns the contents of a secret
   * @throws ErrorSecretUndefined if secret with specified name does not exist
   * @param secretName name of secret including the path.
   * @returns Buffer or string representing the contents of the secret
   */
  public async getSecret(secretName: string): Promise<Buffer | string> {
    const secretPath = path.join(this.vaultId, secretName);
    const readFile = utils.promisify(this.efs.readFile).bind(this.efs);

    try {
      return await readFile(secretPath);
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new errors.ErrorSecretUndefined(
          `Secret with name: ${secretName} does not exist`,
        );
      }
      throw err;
    }
  }

  /**
   * Removes a secret from a vault
   * @throws ErrorGitFile if secretName is '.git'
   * @throws ErrorRecursiveDelete if the specified secret is a directory but
   * the deletion is not recursive
   * @throws ErrorSecretUdefined if the secret does not exist
   * @param secretName name of the secret
   * @param recursive if the deletion should be recursive
   * @returns true if the secret no longer exists in the vault directory
   */
  public async deleteSecret(
    secretName: string,
    recursive: boolean,
  ): Promise<boolean> {
    try {
      if (
        (await git.getConfig({
          fs: this.efs,
          dir: this.vaultId,
          path: 'remote.origin.url',
        })) != undefined &&
        (await git.currentBranch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
        })) === 'master'
      ) {
        await git.branch({
          fs: this.EncryptedFS,
          dir: this.vaultId,
          ref: 'changes',
          checkout: true,
        });
      }
    } catch {
      throw new errors.ErrorVaultUninitialised(
        `${this.vaultName} has not been initialised\nVaultId: ${this.vaultId}`,
      );
    }
    if (path.basename(secretName) === '.git') {
      throw new errors.ErrorGitFile('Cannot remove .git');
    }
    const release = await this.mutex.acquire();
    // make secret path
    const secretPath = path.join(this.vaultId, secretName);

    const stat = utils.promisify(this.efs.stat).bind(this.efs);
    const rmdir = utils.promisify(this.efs.rmdir).bind(this.efs);
    const exists = utils.promisify(this.efs.exists).bind(this.efs);
    const unlink = utils.promisify(this.efs.unlink).bind(this.efs);
    const readdir = utils.promisify(this.efs.readdir).bind(this.efs);

    try {
      if ((await stat(secretPath)).isDirectory()) {
        if (recursive) {
          await rmdir(secretPath, { recursive: true });
          this.logger.info(
            `Deleted directory at '${this.baseDir}/${secretPath}'`,
          );
          await this.commitChanges(
            [{ fileName: secretName, action: 'removed' }],
            `Remove directory: ${secretName}`,
          );
        } else {
          throw new errors.ErrorRecursive(
            'delete a vault directory must be recursive',
          );
        }
      } else if (await exists(secretPath)) {
        // Remove from fs
        await unlink(secretPath);
        // Delete dir if it is empty
        const dirname = path.dirname(secretPath);
        if (
          path.join(this.baseDir, this.vaultId) != dirname &&
          (await readdir(dirname).length) == 0
        ) {
          await rmdir(dirname, { recursive: true });
          this.logger.info(
            `Deleted directory at '${this.baseDir}/${secretPath}'`,
          );
        }
        // Auto commit message
        await this.commitChanges(
          [{ fileName: secretName, action: 'removed' }],
          `Remove secret: ${secretName}`,
        );
      } else {
        throw new errors.ErrorSecretUndefined(
          'path: ' + secretName + ' does not exist in vault',
        );
      }
    } finally {
      release();
    }
    if (await exists(secretPath)) {
      return false;
    }
    return true;
  }

  /* === Helpers === */

  /**
   * Commits the changes made to a vault repository
   *
   * @param fileChanges changes that have been made to files
   * @param message description of change
   * @returns a commit message
   */
  private async commitChanges(
    fileChanges: FileChanges,
    message: string,
  ): Promise<string> {
    for (const fileChange of fileChanges) {
      if (fileChange.action == 'removed') {
        await git.remove({
          fs: this.efs,
          dir: this.vaultId,
          filepath: fileChange.fileName,
        });
      } else {
        await git.add({
          fs: this.efs,
          dir: this.vaultId,
          filepath: fileChange.fileName,
        });
      }
    }

    return await git.commit({
      fs: this.efs,
      dir: this.vaultId,
      author: {
        name: this.vaultName,
      },
      message: message,
    });
  }
}

export default Vault;
