import fs from 'fs';
import path from 'path';
import git from 'isomorphic-git';
import { Mutex } from 'async-mutex';
import { VirtualFS } from 'virtualfs';
import { EncryptedFS } from 'encryptedfs';
import GitFrontend from '../git/GitFrontend';
import { JSONMapReplacer, JSONMapReviver, readdirRecursively } from '../utils';

interface NodeIdPermissions {
  nodeId: string;
  canEdit: boolean;
}

class Vault {
  private key: Buffer;
  name: string;
  private efs: EncryptedFS;
  vaultPath: string;
  private secrets: Map<string, any>;
  private sharedNodeIds: Map<string, NodeIdPermissions>;
  private metadataPath: string;

  private gitFrontend: GitFrontend;

  // Concurrency
  private mutex: Mutex = new Mutex();

  constructor(
    name: string,
    symKey: Buffer,
    baseDir: string,
    gitFrontend: GitFrontend,
  ) {
    // how do we create pub/priv key pair?
    // do we use the same gpg pub/priv keypair
    this.key = symKey;
    // Set filesystem
    const vfsInstance = new VirtualFS();

    this.efs = new EncryptedFS(this.key, vfsInstance, vfsInstance, fs, process);

    this.name = name;
    this.vaultPath = path.join(baseDir, name);
    // make the vault directory
    this.efs.mkdirSync(this.vaultPath, { recursive: true });
    this.secrets = new Map();

    this.gitFrontend = gitFrontend;

    // Load metadata
    this.metadataPath = path.join(this.vaultPath, '.vault', 'metadata');
    this.loadSecrets().then(() => {
      this.loadMetadata();
    });
  }

  async initializeVault(): Promise<void> {
    // Init repository for vault
    const efs = this.EncryptedFS;
    const fileSystem = { promises: efs.promises };
    // first make sure its not already initialized
    try {
      const statusMatrix = await git.statusMatrix({
        fs: fileSystem,
        dir: this.vaultPath,
      });
      if (statusMatrix == undefined) {
        return;
      }
    } catch (error) {
      return;
    }

    await git.init({
      fs: fileSystem,
      dir: this.vaultPath,
    });

    // Initial commit
    await git.commit({
      fs: fileSystem,
      dir: this.vaultPath,
      author: {
        name: this.name,
      },
      message: 'init commit',
    });
    // Write packed-refs file because isomorphic git goes searching for it
    // and apparently its not autogenerated
    efs.writeFileSync(
      path.join(this.vaultPath, '.git', 'packed-refs'),
      '# pack-refs with: peeled fully-peeled sorted',
    );
  }

  /**
   * Returns the Encrypted File System used for vault operations
   */
  public get EncryptedFS(): EncryptedFS {
    return this.efs;
  }

  /**
   * Determines whether a secret exists in the vault
   * @param secretName Name of desired secret
   */
  secretExists(secretName: string): boolean {
    const secretPath = path.join(this.vaultPath, secretName);
    return this.secrets.has(secretName) && this.efs.existsSync(secretPath);
  }

  /**
   * Rename the vault
   */
  async rename(newName: string): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      this.efs.renameSync(`../${this.name}`, `../${newName}`);
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  /**
   * Get the stats for the vault
   */
  async stats(): Promise<fs.Stats> {
    const release = await this.mutex.acquire();
    try {
      return this.efs.statSync(`../${this.name}`);
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  /**
   * Adds a secret to the vault
   * @param secretName Name of new secret
   * @param secret Content of new secret
   */
  async addSecret(secretName: string, secret: Buffer): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      await this.addSecretHelper(secretName, secret);

      // Auto commit message
      await this.commitChanges(
        [{ secretName, action: 'added' }],
        `Add secret: ${secretName}`,
      );
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  /**
   * Adds a directory of secrets to the vault
   * @param secretDirectoryPath Path to a directory of secrets
   */
  async addSecrets(secretDirectoryPath: string): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      const absoluteDirPath = path.resolve(secretDirectoryPath);
      // add secret one by one
      const commitList: {
        secretName: string;
        action: 'added' | 'modified' | 'removed';
      }[] = [];
      for await (const secretPath of readdirRecursively(absoluteDirPath)) {
        // get rid of the root path to each secret

        const secretName = secretPath.replace(`${absoluteDirPath}/`, '');
        const secret = fs.readFileSync(secretPath);
        await this.addSecretHelper(secretName, secret);
        commitList.push({ secretName, action: 'added' });
      }

      // Auto commit message
      await this.commitChanges(
        commitList,
        `Add secrets: ${commitList[0].secretName}, ${
          commitList[1].secretName
        } and ${commitList.length - 2} more`,
      );
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  private async addSecretHelper(secretName: string, secret: Buffer) {
    // Check if secret already exists
    if (this.secrets.has(secretName)) {
      throw Error('Secret already exists, try updating it instead.');
    }
    const writePath = path.join(this.vaultPath, secretName);
    // create the directory if it doesn't exist
    await this.efs.promises.mkdir(path.dirname(writePath), { recursive: true });
    // Write secret
    await this.efs.promises.writeFile(writePath, secret, {});

    // Update secrets map
    this.secrets.set(secretName, secret);
  }

  /**
   * Updates a secret in the vault
   * @param secretName Name of secret to be updated
   * @param secret Content of updated secret
   */
  async updateSecret(secretName: string, secret: Buffer): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      // Check if secret already exists
      if (!this.secrets.has(secretName)) {
        throw Error('Secret does not exist, try adding it instead.');
      }
      const writePath = path.join(this.vaultPath, secretName);
      // Write secret
      await this.efs.promises.writeFile(writePath, secret, {});
      // Update secrets map
      this.secrets.set(secretName, secret);
      // Auto commit message
      await this.commitChanges(
        [{ secretName, action: 'modified' }],
        `Update secret: ${secretName}`,
      );
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  /**
   * Get a secret from the vault
   * @param secretName Name of secret to be retrieved
   */
  getSecret(secretName: string): Buffer | string {
    if (this.secrets.has(secretName)) {
      const secret = this.secrets.get(secretName);
      if (secret) {
        return secret;
      } else {
        const secretPath = path.join(this.vaultPath, secretName);
        // TODO: this should be async
        const secretBuf = this.efs.readFileSync(secretPath, {});
        this.secrets.set(secretName, secretBuf);
        return secretBuf;
      }
    }
    throw Error('Secret: ' + secretName + ' does not exist');
  }

  /**
   * [WARNING] Deletes a secret from the vault
   * @param secretName Name of secret to be deleted or path of directory to delete
   * @param recursive Sub directories can only be deleted if this option is set to true
   */
  async deleteSecret(secretName: string, recursive = false): Promise<void> {
    const release = await this.mutex.acquire();
    try {
      // make secret path
      const fsPath = path.join(this.vaultPath, secretName);
      if (this.secrets.has(secretName)) {
        this.secrets.delete(secretName);
        // Remove from fs
        await this.efs.promises.unlink(fsPath);
        // Delete dir if it is empty
        const dirname = path.dirname(fsPath);
        if (
          this.vaultPath != dirname &&
          (await this.efs.promises.readdir(fsPath)).length == 0
        ) {
          await this.efs.promises.rmdir(fsPath, { recursive: true });
        }
        // Auto commit message
        await this.commitChanges(
          [{ secretName, action: 'removed' }],
          `Remove secret: ${secretName}`,
        );
        return;
      } else if ((await this.efs.promises.stat(fsPath)).isDirectory()) {
        if (recursive) {
          await this.efs.promises.rmdir(fsPath, { recursive: true });
          await this.commitChanges(
            [{ secretName, action: 'removed' }],
            `Remove directory: ${secretName}`,
          );
          return;
        } else {
          throw Error('delete a vault directory must be recursive');
        }
      }
      throw Error('path: ' + secretName + ' does not exist in vault');
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  /**
   * Lists all the secrets currently in the vault
   */
  listSecrets(): string[] {
    const secrets: string[] = Array.from(this.secrets.keys());
    return secrets;
  }

  tagVault() {
    throw Error('not implemented');
  }

  untagVault() {
    throw Error('not implemented');
  }

  /////////////
  // Sharing //
  /////////////
  /**
   * Allows a particular node to access the vault
   * @param nodeId NodeId of the node to share with
   */
  shareVault(nodeId: string, canEdit?: boolean) {
    if (this.sharedNodeIds.has(nodeId)) {
      if (canEdit && this.sharedNodeIds.get(nodeId)?.canEdit == canEdit) {
        throw Error(
          'vault is already shared with given node id and has the same permissions',
        );
      } else {
        throw Error('vault is already shared with given node id');
      }
    }

    this.sharedNodeIds.set(nodeId, { nodeId, canEdit: canEdit ?? false });

    // Write metadata
    this.writeMetadata();
  }

  /**
   * Removes access to the vault for a particular node
   * @param nodeId NodeId of the node to unshare with
   */
  unshareVault(nodeId: string) {
    if (!this.sharedNodeIds.has(nodeId)) {
      throw Error('vault is not shared with given nodeId');
    }

    this.sharedNodeIds.delete(nodeId);

    // Write metadata
    this.writeMetadata();
  }

  /**
   * Determines if a particular public key can access the vault
   * @param nodeId Public key to check
   */
  nodeCanPull(nodeId: string): boolean {
    return this.sharedNodeIds.has(nodeId);
  }

  /**
   * Determines if a particular public key can push to the vault upstream
   * @param nodeId Public key to check
   */
  nodeCanPush(nodeId: string): boolean {
    return (
      this.sharedNodeIds.has(nodeId) &&
      (this.sharedNodeIds.get(nodeId)?.canEdit ?? false)
    );
  }

  /**
   * Pulls the vault from a specific node
   * @param nodeId NodeId of node that owns vault to be pulled
   */
  async pullVault(nodeId: string) {
    const release = await this.mutex.acquire();
    try {
      // Strangely enough this is needed for pulls along with ref set to 'HEAD'
      // In isogit's documentation, this is just to get the currentBranch name
      // But it solves a bug whereby if not used, git.pull complains that it can't
      // find the master branch or HEAD
      await git.currentBranch({
        fs: { promises: this.efs.promises },
        dir: this.vaultPath,
        fullname: true,
      });
      // First pull
      const gitClient = this.gitFrontend.connectToNodeGit(nodeId);
      await git.pull({
        fs: { promises: this.efs.promises },
        http: gitClient,
        dir: this.vaultPath,
        url: 'http://' + '0.0.0.0:0' + '/' + this.name,
        ref: 'HEAD',
        singleBranch: true,
        author: {
          name: this.name,
        },
      });

      // Load any new secrets
      await this.loadSecrets();
    } catch (error) {
      throw error;
    } finally {
      release();
    }
  }

  async getVaultHistory(depth?: number) {
    const logs = await git.log({
      fs: { promises: this.efs.promises },
      dir: this.vaultPath,
      depth,
    });
    return logs.map((commit) => {
      return commit.commit.message;
    });
  }

  // ============== Helper methods ============== //
  private writeMetadata(): void {
    // mkdir first
    this.efs.mkdirSync(path.dirname(this.metadataPath), { recursive: true });

    // Create and write metadata
    this.efs.writeFileSync(
      this.metadataPath,
      JSON.stringify(this.sharedNodeIds, JSONMapReplacer),
    );
  }

  private loadMetadata(): void {
    if (this.efs.existsSync(this.metadataPath)) {
      const fileContents = this.efs.readFileSync(this.metadataPath).toString();
      this.sharedNodeIds = JSON.parse(fileContents, JSONMapReviver);
    } else {
      // Need to create it
      this.sharedNodeIds = new Map();
      this.writeMetadata();
    }
  }

  private async commitChanges(
    fileChanges: {
      secretName: string;
      action: 'added' | 'modified' | 'removed';
    }[],
    message: string,
  ): Promise<string> {
    for (const { secretName, action } of fileChanges) {
      if (action == 'removed') {
        await git.remove({
          fs: { promises: this.efs.promises },
          dir: this.vaultPath,
          filepath: secretName,
        });
      } else {
        await git.add({
          fs: { promises: this.efs.promises },
          dir: this.vaultPath,
          filepath: secretName,
        });
      }
    }

    return await git.commit({
      fs: { promises: this.efs.promises },
      dir: this.vaultPath,
      author: {
        name: this.name,
      },
      message: message,
    });
  }

  private async loadSecrets(): Promise<void> {
    // Remove all secrets first
    this.secrets.clear();
    for await (const secretFilePath of readdirRecursively(this.vaultPath)) {
      const secret = secretFilePath.replace(`${this.vaultPath}/`, '');
      this.secrets.set(secret, null);
    }
  }
}

export default Vault;
