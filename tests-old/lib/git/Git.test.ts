import os from 'os';
import fs from 'fs';
import path from 'path';
import git from 'isomorphic-git'
import { randomString } from '../../../src/utils';
import GitBackend from '../../../src/git/GitBackend';
import GitRequest from '../../../src/git/GitRequest';

describe('GitBackend and GitRequest classes', () => {
  let sourceDir: string
  let targetDir: string

  let repoName: string
  let sourceRepoPath: string
  let targetRepoPath: string

  let fileName: string
  let fileContents: Buffer

  let gitBackend: GitBackend
  let gitRequest: GitRequest

  beforeEach(async () => {

    sourceDir = fs.mkdtempSync(`${os.tmpdir}/pktest${randomString(5)}`)
    targetDir = fs.mkdtempSync(`${os.tmpdir}/pktest${randomString(5)}`)
    repoName = `repo-${randomString(5)}`
    sourceRepoPath = path.join(sourceDir, repoName)
    targetRepoPath = path.join(targetDir, repoName)
    fs.mkdirSync(sourceRepoPath, { recursive: true })
    // Initialize a git repo in sourceDir
    await git.init({
      fs,
      dir: sourceRepoPath,
    });

    // initial commit
    await git.commit({
      fs,
      dir: sourceRepoPath,
      author: {
        name: repoName,
      },
      message: 'init commit'
    });
    // Write packed-refs file because isomorphic git goes searching for it
    // and apparently its not autogenerated
    fs.writeFileSync(path.join(sourceRepoPath, '.git', 'packed-refs'), '# pack-refs with: peeled fully-peeled sorted');

    // create first file
    fileName = `some-file-${randomString(5)}`
    fileContents = Buffer.from(`some-file-contents-${randomString(5)}`)
    fs.writeFileSync(path.join(sourceRepoPath, fileName), fileContents)
    // commit that file
    await git.add({
      fs,
      dir: sourceRepoPath,
      filepath: fileName
    })
    await git.commit({
      fs,
      dir: sourceRepoPath,
      author: {
        name: repoName,
      },
      message: 'added first file'
    });

    // set up git backend
    gitBackend = new GitBackend(
      sourceDir,
      (_) => fs,
      (publicKey: string) => {
        return ['vault1', 'vault2']
      }
    )
    // create git request object
    gitRequest = new GitRequest(
      gitBackend.handleInfoRequest.bind(gitBackend),
      gitBackend.handlePackRequest.bind(gitBackend),
      gitBackend.handleVaultNamesRequest.bind(gitBackend),
    )
  })

  afterEach(() => {
    fs.rmdirSync(sourceDir, { recursive: true })
    fs.rmdirSync(targetDir, { recursive: true })
  })

  test('can clone a repository', async () => {
    await git.clone({
      fs: { promises: fs.promises },
      http: gitRequest,
      dir: targetRepoPath,
      url: `http://0.0.0.0/${repoName}`,
    });

    // check file has been cloned too
    expect(fs.readFileSync(path.join(sourceRepoPath, fileName))).toEqual(fileContents)
  })

  describe('Push Operations', () => {
    // todo add in testing when push functionaltiy is implemented
  })

  describe('Pull Operations', () => {
    beforeEach(async () => {
      // clone to the targetDir
      await git.clone({
        fs: { promises: fs.promises },
        http: gitRequest,
        dir: targetRepoPath,
        url: `http://0.0.0.0/${repoName}`
      });

      // set git config
      await git.setConfig({
        fs,
        dir: targetRepoPath,
        path: 'user.name',
        value: repoName
      })
    })

    test('file changes are reflected in pulled changes', async () => {
      const newFileContents = Buffer.from(`some new random change: ${randomString(5)}`)
      // change file in source repo
      fs.writeFileSync(path.join(sourceRepoPath, fileName), newFileContents)

      // add and commit
      await git.add({
        fs,
        dir: sourceRepoPath,
        filepath: fileName
      })
      await git.commit({
        fs,
        dir: sourceRepoPath,
        author: {
          name: repoName,
        },
        message: 'modified first file'
      });

      // pull in target repo
      await git.pull({
        fs,
        http: gitRequest,
        dir: targetRepoPath
      })

      // expect that the file contents have changed in target repo
      expect(fs.readFileSync(path.join(targetRepoPath, fileName))).toEqual(newFileContents)
    })
  })

  describe('Branch Operations', () => {
    let branchName: string
    beforeEach(async () => {
      // clone to the targetDir
      await git.clone({
        fs,
        http: gitRequest,
        dir: targetRepoPath,
        url: `http://0.0.0.0/${repoName}`
      });

      // set git config
      await git.setConfig({
        fs,
        dir: targetRepoPath,
        path: 'user.name',
        value: repoName
      })

      // add a new branch to the sourceDir
      branchName = `random-branch-name-${randomString(5)}`
      await git.branch({ fs, dir: sourceRepoPath, ref: branchName })
      expect(await git.listBranches({ fs, dir: sourceRepoPath })).toContainEqual(branchName)
    })

    test('can pull and checkout new remote branch', async () => {
      // pull from sourceDir to get new branch
      await git.pull({
        fs,
        http: gitRequest,
        dir: targetRepoPath,
      })

      // switch to new branch
      await git.checkout({
        fs,
        dir: targetRepoPath,
        ref: branchName
      })

      // branch is listed
      expect(await git.listBranches({ fs, dir: targetRepoPath })).toContainEqual(branchName)
    })
  })
})
